{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/Chainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CBORChainlink} from \"./vendor/CBORChainlink.sol\";\nimport {BufferChainlink} from \"./vendor/BufferChainlink.sol\";\n\n/**\n * @title Library for common Chainlink functions\n * @dev Uses imported CBOR library for encoding to buffer\n */\nlibrary Chainlink {\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\n\n  using CBORChainlink for BufferChainlink.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    BufferChainlink.buffer buf;\n  }\n\n  /**\n   * @notice Initializes a Chainlink request\n   * @dev Sets the ID, callback address, and callback function signature on the request\n   * @param self The uninitialized request\n   * @param jobId The Job Specification ID\n   * @param callbackAddr The callback address\n   * @param callbackFunc The callback function signature\n   * @return The initialized request\n   */\n  function initialize(\n    Request memory self,\n    bytes32 jobId,\n    address callbackAddr,\n    bytes4 callbackFunc\n  ) internal pure returns (Chainlink.Request memory) {\n    BufferChainlink.init(self.buf, defaultBufferSize);\n    self.id = jobId;\n    self.callbackAddress = callbackAddr;\n    self.callbackFunctionId = callbackFunc;\n    return self;\n  }\n\n  /**\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\n   * @param self The initialized request\n   * @param data The CBOR data\n   */\n  function setBuffer(Request memory self, bytes memory data) internal pure {\n    BufferChainlink.init(self.buf, data.length);\n    BufferChainlink.append(self.buf, data);\n  }\n\n  /**\n   * @notice Adds a string value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The string value to add\n   */\n  function add(\n    Request memory self,\n    string memory key,\n    string memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeString(value);\n  }\n\n  /**\n   * @notice Adds a bytes value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The bytes value to add\n   */\n  function addBytes(\n    Request memory self,\n    string memory key,\n    bytes memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeBytes(value);\n  }\n\n  /**\n   * @notice Adds a int256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The int256 value to add\n   */\n  function addInt(\n    Request memory self,\n    string memory key,\n    int256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeInt(value);\n  }\n\n  /**\n   * @notice Adds a uint256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The uint256 value to add\n   */\n  function addUint(\n    Request memory self,\n    string memory key,\n    uint256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeUInt(value);\n  }\n\n  /**\n   * @notice Adds an array of strings to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param values The array of string values to add\n   */\n  function addStringArray(\n    Request memory self,\n    string memory key,\n    string[] memory values\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < values.length; i++) {\n      self.buf.encodeString(values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ChainlinkClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Chainlink.sol\";\nimport \"./interfaces/ENSInterface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/ChainlinkRequestInterface.sol\";\nimport \"./interfaces/OperatorInterface.sol\";\nimport \"./interfaces/PointerInterface.sol\";\nimport {ENSResolver as ENSResolver_Chainlink} from \"./vendor/ENSResolver.sol\";\n\n/**\n * @title The ChainlinkClient contract\n * @notice Contract writers can inherit this contract in order to create requests for the\n * Chainlink network\n */\nabstract contract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\n  uint256 private constant AMOUNT_OVERRIDE = 0;\n  address private constant SENDER_OVERRIDE = address(0);\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private s_ens;\n  bytes32 private s_ensNode;\n  LinkTokenInterface private s_link;\n  OperatorInterface private s_oracle;\n  uint256 private s_requestCount = 1;\n  mapping(bytes32 => address) private s_pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackAddr address to operate the callback on\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildChainlinkRequest(\n    bytes32 specId,\n    address callbackAddr,\n    bytes4 callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\n    internal\n    view\n    returns (Chainlink.Request memory)\n  {\n    Chainlink.Request memory req;\n    return req.initialize(specId, address(this), callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      ChainlinkRequestInterface.oracleRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      address(this),\n      req.callbackFunctionId,\n      nonce,\n      ORACLE_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev This function supports multi-word response\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev This function supports multi-word response\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      OperatorInterface.operatorRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      req.callbackFunctionId,\n      nonce,\n      OPERATOR_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Make a request to an oracle\n   * @param oracleAddress The address of the oracle for the request\n   * @param nonce used to generate the request ID\n   * @param payment The amount of LINK to send for the request\n   * @param encodedRequest data encoded for request type specific format\n   * @return requestId The request ID\n   */\n  function _rawRequest(\n    address oracleAddress,\n    uint256 nonce,\n    uint256 payment,\n    bytes memory encodedRequest\n  ) private returns (bytes32 requestId) {\n    requestId = keccak256(abi.encodePacked(this, nonce));\n    s_pendingRequests[requestId] = oracleAddress;\n    emit ChainlinkRequested(requestId);\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \"unable to transferAndCall to oracle\");\n  }\n\n  /**\n   * @notice Allows a request to be cancelled if it has not been fulfilled\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\n   * Deletes the request from the `pendingRequests` mapping.\n   * Emits ChainlinkCancelled event.\n   * @param requestId The request ID\n   * @param payment The amount of LINK sent for the request\n   * @param callbackFunc The callback function specified for the request\n   * @param expiration The time of the expiration for the request\n   */\n  function cancelChainlinkRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunc,\n    uint256 expiration\n  ) internal {\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\n    delete s_pendingRequests[requestId];\n    emit ChainlinkCancelled(requestId);\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\n  }\n\n  /**\n   * @notice the next request count to be used in generating a nonce\n   * @dev starts at 1 in order to ensure consistent gas cost\n   * @return returns the next request count to be used in a nonce\n   */\n  function getNextRequestCount() internal view returns (uint256) {\n    return s_requestCount;\n  }\n\n  /**\n   * @notice Sets the stored oracle address\n   * @param oracleAddress The address of the oracle contract\n   */\n  function setChainlinkOracle(address oracleAddress) internal {\n    s_oracle = OperatorInterface(oracleAddress);\n  }\n\n  /**\n   * @notice Sets the LINK token address\n   * @param linkAddress The address of the LINK token contract\n   */\n  function setChainlinkToken(address linkAddress) internal {\n    s_link = LinkTokenInterface(linkAddress);\n  }\n\n  /**\n   * @notice Sets the Chainlink token address for the public\n   * network as given by the Pointer contract\n   */\n  function setPublicChainlinkToken() internal {\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  /**\n   * @notice Retrieves the stored address of the LINK token\n   * @return The address of the LINK token\n   */\n  function chainlinkTokenAddress() internal view returns (address) {\n    return address(s_link);\n  }\n\n  /**\n   * @notice Retrieves the stored address of the oracle contract\n   * @return The address of the oracle contract\n   */\n  function chainlinkOracleAddress() internal view returns (address) {\n    return address(s_oracle);\n  }\n\n  /**\n   * @notice Allows for a request which was created on another contract to be fulfilled\n   * on this contract\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\n   * @param requestId The request ID used for the response\n   */\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\n    s_pendingRequests[requestId] = oracleAddress;\n  }\n\n  /**\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\n   * @dev Accounts for subnodes having different resolvers\n   * @param ensAddress The address of the ENS contract\n   * @param node The ENS node hash\n   */\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\n    s_ens = ENSInterface(ensAddress);\n    s_ensNode = node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\n    setChainlinkToken(resolver.addr(linkSubnode));\n    updateChainlinkOracleWithENS();\n  }\n\n  /**\n   * @notice Sets the stored oracle contract with the address resolved by ENS\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\n   */\n  function updateChainlinkOracleWithENS() internal {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\n    setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  /**\n   * @notice Ensures that the fulfillment is valid for this contract\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\n   * @param requestId The request ID for fulfillment\n   */\n  function validateChainlinkCallback(bytes32 requestId)\n    internal\n    recordChainlinkFulfillment(requestId)\n  // solhint-disable-next-line no-empty-blocks\n  {\n\n  }\n\n  /**\n   * @dev Reverts if the sender is not the oracle of the request.\n   * Emits ChainlinkFulfilled event.\n   * @param requestId The request ID for fulfillment\n   */\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\n    require(msg.sender == s_pendingRequests[requestId], \"Source must be the oracle of the request\");\n    delete s_pendingRequests[requestId];\n    emit ChainlinkFulfilled(requestId);\n    _;\n  }\n\n  /**\n   * @dev Reverts if the request is already pending\n   * @param requestId The request ID for fulfillment\n   */\n  modifier notPendingRequest(bytes32 requestId) {\n    require(s_pendingRequests[requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 requestPrice,\n    bytes32 serviceAgreementID,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ENSInterface {\n  // Logged when the owner of a node assigns a new owner to a subnode.\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n  // Logged when the owner of a node transfers ownership to a new account.\n  event Transfer(bytes32 indexed node, address owner);\n\n  // Logged when the resolver for a node changes.\n  event NewResolver(bytes32 indexed node, address resolver);\n\n  // Logged when the TTL of a node changes\n  event NewTTL(bytes32 indexed node, uint64 ttl);\n\n  function setSubnodeOwner(\n    bytes32 node,\n    bytes32 label,\n    address owner\n  ) external;\n\n  function setResolver(bytes32 node, address resolver) external;\n\n  function setOwner(bytes32 node, address owner) external;\n\n  function setTTL(bytes32 node, uint64 ttl) external;\n\n  function owner(bytes32 node) external view returns (address);\n\n  function resolver(bytes32 node) external view returns (address);\n\n  function ttl(bytes32 node) external view returns (uint64);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface KeeperCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OracleInterface.sol\";\nimport \"./ChainlinkRequestInterface.sol\";\n\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\n  function operatorRequest(\n    address sender,\n    uint256 payment,\n    bytes32 specId,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function fulfillOracleRequest2(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes calldata data\n  ) external returns (bool);\n\n  function ownerTransferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\n\n  function getAuthorizedSenders() external returns (address[] memory);\n\n  function setAuthorizedSenders(address[] calldata senders) external;\n\n  function getForwarder() external returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OracleInterface {\n  function fulfillOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes32 data\n  ) external returns (bool);\n\n  function isAuthorizedSender(address node) external view returns (bool);\n\n  function withdraw(address recipient, uint256 amount) external;\n\n  function withdrawable() external view returns (uint256);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n\n  /*\n   * @notice Check to see if there exists a request commitment consumers\n   * for all consumers and keyhashes for a given sub.\n   * @param subId - ID of the subscription\n   * @return true if there exists at least one unfulfilled request for the subscription, false\n   * otherwise.\n   */\n  function pendingRequestExists(uint64 subId) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary BufferChainlink {\n  /**\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n   *      a capacity. The capacity may be longer than the current value, in\n   *      which case it can be extended without the need to allocate more memory.\n   */\n  struct buffer {\n    bytes buf;\n    uint256 capacity;\n  }\n\n  /**\n   * @dev Initializes a buffer with an initial capacity.\n   * @param buf The buffer to initialize.\n   * @param capacity The number of bytes of space to allocate the buffer.\n   * @return The buffer, for chaining.\n   */\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n    if (capacity % 32 != 0) {\n      capacity += 32 - (capacity % 32);\n    }\n    // Allocate space for the buffer data\n    buf.capacity = capacity;\n    assembly {\n      let ptr := mload(0x40)\n      mstore(buf, ptr)\n      mstore(ptr, 0)\n      mstore(0x40, add(32, add(ptr, capacity)))\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Initializes a new buffer from an existing bytes object.\n   *      Changes to the buffer may mutate the original value.\n   * @param b The bytes object to initialize the buffer with.\n   * @return A new buffer.\n   */\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n    buffer memory buf;\n    buf.buf = b;\n    buf.capacity = b.length;\n    return buf;\n  }\n\n  function resize(buffer memory buf, uint256 capacity) private pure {\n    bytes memory oldbuf = buf.buf;\n    init(buf, capacity);\n    append(buf, oldbuf);\n  }\n\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  /**\n   * @dev Sets buffer length to 0.\n   * @param buf The buffer to truncate.\n   * @return The original buffer, for chaining..\n   */\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\n    assembly {\n      let bufptr := mload(buf)\n      mstore(bufptr, 0)\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The start offset to write to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    require(len <= data.length);\n\n    if (off + len > buf.capacity) {\n      resize(buf, max(buf.capacity, len + off) * 2);\n    }\n\n    uint256 dest;\n    uint256 src;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Start address = buffer address + offset + sizeof(buffer length)\n      dest := add(add(bufptr, 32), off)\n      // Update buffer length if we're extending it\n      if gt(add(len, off), buflen) {\n        mstore(bufptr, add(len, off))\n      }\n      src := add(data, 32)\n    }\n\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    unchecked {\n      uint256 mask = (256**(32 - len)) - 1;\n      assembly {\n        let srcpart := and(mload(src), not(mask))\n        let destpart := and(mload(dest), mask)\n        mstore(dest, or(destpart, srcpart))\n      }\n    }\n\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function append(\n    buffer memory buf,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, len);\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, data.length);\n  }\n\n  /**\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write the byte at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeUint8(\n    buffer memory buf,\n    uint256 off,\n    uint8 data\n  ) internal pure returns (buffer memory) {\n    if (off >= buf.capacity) {\n      resize(buf, buf.capacity * 2);\n    }\n\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Address = buffer address + sizeof(buffer length) + off\n      let dest := add(add(bufptr, off), 32)\n      mstore8(dest, data)\n      // Update buffer length if we extended it\n      if eq(off, buflen) {\n        mstore(bufptr, add(buflen, 1))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n    return writeUint8(buf, buf.buf.length, data);\n  }\n\n  /**\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n   *      exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (left-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes32 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    unchecked {\n      uint256 mask = (256**len) - 1;\n      // Right-align data\n      data = data >> (8 * (32 - len));\n      assembly {\n        // Memory address of the buffer data\n        let bufptr := mload(buf)\n        // Address = buffer address + sizeof(buffer length) + off + len\n        let dest := add(add(bufptr, off), len)\n        mstore(dest, or(and(mload(dest), not(mask)), data))\n        // Update buffer length if we extended it\n        if gt(add(off, len), mload(bufptr)) {\n          mstore(bufptr, add(off, len))\n        }\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeBytes20(\n    buffer memory buf,\n    uint256 off,\n    bytes20 data\n  ) internal pure returns (buffer memory) {\n    return write(buf, off, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chhaining.\n   */\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, 32);\n  }\n\n  /**\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (right-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function writeInt(\n    buffer memory buf,\n    uint256 off,\n    uint256 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint256 mask = (256**len) - 1;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + off + sizeof(buffer length) + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n   * exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer.\n   */\n  function appendInt(\n    buffer memory buf,\n    uint256 data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return writeInt(buf, buf.buf.length, data, len);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.19;\n\nimport {BufferChainlink} from \"./BufferChainlink.sol\";\n\nlibrary CBORChainlink {\n  using BufferChainlink for BufferChainlink.buffer;\n\n  uint8 private constant MAJOR_TYPE_INT = 0;\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\n  uint8 private constant MAJOR_TYPE_STRING = 3;\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\n  uint8 private constant MAJOR_TYPE_MAP = 5;\n  uint8 private constant MAJOR_TYPE_TAG = 6;\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\n    if(value <= 23) {\n      buf.appendUint8(uint8((major << 5) | value));\n    } else if (value <= 0xFF) {\n      buf.appendUint8(uint8((major << 5) | 24));\n      buf.appendInt(value, 1);\n    } else if (value <= 0xFFFF) {\n      buf.appendUint8(uint8((major << 5) | 25));\n      buf.appendInt(value, 2);\n    } else if (value <= 0xFFFFFFFF) {\n      buf.appendUint8(uint8((major << 5) | 26));\n      buf.appendInt(value, 4);\n    } else {\n      buf.appendUint8(uint8((major << 5) | 27));\n      buf.appendInt(value, 8);\n    }\n  }\n\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\n    buf.appendUint8(uint8((major << 5) | 31));\n  }\n\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\n    if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, value);\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n    }\n  }\n\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\n    if(value < -0x10000000000000000) {\n      encodeSignedBigNum(buf, value);\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, uint(value));\n    } else if(value >= 0) {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n    }\n  }\n\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n    buf.append(value);\n  }\n\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n    encodeBytes(buf, abi.encode(value));\n  }\n\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\n  }\n\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n    buf.append(bytes(value));\n  }\n\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n  }\n\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n  }\n\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/ENSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSResolver {\n  function addr(bytes32 node) public view virtual returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/Aid.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./Infrastructure.sol\";\nimport \"./Forces.sol\";\nimport \"./Treasury.sol\";\nimport \"./Wonders.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./KeeperFile.sol\";\nimport \"./Senate.sol\";\nimport \"./CountryParameters.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title AidContract this contract facilitates aid being sent between nations\n/// @author OxSnosh\ncontract AidContract is Ownable {\n    address public countryMinter;\n    address public treasury;\n    address public forces;\n    address public keeper;\n    address public infrastructure;\n    address public wonder1;\n    address public senate;\n    address public countryParameters;\n    uint256 public aidProposalId;\n    uint256 proposalExpirationDays = 7;\n\n    CountryMinter mint;\n    WondersContract1 won1;\n    KeeperContract keep;\n    SenateContract sen;\n    CountryParametersContract param;\n\n    /// @dev this function is callable by the owner only\n    /// @dev this function will be called after deployment to initiate contract pointers within this contract\n    function settings(\n        address _countryMinter,\n        address _treasury,\n        address _forces,\n        address _infrastructure,\n        address _keeper,\n        address _wonder1,\n        address _senate,\n        address _countryParameters\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        treasury = _treasury;\n        forces = _forces;\n        infrastructure = _infrastructure;\n        keeper = _keeper;\n        keep = KeeperContract(_keeper);\n        wonder1 = _wonder1;\n        won1 = WondersContract1(_wonder1);\n        senate = _senate;\n        sen = SenateContract(_senate);\n        countryParameters = _countryParameters;\n        param = CountryParametersContract(_countryParameters);\n    }\n\n    struct Proposal {\n        uint256 proposalId;\n        uint256 dayProposed;\n        uint256 idSender;\n        uint256 idRecipient;\n        uint256 techAid;\n        uint256 balanceAid;\n        uint256 soldierAid;\n        bool accepted;\n        bool cancelled;\n    }\n\n    event AidProposed(\n        uint256 indexed proposalId,\n        uint256 indexed idSender,\n        uint256 indexed idRecipient,\n        uint256 dayProposed,\n        uint256 techAid,\n        uint256 balanceAid,\n        uint256 soldierAid\n    );\n\n    event AidAccepted(\n        uint256 indexed proposalId,\n        uint256 indexed idSender,\n        uint256 indexed idRecipient,\n        uint256 techAid,\n        uint256 balanceAid,\n        uint256 soldierAid\n    );\n\n    event ProposalCancelled(\n        uint256 indexed proposalId,\n        uint256 indexed idSender,\n        uint256 indexed idRecipient\n    );\n\n    mapping(uint256 => Proposal) public idToProposal;\n    mapping(uint256 => uint256[]) public idToAidProposalsSent;\n    mapping(uint256 => uint256[]) public idToAidProposalsReceived;\n    mapping(uint256 => mapping(uint256 => uint256[]))\n        public idToAidProposalsLast10Days;\n\n    /// @dev this is the function a nations owner will call to initiate an aid proposal\n    /// @param idSender is the country ID of the aid sender (caller of the function)\n    /// @param idRecipient is the country ID of the aid recipient\n    /// @param techAid is the amount of Technology being sent in the proposal\n    /// @param balanceAid is the amount of balance being sent in the proposal\n    /// @param soldiersAid is the amount of troops beind sent in the proposal\n    /// @notice the max aid is 100 Tech, 6,000,000 balance and 4,000 soldiers without a Federal Aid Commission\n    /// @notice the max aid is 150 Tech, 9,000,000 balance and 6,000 soldiers with a Federal Aid Commission\n    function proposeAid(\n        uint256 idSender,\n        uint256 idRecipient,\n        uint256 techAid,\n        uint256 balanceAid,\n        uint256 soldiersAid\n    ) public {\n        bool isOwner = mint.checkOwnership(idSender, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        bool availableAidSlot = checkAidSlots(idSender);\n        require(availableAidSlot, \"aid slot not available\");\n        bool availableAidSlotRecipient = checkAidSlots(idRecipient);\n        require(availableAidSlotRecipient, \"recipient aid slot not available\");\n        uint256 day = keep.getGameDay();\n        idToAidProposalsLast10Days[idSender][day].push(aidProposalId);\n        idToAidProposalsLast10Days[idRecipient][day].push(aidProposalId);\n        bool aidAvailable = checkAvailability(\n            idSender,\n            techAid,\n            balanceAid,\n            soldiersAid\n        );\n        require(aidAvailable, \"aid not available\");\n        bool sanctioned = sen.isSanctioned(idSender, idRecipient);\n        require(!sanctioned, \"trade not possible\");\n        bool federalAidEligable = getFederalAidEligability(\n            idSender,\n            idRecipient\n        );\n        uint256[3] memory maximums;\n        if (!federalAidEligable) {\n            maximums = [\n                uint256(100),\n                uint256(6000000 * (10 ** 18)),\n                uint256(4000)\n            ];\n        }\n        if (federalAidEligable) {\n            maximums = [\n                uint256(150),\n                uint256(9000000 * (10 ** 18)),\n                uint256(6000)\n            ];\n        }\n        require(techAid <= maximums[0], \"max tech exceeded\");\n        require(balanceAid <= maximums[1], \"max balance excedded\");\n        require(soldiersAid <= maximums[2], \"max soldier aid is excedded\");\n        completeProposal(\n            aidProposalId,\n            day,\n            idSender,\n            idRecipient,\n            techAid,\n            balanceAid,\n            soldiersAid\n        );\n        aidProposalId++;\n    }\n\n    function completeProposal(\n        uint256 proposalId,\n        uint256 day,\n        uint256 idSender,\n        uint256 idRecipient,\n        uint256 techAid,\n        uint256 balanceAid,\n        uint256 soldiersAid\n    ) internal {\n        Proposal memory newProposal = Proposal(\n            aidProposalId,\n            day,\n            idSender,\n            idRecipient,\n            techAid,\n            balanceAid,\n            soldiersAid,\n            false,\n            false\n        );\n        idToProposal[aidProposalId] = newProposal;\n        idToAidProposalsSent[idSender].push(aidProposalId);\n        idToAidProposalsReceived[idRecipient].push(aidProposalId);\n        emit AidProposed(\n            proposalId,\n            idSender,\n            idRecipient,\n            day,\n            techAid,\n            balanceAid,\n            soldiersAid\n        );\n    }\n\n    ///@dev this function is public but called by the proposeAid() function to check the availabiliy of proposing aid\n    ///@notice nations can only send one aid proposal per day without a Disaster Relief Agency\n    ///@notice nations can send 2 aid porposals per day with a disaster relief agency\n    ///@param idSender id the nation ID of the nation proposing aid\n    ///@return bool returns a boolean value if there is an aid slot available for the prpoposal\n    function checkAidSlots(uint256 idSender) public view returns (bool) {\n        uint256 maxAidSlots = getMaxAidSlots(idSender);\n        uint256 aidProposalsLast10Days = getAidProposalsLast10Days(idSender);\n        if ((aidProposalsLast10Days + 1) <= maxAidSlots) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    ///@dev this function is public but also callable from the proposeAid() function\n    ///@notice this function checks max aid slots per day for a nation\n    ///@notice max aid slots allow you to propose 10 aid packages every 10 days (13 with a disaster relief agency)\n    ///@param id id the nation ID of the nation proposing aid\n    ///@return uint256 defaults to 1 aid slot per day and 2 with a disaster relief agency\n    function getMaxAidSlots(uint256 id) public view returns (uint256) {\n        uint256 maxAidSlotsPer10Days = 10;\n        bool disasterReliefAgency = won1.getDisasterReliefAgency(id);\n        if (disasterReliefAgency) {\n            maxAidSlotsPer10Days += 3;\n        }\n        return (maxAidSlotsPer10Days);\n    }\n\n    function getAidProposalsLast10Days(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 day = keep.getGameDay();\n        uint256 proposalsLast10Days = 0;\n        uint256 daysToCheck;\n        if (day >= 10) {\n            daysToCheck = 10;\n        } else {\n            daysToCheck = day;\n        }\n        for (uint256 i = 0; i <= daysToCheck; i++) {\n            uint256 dayToCheck = day - i;\n            proposalsLast10Days += idToAidProposalsLast10Days[id][dayToCheck]\n                .length;\n            uint256[] memory proposalsForThatDay = idToAidProposalsLast10Days[\n                id\n            ][dayToCheck];\n            for (uint256 j = 0; j < proposalsForThatDay.length; j++) {\n                uint256 proposalId = proposalsForThatDay[j];\n                bool cancelled = idToProposal[proposalId].cancelled;\n                if (cancelled) {\n                    proposalsLast10Days -= 1;\n                }\n            }\n        }\n        return proposalsLast10Days;\n    }\n\n    ///@dev this function is public but also callable by the proposeAid() and acceptProposal() function\n    ///@notice this function checks that the aid proposed is less than the available aid of the sender nation\n    ///@param idSender is the nation ID of the nations proposing aid\n    ///@param techAid is the amount of Tech in the aid proposal\n    ///@param balanceAid is the amount of Balance in the aid proposal\n    ///@param soldiersAid is the amount of soldiers in the aid proposal\n    ///@return bool true if the sender has enough of each aid parameter to send\n    function checkAvailability(\n        uint256 idSender,\n        uint256 techAid,\n        uint256 balanceAid,\n        uint256 soldiersAid\n    ) public view returns (bool) {\n        uint256 techAvailable = InfrastructureContract(infrastructure)\n            .getTechnologyCount(idSender);\n        uint256 balanceAvailable = TreasuryContract(treasury).checkBalance(\n            idSender\n        );\n        uint256 soldiersAvailable = ForcesContract(forces)\n            .getDefendingSoldierCount(idSender);\n        require(techAvailable >= techAid, \"not enough tech for this proposal\");\n        require(\n            balanceAvailable >= balanceAid,\n            \"not enough funds for this porposal\"\n        );\n        require(\n            soldiersAvailable >= soldiersAid,\n            \"not enough soldiers for this porposal\"\n        );\n        return true;\n    }\n\n    ///@dev this function is a public view function that is called by the proposeAid() function\n    ///@notice if both nations have a federal aid commission then max aid amounts increase 50%\n    ///@param idSender is the nation ID of the sender of the aid proposal\n    ///@param idRecipient id the nation ID of the recipient of the aid proposal\n    ///@return bool true if both sender and reciever have a federal aid commission\n    function getFederalAidEligability(\n        uint256 idSender,\n        uint256 idRecipient\n    ) public view returns (bool) {\n        bool senderEligable = won1.getFederalAidComission(idSender);\n        bool recipientEligable = won1.getFederalAidComission(idRecipient);\n        if (senderEligable && recipientEligable) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    ///@dev this finction is only callable by the owner of the contract\n    ///@dev this function allows the contract owner to set how long aid proposals stay active for\n    function setProposalExpiration(uint256 newExpiration) public onlyOwner {\n        proposalExpirationDays = newExpiration;\n    }\n\n    ///@dev this is a view function that allows anyone to view the duration aid proposals have untile they expire\n    ///@return uint256 the number of days a proposal has to be exepted otherwise it expires\n    function getProposalExpiration() public view returns (uint256) {\n        return proposalExpirationDays;\n    }\n\n    ///@dev this function is a public view function that checks to see if an aid propoals is expired (too much time has elapsed since proposal)\n    ///@notice this function will prevent an aid proposal from being fulfilled if the proposal is passed the expiration duration\n    ///@param proposalId id the ID of the aid proposal\n    ///@return bool true if amount of time elapsed since proposal is greater than the proposal expiration time\n    function proposalExpired(uint256 proposalId) public view returns (bool) {\n        uint256 day = keep.getGameDay();\n        uint256 dayProposed = idToProposal[proposalId].dayProposed;\n        uint256 timeElapsed = (day - dayProposed);\n        bool expired = false;\n        if (timeElapsed > proposalExpirationDays) {\n            expired = true;\n        }\n        return expired;\n    }\n\n    ///@dev this is a public function that is callable by the recipient of the aid proposal\n    ///@notice this function is called by the recipient of an aid proposal in order to accept the aid\n    ///@param proposalId this id the ID of the aid proposal\n    function acceptProposal(uint256 proposalId) public {\n        bool expired = proposalExpired(proposalId);\n        require(expired == false, \"proposal expired\");\n        uint256 idSender = idToProposal[proposalId].idSender;\n        uint256 idRecipient = idToProposal[proposalId].idRecipient;\n        uint256 tech = idToProposal[proposalId].techAid;\n        uint256 balance = idToProposal[proposalId].balanceAid;\n        uint256 soldiers = idToProposal[proposalId].soldierAid;\n        bool accepted = idToProposal[proposalId].accepted;\n        require(accepted == false, \"this offer has been accepted already\");\n        bool cancelled = idToProposal[proposalId].cancelled;\n        require(cancelled == false, \"this offer has been cancelled\");\n        address addressRecipient = mint.ownerOf(idRecipient);\n        require(\n            addressRecipient == msg.sender,\n            \"you are not the recipient of this proposal\"\n        );\n        bool sanctioned = sen.isSanctioned(idSender, idRecipient);\n        require(!sanctioned, \"trade not possible\");\n        bool available = checkAvailability(idSender, tech, balance, soldiers);\n        require(available, \"balances not available\");\n        InfrastructureContract(infrastructure).sendTech(\n            idSender,\n            idRecipient,\n            tech\n        );\n        TreasuryContract(treasury).sendAidBalance(\n            idSender,\n            idRecipient,\n            balance\n        );\n        ForcesContract(forces).sendSoldiers(idSender, idRecipient, soldiers);\n        idToProposal[proposalId].accepted = true;\n        finishAcceptProposal(\n            proposalId,\n            idSender,\n            idRecipient,\n            tech,\n            balance,\n            soldiers\n        );\n    }\n\n    function finishAcceptProposal(\n        uint256 proposalId,\n        uint256 idSender,\n        uint256 idRecipient,\n        uint256 tech,\n        uint256 balance,\n        uint256 soldiers\n    ) internal {\n        uint256[] storage senderProposals = idToAidProposalsSent[idSender];\n        uint256[] storage recipientProposals = idToAidProposalsReceived[\n            idRecipient\n        ];\n        uint256 day = keep.getGameDay();\n        for (uint256 i = 0; i < senderProposals.length; i++) {\n            if (senderProposals[i] == proposalId) {\n                senderProposals[i] = senderProposals[senderProposals.length - 1];\n                senderProposals.pop();\n            }\n            Proposal memory proposal = idToProposal[proposalId];\n            if (day - proposal.dayProposed > 10) {\n                senderProposals[i] = senderProposals[senderProposals.length - 1];\n                senderProposals.pop();                    \n            }\n        }\n        for (uint256 i = 0; i < recipientProposals.length; i++) {\n            if (recipientProposals[i] == proposalId) {\n                recipientProposals[i] = recipientProposals[recipientProposals\n                    .length - 1];\n                recipientProposals.pop();\n            }\n            Proposal memory proposal = idToProposal[proposalId];\n            if (day - proposal.dayProposed > 10) {\n                recipientProposals[i] = recipientProposals[recipientProposals\n                    .length - 1];\n                recipientProposals.pop();                    \n            }\n        }\n        emit AidAccepted(\n            proposalId,\n            idSender,\n            idRecipient,\n            tech,\n            balance,\n            soldiers\n        );\n    }\n\n    ///@dev this function is a public function that allows the aid proposal to be cancelled by the sender of the proposal\n    ///@notice this function allows the aid sender or recipient to cancel an aid proposal prior to it being accepted\n    ///@param proposalId this is the id of the proposal\n    function cancelAid(uint256 proposalId) public {\n        uint256 idRecipient = idToProposal[proposalId].idRecipient;\n        uint256 idSender = idToProposal[proposalId].idSender;\n        address addressRecipient = mint.ownerOf(idRecipient);\n        address addressSender = mint.ownerOf(idSender);\n        require(\n            addressSender == msg.sender || addressRecipient == msg.sender,\n            \"caller not a participant in this trade\"\n        );\n        bool cancelled = idToProposal[proposalId].cancelled;\n        require(cancelled == false, \"trade already cancelled\");\n        bool accepted = idToProposal[proposalId].accepted;\n        require(accepted == false, \"trade already accepted\");\n        bool expired = proposalExpired(proposalId);\n        require(expired == false, \"trade already expired\");\n        idToProposal[proposalId].cancelled = true;\n        uint256 nationCancelling;\n        if (addressSender == msg.sender) {\n            nationCancelling = idSender;\n        } else if (addressRecipient == msg.sender) {\n            nationCancelling = idRecipient;\n        }\n        completeCancelAid(proposalId, idSender, idRecipient);\n    }\n\n    function completeCancelAid(\n        uint256 proposalId,\n        uint256 idSender,\n        uint256 idRecipient\n    ) internal {\n        uint256[] storage senderProposals = idToAidProposalsSent[idSender];\n        uint256[] storage recipientProposals = idToAidProposalsReceived[\n            idRecipient\n        ];\n        uint256 day = keep.getGameDay();\n        for (uint256 i = 0; i < senderProposals.length; i++) {\n            if (senderProposals[i] == proposalId) {\n                senderProposals[i] = senderProposals[senderProposals.length - 1];\n                senderProposals.pop();\n            }\n            Proposal memory proposal = idToProposal[proposalId];\n            if (day - proposal.dayProposed > 10) {\n                senderProposals[i] = senderProposals[senderProposals.length - 1];\n                senderProposals.pop();                    \n            }\n        }\n        for (uint256 i = 0; i < recipientProposals.length; i++) {\n            if (recipientProposals[i] == proposalId) {\n                recipientProposals[i] = recipientProposals[recipientProposals\n                    .length - 1];\n                recipientProposals.pop();\n            }\n            Proposal memory proposal = idToProposal[proposalId];\n            if (day - proposal.dayProposed > 10) {\n                recipientProposals[i] = recipientProposals[recipientProposals\n                    .length - 1];\n                recipientProposals.pop();                    \n            }\n        }\n        emit ProposalCancelled(\n            proposalId,\n            idSender,\n            idRecipient\n        );\n\n    }\n\n    ///@dev this is public view function that allows a caller to return the items in a proposal struct\n    ///@return uint256 this funtion returns the contects of a proposal struct\n    function getProposal(\n        uint256 proposalId\n    )\n        public\n        view\n        returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256)\n    {\n        return (\n            idToProposal[proposalId].proposalId,\n            idToProposal[proposalId].dayProposed,\n            idToProposal[proposalId].idSender,\n            idToProposal[proposalId].idRecipient,\n            idToProposal[proposalId].techAid,\n            idToProposal[proposalId].balanceAid,\n            idToProposal[proposalId].soldierAid\n        );\n    }\n\n    ///@dev this function is a public view function that allows the caller to see if an aid proposal is cancelled or accepted already\n    ///@return bool true if the proposal has cancelled or accepted\n    function checkCancelledOrAccepted(\n        uint256 proposalId\n    ) public view returns (bool, bool) {\n        return (\n            idToProposal[proposalId].accepted,\n            idToProposal[proposalId].cancelled\n        );\n    }\n\n    function getProposalsSent(uint256 id)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return idToAidProposalsSent[id];\n    }\n\n    function getProposalsReceived(uint256 id)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return idToAidProposalsReceived[id];\n    }\n}\n"
    },
    "contracts/AirBattle.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./War.sol\";\nimport \"./Fighters.sol\";\nimport \"./Bombers.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Forces.sol\";\nimport \"./Wonders.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./Forces.sol\";\nimport \"./Missiles.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\n\n///@title AirBattleContract\n///@author OxSnosh\n///@dev this contract allows you to launch a bombing campaign against another nation\ncontract AirBattleContract is Ownable, VRFConsumerBaseV2, ChainlinkClient {\n    using Chainlink for Chainlink.Request;\n\n    uint256 airBattleId;\n    address warAddress;\n    address fighterAddress;\n    address bomberAddress;\n    address infrastructure;\n    address forces;\n    address missiles;\n    address wonders1;\n    address fighterLosses;\n    address countryMinter;\n    address addAirBattleAddress;\n    //fighter strength\n    uint256 yak9Strength = 1;\n    uint256 p51MustangStrength = 2;\n    uint256 f86SabreStrength = 3;\n    uint256 mig15Strength = 4;\n    uint256 f100SuperSabreStrength = 5;\n    uint256 f35LightningStrength = 6;\n    uint256 f15EagleStrength = 7;\n    uint256 su30MkiStrength = 8;\n    uint256 f22RaptorStrength = 9;\n    //bomber strength\n    uint256 ah1CobraStrength = 1;\n    uint256 ah64ApacheStrength = 2;\n    uint256 bristolBlenheimStrength = 3;\n    uint256 b52MitchellStrength = 4;\n    uint256 b17gFlyingFortressStrength = 5;\n    uint256 b52StratofortressStrength = 6;\n    uint256 b2SpiritStrength = 7;\n    uint256 b1bLancerStrength = 8;\n    uint256 tupolevTu160Strength = 9;\n\n    WarContract war;\n    FightersContract fighter;\n    BombersContract bomber;\n    InfrastructureContract inf;\n    ForcesContract force;\n    MissilesContract mis;\n    WondersContract1 won1;\n    FighterLosses fighterLoss;\n    CountryMinter mint;\n    AdditionalAirBattle addAirBattle;\n\n    uint256[] private s_randomWords;\n    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;\n    uint64 private immutable i_subscriptionId;\n    bytes32 private immutable i_gasLane;\n    uint32 private immutable i_callbackGasLimit;\n    uint16 private constant REQUEST_CONFIRMATIONS = 3;\n    uint32 private constant NUM_WORDS = 6;\n\n    struct AirBattle {\n        uint256 warId;\n        uint256 attackerId;\n        uint256 defenderId;\n        uint256[] attackerFighterArray;\n        uint256[] attackerBomberArray;\n        uint256[] defenderFighterArray;\n        uint256[] attackerFighterCasualties;\n        uint256[] attackerBomberCasualties;\n        uint256[] defenderFighterCasualties;\n        uint256[] damage;\n    }\n\n    event AirAssaultLaunched(\n        uint256 indexed battleId,\n        uint256 indexed attackerId,\n        uint256 indexed defenderId,\n        uint256[] attackerFighterArray,\n        uint256[] attackerBomberArray,\n        uint256[] defenderFighterArray,\n        uint256 warId\n    );\n\n\n    mapping(uint256 => AirBattle) airBattleIdToAirBattle;\n\n    mapping(uint256 => uint256) s_requestIdToRequestIndex;\n    mapping(uint256 => uint256[]) public s_requestIndexToRandomWords;\n\n    ///@dev this is the constructor funtion for the contact\n    constructor(\n        address vrfCoordinatorV2,\n        uint64 subscriptionId,\n        bytes32 gasLane,\n        uint32 callbackGasLimit\n    ) VRFConsumerBaseV2(vrfCoordinatorV2) {\n        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2);\n        i_gasLane = gasLane;\n        i_subscriptionId = subscriptionId;\n        i_callbackGasLimit = callbackGasLimit;\n    }\n\n    ///@dev this function is only callable by the owner\n    ///@dev this function will be called right after deployment in order to set up contract pointers\n    function settings(\n        address _warAddress,\n        address _fighter,\n        address _bomber,\n        address _infrastructure,\n        address _forces,\n        address _fighterLosses,\n        address _mint,\n        address _addAirBattle\n    ) public onlyOwner {\n        warAddress = _warAddress;\n        war = WarContract(_warAddress);\n        fighterAddress = _fighter;\n        fighter = FightersContract(_fighter);\n        bomberAddress = _bomber;\n        bomber = BombersContract(_bomber);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        forces = _forces;\n        force = ForcesContract(_forces);\n        fighterLosses = _fighterLosses;\n        fighterLoss = FighterLosses(_fighterLosses);\n        countryMinter = _mint;\n        mint = CountryMinter(_mint);\n        addAirBattleAddress = _addAirBattle;\n        addAirBattle = AdditionalAirBattle(_addAirBattle);\n    }\n\n    ///@dev this function is a public function\n    ///@notice this function allows one nation to launch a bombing campaign against another nation\n    ///@notice can only be called if a war is active between the two nations\n    ///@param warId is the ID of the current war between the two nations\n    ///@param attackerId is the nation ID of the attacker nation\n    // /@param defenderId is the nation ID of the defending nation\n    function airBattle(\n        uint256 warId,\n        uint256 attackerId,\n        uint256 defenderId,\n        uint256[] memory attackerFighterArray,\n        uint256[] memory attackerBomberArray\n    ) public {\n        bool isOwner = mint.checkOwnership(attackerId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        bool isActiveWar = war.isWarActive(warId);\n        require(isActiveWar, \"!not active war\");\n        (uint256 warOffense, uint256 warDefense) = war.getInvolvedParties(\n            warId\n        );\n        require(\n            warOffense == attackerId || warOffense == defenderId,\n            \"attacker not involved in this war\"\n        );\n        require(\n            warDefense == attackerId || warDefense == defenderId,\n            \"defender not involved in this war\"\n        );\n        uint256 attackerFighterSum = getAttackerFighterSum(\n            attackerFighterArray\n        );\n        uint256 attackerBomberSum = getAttackerBomberSum(attackerBomberArray);\n        // airBattleIdToAttackerFighterSum[airBattleId] = attackerFighterSum;\n        // airBattleIdToAttackerBomberSum[airBattleId] = attackerBomberSum;\n        uint256 attackSum = (attackerFighterSum + attackerBomberSum);\n        require(attackSum <= 25, \"cannot send more than 25 planes on a sortie\");\n        bool fighterCheck = verifyAttackerFighterArrays(\n            attackerId,\n            attackerFighterArray\n        );\n        bool bomberCheck = verifyAttackerBomberArray(\n            attackerId,\n            attackerBomberArray\n        );\n        require(fighterCheck, \"!fighter check\");\n        require(bomberCheck, \"!bomber check\");\n        completeAirBattleLaunch(\n            warId,\n            attackerId,\n            defenderId,\n            attackerFighterArray,\n            attackerBomberArray,\n            airBattleId\n        );\n        airBattleId++;\n    }\n\n    function completeAirBattleLaunch(\n        uint256 warId,\n        uint256 attackerId,\n        uint256 defenderId,\n        uint256[] memory attackerFighterArray,\n        uint256[] memory attackerBomberArray,\n        uint256 _airBattleId\n    ) internal {\n        war.cancelPeaceOffersUponAttack(warId);\n        AirBattle storage newAirBattle = airBattleIdToAirBattle[_airBattleId];\n        newAirBattle.warId = warId;\n        newAirBattle.attackerId = attackerId;\n        newAirBattle.defenderId = defenderId;\n        newAirBattle.attackerFighterArray = attackerFighterArray;\n        newAirBattle.attackerBomberArray = attackerBomberArray;\n        uint256[] memory defenderFighterArray = generateDefenderFighters(\n            defenderId,\n            _airBattleId\n        );\n        emit AirAssaultLaunched(\n            airBattleId,\n            attackerId,\n            defenderId,\n            attackerFighterArray,\n            attackerBomberArray,\n            defenderFighterArray,\n            warId\n        );\n        fulfillRequest(_airBattleId);\n    }\n\n    //make a function that will verify that the attacker has the planes included in the arrays\n    function verifyAttackerFighterArrays(\n        uint256 attackerId,\n        uint256[] memory attackerFighterArray\n    ) internal view returns (bool) {\n        require(\n            fighter.getYak9Count(attackerId) >= attackerFighterArray[0],\n            \"not enough yak9s\"\n        );\n        require(\n            fighter.getP51MustangCount(attackerId) >= attackerFighterArray[1],\n            \"not enough p51s\"\n        );\n        require(\n            fighter.getF86SabreCount(attackerId) >= attackerFighterArray[2],\n            \"not enough f86s\"\n        );\n        require(\n            fighter.getMig15Count(attackerId) >= attackerFighterArray[3],\n            \"not enough mig15s\"\n        );\n        require(\n            fighter.getF100SuperSabreCount(attackerId) >=\n                attackerFighterArray[4],\n            \"not enough f100s\"\n        );\n        require(\n            fighter.getF35LightningCount(attackerId) >= attackerFighterArray[5],\n            \"not enough f35s\"\n        );\n        require(\n            fighter.getF15EagleCount(attackerId) >= attackerFighterArray[6],\n            \"not enough f15s\"\n        );\n        require(\n            fighter.getSu30MkiCount(attackerId) >= attackerFighterArray[7],\n            \"not enough su30s\"\n        );\n        require(\n            fighter.getF22RaptorCount(attackerId) >= attackerFighterArray[8],\n            \"not enough f22s\"\n        );\n        return true;\n    }\n\n    function getAttackerFighterSum(\n        uint256[] memory attackerFighterArray\n    ) internal pure returns (uint256) {\n        uint256 sum = 0;\n        for (uint256 i = 0; i < attackerFighterArray.length; i++) {\n            sum += attackerFighterArray[i];\n        }\n        return sum;\n    }\n\n    function getAttackerBomberSum(\n        uint256[] memory attackerBomberArray\n    ) internal pure returns (uint256) {\n        uint256 sum = 0;\n        for (uint256 i = 0; i < attackerBomberArray.length; i++) {\n            sum += attackerBomberArray[i];\n        }\n        return sum;\n    }\n\n    function verifyAttackerBomberArray(\n        uint256 attackerId,\n        uint256[] memory attackerBomberArray\n    ) internal view returns (bool) {\n        require(\n            bomber.getAh64ApacheCount(attackerId) >= attackerBomberArray[1],\n            \"not enough ah64s\"\n        );\n        require(\n            bomber.getBristolBlenheimCount(attackerId) >=\n                attackerBomberArray[2],\n            \"not enough bristols\"\n        );\n        require(\n            bomber.getB52MitchellCount(attackerId) >= attackerBomberArray[3],\n            \"not enough b52 Mitchells\"\n        );\n        require(\n            bomber.getB17gFlyingFortressCount(attackerId) >=\n                attackerBomberArray[4],\n            \"not enough b17s\"\n        );\n        require(\n            bomber.getB52StratofortressCount(attackerId) >=\n                attackerBomberArray[5],\n            \"not enough b52 Strato's\"\n        );\n        require(\n            bomber.getB2SpiritCount(attackerId) >= attackerBomberArray[6],\n            \"not enough b2 Spirits\"\n        );\n        require(\n            bomber.getB1bLancerCount(attackerId) >= attackerBomberArray[7],\n            \"not enough b1b Lancers\"\n        );\n        require(\n            bomber.getTupolevTu160Count(attackerId) >= attackerBomberArray[8],\n            \"not enough tupolev's\"\n        );\n        return true;\n    }\n\n    function generateDefenderFighters(\n        uint256 defenderId,\n        uint256 _airBattleId\n    ) internal returns (uint256[] memory) {\n        uint256[] memory defenderFighterArray = new uint256[](9);\n        defenderFighterArray[0] = fighter.getYak9Count(defenderId);\n        defenderFighterArray[1] = fighter.getP51MustangCount(defenderId);\n        defenderFighterArray[2] = fighter.getF86SabreCount(defenderId);\n        defenderFighterArray[3] = fighter.getMig15Count(defenderId);\n        defenderFighterArray[4] = fighter.getF100SuperSabreCount(defenderId);\n        defenderFighterArray[5] = fighter.getF35LightningCount(defenderId);\n        defenderFighterArray[6] = fighter.getF15EagleCount(defenderId);\n        defenderFighterArray[7] = fighter.getSu30MkiCount(defenderId);\n        defenderFighterArray[8] = fighter.getF22RaptorCount(defenderId);\n        AirBattle storage newAirBattle = airBattleIdToAirBattle[_airBattleId];\n        newAirBattle.defenderFighterArray = defenderFighterArray;\n        return defenderFighterArray;\n    }\n\n    function fulfillRequest(uint256 battleId) public {\n        console.log(\"arrived to fulfillRequest()\");\n        uint256 requestId = i_vrfCoordinator.requestRandomWords(\n            i_gasLane,\n            i_subscriptionId,\n            REQUEST_CONFIRMATIONS,\n            i_callbackGasLimit,\n            NUM_WORDS\n        );\n        s_requestIdToRequestIndex[requestId] = battleId;\n        console.log(\"arrived to end of fulfillRequest()\");\n    }\n\n    bytes32 jobId;\n    address oracleAddress;\n    uint256 fee;\n\n    function updateJobId(bytes32 _jobId) public onlyOwner {\n        jobId = _jobId;\n    }\n\n    function updateOracleAddress(address _oracleAddress) public onlyOwner {\n        oracleAddress = _oracleAddress;\n        setChainlinkOracle(_oracleAddress);\n    }\n\n    function updateFee(uint256 _fee) public onlyOwner {\n        fee = _fee;\n    }\n\n    function updateLinkAddress(address _linkAddress) public onlyOwner {\n        setChainlinkToken(_linkAddress);\n    }\n\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) internal override {\n        console.log(\"arrived to fulfillRandomWords()\");\n        console.log(randomWords[0]);\n        console.log(randomWords[1]);\n        console.log(randomWords[2]);\n        console.log(randomWords[3]);\n        console.log(randomWords[4]);\n        console.log(randomWords[5]);\n        uint256 requestNumber = s_requestIdToRequestIndex[requestId];\n        s_requestIndexToRandomWords[requestNumber] = randomWords;\n        Chainlink.Request memory req = buildOperatorRequest(\n            jobId,\n            this.completeAirBattle.selector\n        );\n        bytes memory defenderFighters = abi.encode(\n            airBattleIdToAirBattle[requestNumber].defenderFighterArray\n        );\n        bytes memory attackerFighters = abi.encode(\n            airBattleIdToAirBattle[requestNumber].attackerFighterArray\n        );\n        bytes memory attackerBombers = abi.encode(\n            airBattleIdToAirBattle[requestNumber].attackerBomberArray\n        );\n        uint256 attackerId = airBattleIdToAirBattle[requestNumber].attackerId;\n        uint256 defenderId = airBattleIdToAirBattle[requestNumber].defenderId;\n        uint256 attackId = s_requestIdToRequestIndex[requestId];\n        req.addUint(\"orderId\", requestNumber);\n        req.addBytes(\"defenderFighters\", defenderFighters);\n        req.addBytes(\"attackerFighters\", attackerFighters);\n        req.addBytes(\"attackerBombers\", attackerBombers);\n        req.addBytes(\"randomNumbers\", abi.encode(randomWords));\n        req.addUint(\"attackerId\", attackerId);\n        req.addUint(\"defenderId\", defenderId);\n        req.addUint(\"defenderId\", defenderId);\n        req.addUint(\"attackId\", attackId);\n        console.log(\"arrived to sendOperatorRequest()\");\n        sendOperatorRequest(req, fee);\n        console.log(\"arrived to fulfillRandomWords()\");\n    }\n\n    function completeAirBattle(\n        bytes memory attackerFighterCasualtiesBytes,\n        bytes memory attackerBomberCasualtiesBytes,\n        bytes memory defenderFighterCasualtiesBytes,\n        uint256 attackerId,\n        uint256 defenderId,\n        uint256 infrastructureDamage,\n        uint256 tankDamage,\n        uint256 cruiseMissileDamage,\n        uint256 battleId\n    ) public {\n        addAirBattle.completeAirBattle(\n            attackerFighterCasualtiesBytes,\n            attackerBomberCasualtiesBytes,\n            defenderFighterCasualtiesBytes,\n            attackerId,\n            defenderId,\n            infrastructureDamage,\n            tankDamage,\n            cruiseMissileDamage,\n            battleId\n        );\n    \n        // uint256[] memory attackerFighterCasualties = abi.decode(\n        //     attackerFighterCasualtiesBytes,\n        //     (uint256[])\n        // );\n        // uint256[] memory attackerBomberCasualties = abi.decode(\n        //     attackerBomberCasualtiesBytes,\n        //     (uint256[])\n        // );\n        // uint256[] memory defenderFighterCasualties = abi.decode(\n        //     defenderFighterCasualtiesBytes,\n        //     (uint256[])\n        // );\n        // fighterLoss.decrementLosses(attackerFighterCasualties, attackerId);\n        // bomber.decrementBomberLosses(attackerBomberCasualties, attackerId);\n        // fighterLoss.decrementLosses(defenderFighterCasualties, defenderId);\n        // completeAirBattleCont(\n        //     infrastructureDamage,\n        //     tankDamage,\n        //     cruiseMissileDamage,\n        //     battleId,\n        //     attackerFighterCasualties,\n        //     attackerBomberCasualties,\n        //     defenderFighterCasualties,\n        //     defenderId\n        // );\n    }\n\n    // function completeAirBattleCont(\n    //     uint256 infrastructureDamage,\n    //     uint256 tankDamage,\n    //     uint256 cruiseMissileDamage,\n    //     uint256 battleId,\n    //     uint256[] memory attackerFighterCasualties,\n    //     uint256[] memory attackerBomberCasualties,\n    //     uint256[] memory defenderFighterCasualties,\n    //     uint256 defenderId\n    // ) public {\n    //     bool antiAir = won1.getAntiAirDefenseNewtwork(defenderId);\n    //     if (antiAir) {\n    //         infrastructureDamage = ((infrastructureDamage * 60) / 100);\n    //         tankDamage = ((tankDamage * 60) / 100);\n    //         cruiseMissileDamage = ((cruiseMissileDamage * 60) / 100);\n    //     }\n    //     inf.decreaseInfrastructureCountFromAirBattleContract(\n    //         defenderId,\n    //         infrastructureDamage\n    //     );\n    //     force.decreaseDefendingTankCountFromAirBattleContract(\n    //         defenderId,\n    //         tankDamage\n    //     );\n    //     mis.decreaseCruiseMissileCountFromAirBattleContract(\n    //         defenderId,\n    //         cruiseMissileDamage\n    //     );\n    //     uint256[3] memory damage = [\n    //         infrastructureDamage,\n    //         tankDamage,\n    //         cruiseMissileDamage\n    //     ];\n    //     AirBattle storage newAirBattle = airBattleIdToAirBattle[battleId];\n    //     newAirBattle.attackerFighterCasualties = attackerFighterCasualties;\n    //     newAirBattle.attackerBomberCasualties = attackerBomberCasualties;\n    //     newAirBattle.defenderFighterCasualties = defenderFighterCasualties;\n    //     newAirBattle.damage = damage;\n    //     emit AirAssaultCasualties(\n    //         battleId,\n    //         newAirBattle.attackerId,\n    //         newAirBattle.defenderId,\n    //         attackerFighterCasualties,\n    //         attackerBomberCasualties,\n    //         defenderFighterCasualties,\n    //         newAirBattle.warId\n    //     );\n    // }\n}\n\ncontract AdditionalAirBattle is Ownable {    \n    address warAddress;\n    address fighterAddress;\n    address bomberAddress;\n    address infrastructure;\n    address forces;\n    address missiles;\n    address wonders1;\n    address fighterLosses;\n    address countryMinter;\n    address airBattleAddress;\n\n    WarContract war;\n    FightersContract fighter;\n    BombersContract bomber;\n    InfrastructureContract inf;\n    ForcesContract force;\n    MissilesContract mis;\n    WondersContract1 won1;\n    FighterLosses fighterLoss;\n    CountryMinter mint;\n    AirBattleContract airBattle;\n\n    struct AirBattleCasualties{\n        uint256[] attackerFighterCasualties;\n        uint256[] attackerBomberCasualties;\n        uint256[] defenderFighterCasualties;\n        uint256[] damage;\n    }\n\n    mapping(uint256 => AirBattleCasualties) airBattleIdToAirBattleCasualties;\n\n    event AirAssaultCasualties(\n        uint256 indexed battleId,\n        uint256 indexed attackerId,\n        uint256 indexed defenderId,\n        bytes attackerFighterCasualties,\n        bytes attackerBomberCasualties,\n        bytes defenderFighterCasualties,\n        uint256 infrastructureDamage,\n        uint256 tankDamage,\n        uint256 cruiseMissileDamage\n    );\n\n    //@dev this function is only callable by the owner\n    ///@dev this function will be called right after deployment in order to set up contract pointers\n    function settings(\n        address _warAddress,\n        address _fighter,\n        address _bomber,\n        address _infrastructure,\n        address _forces,\n        address _fighterLosses,\n        address _mint,\n        address _airBattle\n    ) public onlyOwner {\n        warAddress = _warAddress;\n        war = WarContract(_warAddress);\n        fighterAddress = _fighter;\n        fighter = FightersContract(_fighter);\n        bomberAddress = _bomber;\n        bomber = BombersContract(_bomber);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        forces = _forces;\n        force = ForcesContract(_forces);\n        fighterLosses = _fighterLosses;\n        fighterLoss = FighterLosses(_fighterLosses);\n        countryMinter = _mint;\n        mint = CountryMinter(_mint);\n        airBattleAddress = _airBattle;\n        airBattle = AirBattleContract(_airBattle);\n    }\n    \n    function completeAirBattle(\n        bytes memory attackerFighterCasualtiesBytes,\n        bytes memory attackerBomberCasualtiesBytes,\n        bytes memory defenderFighterCasualtiesBytes,\n        uint256 attackerId,\n        uint256 defenderId,\n        uint256 infrastructureDamage,\n        uint256 tankDamage,\n        uint256 cruiseMissileDamage,\n        uint256 battleId\n    ) public {\n        handleDamage(\n            defenderId,\n            infrastructureDamage,\n            tankDamage,\n            cruiseMissileDamage\n        );\n        handleCasualties(\n            attackerFighterCasualtiesBytes,\n            attackerBomberCasualtiesBytes,\n            defenderFighterCasualtiesBytes,\n            defenderId,\n            attackerId\n        );\n        emit AirAssaultCasualties(\n            battleId,\n            attackerId,\n            defenderId,\n            attackerFighterCasualtiesBytes,\n            attackerBomberCasualtiesBytes,\n            defenderFighterCasualtiesBytes,\n            infrastructureDamage,\n            tankDamage,\n            cruiseMissileDamage\n        );\n    }\n\n    function handleDamage(\n        uint256 defenderId,\n        uint256 infrastructureDamage,\n        uint256 tankDamage,\n        uint256 cruiseMissileDamage\n    ) internal {\n        bool antiAir = won1.getAntiAirDefenseNewtwork(defenderId);\n        if (antiAir) {\n            infrastructureDamage = ((infrastructureDamage * 60) / 100);\n            tankDamage = ((tankDamage * 60) / 100);\n            cruiseMissileDamage = ((cruiseMissileDamage * 60) / 100);\n        }\n        inf.decreaseInfrastructureCountFromAirBattleContract(\n            defenderId,\n            infrastructureDamage\n        );\n        force.decreaseDefendingTankCountFromAirBattleContract(\n            defenderId,\n            tankDamage\n        );\n        mis.decreaseCruiseMissileCountFromAirBattleContract(\n            defenderId,\n            cruiseMissileDamage\n        );\n    }\n\n    function handleCasualties(\n        bytes memory attackerFighterCasualtiesBytes,\n        bytes memory attackerBomberCasualtiesBytes,\n        bytes memory defenderFighterCasualtiesBytes,\n        uint256 defenderId,\n        uint256 attackerId\n    ) internal {\n        uint256[] memory attackerFighterCasualties = abi.decode(\n            attackerFighterCasualtiesBytes,\n            (uint256[])\n        );\n        uint256[] memory attackerBomberCasualties = abi.decode(\n            attackerBomberCasualtiesBytes,\n            (uint256[])\n        );\n        uint256[] memory defenderFighterCasualties = abi.decode(\n            defenderFighterCasualtiesBytes,\n            (uint256[])\n        );\n        fighterLoss.decrementLosses(attackerFighterCasualties, attackerId);\n        bomber.decrementBomberLosses(attackerBomberCasualties, attackerId);\n        fighterLoss.decrementLosses(defenderFighterCasualties, defenderId);\n    }\n}\n"
    },
    "contracts/Bills.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./Treasury.sol\";\nimport \"./Wonders.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Forces.sol\";\nimport \"./Fighters.sol\";\nimport \"./Navy.sol\";\nimport \"./Improvements.sol\";\nimport \"./Resources.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./CountryParameters.sol\";\nimport \"./Missiles.sol\";\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n///@title BillsContact\n///@author OxSnosh\n///@notice this contact allows a nation owner to calculate and pay the daily upkeep bills owed for the nation\n///@notice source of bill payments come from infrastructure, improvements, wonders, military and missiles\ncontract BillsContract is Ownable {\n    address public countryMinter;\n    address public treasury;\n    address public wonders1;\n    address public wonders2;\n    address public wonders3;\n    address public wonders4;\n    address public infrastructure;\n    address public forces;\n    address public fighters;\n    address public navy;\n    address public improvements1;\n    address public improvements2;\n    address public resources;\n    address public missiles;\n    address public bonusResources;\n    address public navy2;\n    address public parameters;\n\n    TreasuryContract tsy;\n    WondersContract1 won1;\n    WondersContract2 won2;\n    WondersContract3 won3;\n    WondersContract4 won4;\n    InfrastructureContract inf;\n    ForcesContract frc;\n    FightersContract fight;\n    NavyContract nav;\n    ImprovementsContract1 imp1;\n    ImprovementsContract2 imp2;\n    ResourcesContract res;\n    MissilesContract mis;\n    CountryMinter mint;\n    BonusResourcesContract bonus;\n    NavyContract2 nav2;\n    CountryParametersContract param;\n\n    mapping(uint256 => address) public idToOwnerBills;\n\n    event BillsPaid(uint256 indexed id, uint256 indexed billsPaid);\n\n    ///@dev this function is only callable from the contact owner\n    ///@dev this function will be called right after contract deployment to set contract pointers\n    function settings(\n        address _countryMinter,\n        address _treasury,\n        address _wonders1,\n        address _wonders2,\n        address _wonders3,\n        address _infrastructure,\n        address _forces,\n        address _fighters,\n        address _navy,\n        address _resources\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        treasury = _treasury;\n        tsy = TreasuryContract(_treasury);\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        wonders2 = _wonders2;\n        won2 = WondersContract2(_wonders2);\n        wonders3 = _wonders3;\n        won3 = WondersContract3(_wonders3);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        forces = _forces;\n        frc = ForcesContract(_forces);\n        fighters = _fighters;\n        fight = FightersContract(_fighters);\n        navy = _navy;\n        nav = NavyContract(_navy);\n        resources = _resources;\n        res = ResourcesContract(_resources);\n    }\n\n    ///@dev this function is only callable from the contact owner\n    ///@dev this function will be called right after contract deployment to set contract pointers\n    function settings2(\n        address _improvements1,\n        address _improvements2,\n        address _missiles,\n        address _wonders4,\n        address _infrastructure,\n        address _bonusResources,\n        address _navy2,\n        address _parameters\n    ) public onlyOwner {\n        improvements1 = _improvements1;\n        imp1 = ImprovementsContract1(_improvements1);\n        improvements2 = _improvements2;\n        imp2 = ImprovementsContract2(_improvements2);\n        missiles = _missiles;\n        mis = MissilesContract(_missiles);\n        wonders4 = _wonders4;\n        won4 = WondersContract4(_wonders4);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        bonusResources = _bonusResources;\n        bonus = BonusResourcesContract(_bonusResources);\n        navy2 = _navy2;\n        nav2 = NavyContract2(_navy2);\n        parameters = _parameters;\n        param = CountryParametersContract(_parameters);\n    }\n\n    ///@dev this is public function but will only work for the nation owner who owes the bill payment\n    ///@param id is the nation ID of the nation looking to pay bills\n    ///@notice function allows a nation owner to pay their bills\n    ///@notice function will only work if the caller of the function is the owner of the nation ID in the id parameter\n    function payBills(uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 availableFunds = tsy.checkBalance(id);\n        uint256 billsPayable = getBillsPayable(id);\n        require(\n            availableFunds >= billsPayable,\n            \"balance not high enough to pay bills\"\n        );\n        tsy.decreaseBalanceOnBillsPaid(id, billsPayable);\n        emit BillsPaid(id, billsPayable);\n    }\n\n    ///@notice this is a public view function that will determine a nations bill payment\n    ///@param id is the nation ID of the nation whose bill payment is being calculate\n    ///@return uint256 funtion returns the total bill payment due for nation\n    function getBillsPayable(uint256 id) public view returns (uint256) {\n        uint256 daysSinceLastPayment = tsy.getDaysSinceLastBillsPaid(id);\n        uint256 infrastructureBillsPayable = calculateDailyBillsFromInfrastructure(\n                id\n            );\n        uint256 militaryBillsPayable = calculateDailyBillsFromMilitary(id);\n        uint256 improvementBillsPayable = calculateDailyBillsFromImprovements(\n            id\n        );\n        uint256 wonderBillsPayable = calculateWonderBillsPayable(id);\n        uint256 dailyBillsPayable = infrastructureBillsPayable +\n            militaryBillsPayable +\n            improvementBillsPayable +\n            wonderBillsPayable;\n        uint256 billsPayable = (dailyBillsPayable * daysSinceLastPayment);\n        return billsPayable;\n    }\n\n    ///@notice this function will calculate the daily bills due for a nation's infrastructure\n    ///@return dailyInfrastructureBills function will return the daily bill payment for a nation\n    function calculateDailyBillsFromInfrastructure(\n        uint256 id\n    ) public view returns (uint256 dailyInfrastructureBills) {\n        uint256 costPerLevel = calculateInfrastructureCostPerLevel(id);\n        uint256 infrastructureAmount = inf.getInfrastructureCount(id);\n        return (costPerLevel * infrastructureAmount);\n    }\n\n    ///@notice this function calculated the bill payment per level for a nations infrastructure level\n    ///@param id this is the nation ID for the country to calculate infrastructure bill payment per level of infrastructure\n    ///@return infrastructureBillsPerLevel function will return the infrastructure upkeep cost per level of infrasttucture\n    function calculateInfrastructureCostPerLevel(\n        uint256 id\n    ) public view returns (uint256 infrastructureBillsPerLevel) {\n        uint256 infrastructureAmount = inf.getInfrastructureCount(id);\n        uint256 infrastructureCostPerLevel;\n        if (infrastructureAmount < 100) {\n            infrastructureCostPerLevel = 20;\n        } else if (infrastructureAmount < 200) {\n            infrastructureCostPerLevel = (((5 * infrastructureAmount) / 100) +\n                20);\n        } else if (infrastructureAmount < 300) {\n            infrastructureCostPerLevel = (((6 * infrastructureAmount) / 100) +\n                20);\n        } else if (infrastructureAmount < 500) {\n            infrastructureCostPerLevel = (((7 * infrastructureAmount) / 100) +\n                20);\n        } else if (infrastructureAmount < 700) {\n            infrastructureCostPerLevel = (((8 * infrastructureAmount) / 100) +\n                20);\n        } else if (infrastructureAmount < 1000) {\n            infrastructureCostPerLevel = (((9 * infrastructureAmount) / 100) +\n                20);\n        } else if (infrastructureAmount < 2000) {\n            infrastructureCostPerLevel = (((11 * infrastructureAmount) / 100) +\n                20);\n        } else if (infrastructureAmount < 3000) {\n            infrastructureCostPerLevel = (((13 * infrastructureAmount) / 100) +\n                20);\n        } else if (infrastructureAmount < 4000) {\n            infrastructureCostPerLevel = (((15 * infrastructureAmount) / 100) +\n                20);\n        } else if (infrastructureAmount < 5000) {\n            infrastructureCostPerLevel = (((17 * infrastructureAmount) / 100) +\n                20);\n        } else if (infrastructureAmount < 8000) {\n            infrastructureCostPerLevel = (((1725 * infrastructureAmount) /\n                10000) + 20);\n        } else if (infrastructureAmount < 15000) {\n            infrastructureCostPerLevel = (((175 * infrastructureAmount) /\n                1000) + 20);\n        } else {\n            infrastructureCostPerLevel = (((18 * infrastructureAmount) / 100) +\n                20);\n        }\n        uint256 adjustedInfrastructureCostPerLevel = calculateModifiedInfrastrucureUpkeep(\n                infrastructureCostPerLevel,\n                id\n            );\n        return adjustedInfrastructureCostPerLevel * (10 ** 18);\n    }\n\n    ///@notice this function will adjust the cost per level based on resources, improvements and wonders that make infrastructure upkeep cheaper\n    ///@param baseDailyInfrastructureCostPerLevel this parameter will be the daily cost of infrastructure before adjustments\n    ///@param id is the nation ID for the nation that the bills are being calculated\n    ///@return uint256 this is daily cost per level for infrastructure upkeep after adjusting for resources, improvements and wonders\n    function calculateModifiedInfrastrucureUpkeep(\n        uint256 baseDailyInfrastructureCostPerLevel,\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 infrastructureUpkeepModifier = 100;\n        bool iron = res.viewIron(id);\n        if (iron) {\n            infrastructureUpkeepModifier -= 10;\n        }\n        bool lumber = res.viewLumber(id);\n        if (lumber) {\n            infrastructureUpkeepModifier -= 8;\n        }\n        bool uranium = res.viewUranium(id);\n        if (uranium) {\n            infrastructureUpkeepModifier -= 3;\n        }\n        bool asphalt = bonus.viewAsphalt(id);\n        if (asphalt) {\n            infrastructureUpkeepModifier -= 5;\n        }\n        uint256 laborCamps = imp2.getLaborCampCount(id);\n        if (laborCamps > 0) {\n            infrastructureUpkeepModifier -= (laborCamps * 10);\n        }\n        bool interstate = won2.getInterstateSystem(id);\n        if (interstate) {\n            infrastructureUpkeepModifier -= 8;\n        }\n        bool nationalEnvironmentOffice = won3.getNationalEnvironmentOffice(id);\n        if (nationalEnvironmentOffice) {\n            infrastructureUpkeepModifier -= 3;\n        }\n        bool nuclearPowerPlant = won3.getNuclearPowerPlant(id);\n        if (nuclearPowerPlant) {\n            infrastructureUpkeepModifier -= 5;\n        }\n        uint256 dailyInfrastructureCostPerLevel = ((baseDailyInfrastructureCostPerLevel *\n                infrastructureUpkeepModifier) / 100);\n        return dailyInfrastructureCostPerLevel;\n    }\n\n    ///@notice this function will calculate the daily bills due from military\n    ///@notice military bills will come from soldiers, tanks, aircraft, navy, nukes and cruise missiles\n    ///@param id is the nation ID for the bills being calculated\n    ///@return militaryBills this is the daily cost for military upkeep for the nation\n    function calculateDailyBillsFromMilitary(\n        uint256 id\n    ) public view returns (uint256 militaryBills) {\n        uint256 soldierUpkeep = getSoldierUpkeep(id);\n        uint256 tankUpkeep = getTankUpkeep(id);\n        uint256 aircraftUpkeep = getAircraftUpkeep(id);\n        uint256 navyUpkeep = getNavyUpkeep(id);\n        uint256 nukeUpkeep = getNukeUpkeep(id);\n        uint256 cruiseMissileUpkeep = getCruiseMissileUpkeep(id);\n        uint256 dailyMilitaryUpkeep = soldierUpkeep +\n            tankUpkeep +\n            aircraftUpkeep +\n            navyUpkeep +\n            nukeUpkeep +\n            cruiseMissileUpkeep;\n        bool accomodativeGov = checkAccomodativeGovernmentForMilitaryUpkeep(id);\n        if (accomodativeGov) {\n            dailyMilitaryUpkeep = ((dailyMilitaryUpkeep * 95) / 100);\n        }\n        return dailyMilitaryUpkeep;\n    }\n\n    ///@notice this function calculates daily bills for soldiers\n    ///@param id this is the nation ID for the soldier upkeep calculation\n    ///@return uint256 is the daily upkeep cost of soldiers for the nation\n    function getSoldierUpkeep(uint256 id) public view returns (uint256) {\n        uint256 soldierCount = frc.getSoldierCount(id);\n        uint256 soldierUpkeep = (soldierCount * 2);\n        uint256 soldierUpkeepModifier = 100;\n        bool lead = res.viewLead(id);\n        if (lead) {\n            soldierUpkeepModifier -= 15;\n        }\n        bool pigs = res.viewPigs(id);\n        if (pigs) {\n            soldierUpkeepModifier -= 10;\n        }\n        uint256 barracks = imp1.getBarracksCount(id);\n        if (barracks > 0) {\n            soldierUpkeepModifier -= (8 * barracks);\n        }\n        uint256 guerillaCamps = imp2.getGuerillaCampCount(id);\n        if (guerillaCamps > 0) {\n            soldierUpkeepModifier -= (5 * guerillaCamps);\n        }\n        uint256 adjustedSoldierUpkeep = ((soldierUpkeep *\n            soldierUpkeepModifier) / 100);\n        return adjustedSoldierUpkeep * (10 ** 18);\n    }\n\n    ///@notice this functions calculates daily bills for tanks\n    ///@param id is the nation ID of the daily tank upkeep calculation\n    ///@return uint256 is the daily cost of tank upkeep for the nation\n    function getTankUpkeep(uint256 id) public view returns (uint256) {\n        uint256 tankCount = frc.getTankCount(id);\n        uint256 tankUpkeep = (tankCount * 40);\n        uint256 tankUpkeepModifier = 100;\n        bool iron = res.viewIron(id);\n        if (iron) {\n            tankUpkeepModifier -= 10;\n        }\n        bool oil = res.viewOil(id);\n        if (oil) {\n            tankUpkeepModifier -= 10;\n        }\n        bool lead = res.viewLead(id);\n        if (lead) {\n            tankUpkeepModifier -= 8;\n        }\n        bool logisticalSupport = won4.getSuperiorLogisticalSupport(id);\n        if (logisticalSupport) {\n            tankUpkeepModifier -= 20;\n        }\n        uint256 adjustedTankUpkeep = ((tankUpkeep * tankUpkeepModifier) / 100);\n        return adjustedTankUpkeep * (10 ** 18);\n    }\n\n    ///@notice this finction calculates daily bills for a ntaions nukes\n    ///@param id is the nation for the calculation of daily nuke upkeep costs\n    function getNukeUpkeep(uint256 id) public view returns (uint256) {\n        uint256 nukeCount = mis.getNukeCount(id);\n        uint256 nukeUpkeep = (nukeCount * 5000);\n        uint256 nukeUpkeepModifier = 100;\n        bool lead = res.viewLead(id);\n        if (lead) {\n            nukeUpkeepModifier -= 20;\n        }\n        uint256 adjustedNukeUpkeep = ((nukeUpkeep * nukeUpkeepModifier) / 100);\n        bool uranium = res.viewUranium(id);\n        if (!uranium) {\n            adjustedNukeUpkeep = (adjustedNukeUpkeep * 2);\n        }\n        return adjustedNukeUpkeep * (10 ** 18);\n    }\n\n    ///@notice this function claculates daily bills for a nations cruise missiles\n    ///@param id this is the nation ID of the calulation for daily cruise missile upkeep costs\n    ///@return uint256 this is the daily cruise missile upkeep cost for the nation\n    function getCruiseMissileUpkeep(uint256 id) public view returns (uint256) {\n        uint256 cruiseMissileCount = mis.getCruiseMissileCount(id);\n        uint256 missileUpkeep = (cruiseMissileCount * 500);\n        uint256 missileUpkeepModifier = 100;\n        bool lead = res.viewLead(id);\n        if (lead) {\n            missileUpkeepModifier -= 20;\n        }\n        uint256 adjustedMissileUpkeep = ((missileUpkeep *\n            missileUpkeepModifier) / 100);\n        return adjustedMissileUpkeep * (10 ** 18);\n    }\n\n    ///@notice this function calculates daily bills for a nations aircraft\n    ///@param id is the nation ID for the calculation of daily aircraft upkeep\n    ///@return uint256 this is the daily upkeep cost for a nations aircraft\n    function getAircraftUpkeep(uint256 id) public view returns (uint256) {\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 aircraftUpkeep = (aircraftCount * 200);\n        uint256 aircraftUpkeepModifier = 100;\n        bool lead = res.viewLead(id);\n        if (lead) {\n            aircraftUpkeepModifier -= 25;\n        }\n        uint256 airports = imp1.getAirportCount(id);\n        if (airports > 0) {\n            aircraftUpkeepModifier -= (2 * airports);\n        }\n        bool logisticalSupport = won4.getSuperiorLogisticalSupport(id);\n        if (logisticalSupport) {\n            aircraftUpkeepModifier -= 10;\n        }\n        uint256 adjustedAircraftUpkeep = ((aircraftUpkeep *\n            aircraftUpkeepModifier) / 100);\n        return adjustedAircraftUpkeep * (10 ** 18);\n    }\n\n    ///@notice this function calculates daily bills for a nations navy\n    ///@param id this is the nation ID for the calulation of navy upkeep costs\n    ///@return navyUpkeep this is the daily cost of upkeep for a nations navy\n    function getNavyUpkeep(\n        uint256 id\n    ) public view returns (uint256 navyUpkeep) {\n        uint256 corvetteCount = nav.getCorvetteCount(id);\n        uint256 corvetteUpkeep = (corvetteCount * 5000);\n        uint256 landingShipCount = nav.getLandingShipCount(id);\n        uint256 landingShipUpkeep = (landingShipCount * 10000);\n        uint256 battleshipCount = nav.getBattleshipCount(id);\n        uint256 battleshipUpkeep = (battleshipCount * 25000);\n        uint256 cruiserCount = nav.getCruiserCount(id);\n        uint256 cruiserUpkeep = (cruiserCount * 10000);\n        uint256 additionalNavyUpkeep = getNavyUpkeepAppended(id);\n        uint256 baseNavyUpkeep = additionalNavyUpkeep +\n            corvetteUpkeep +\n            landingShipUpkeep +\n            battleshipUpkeep +\n            cruiserUpkeep;\n        uint256 dailyNavyUpkeep = getAdjustedNavyUpkeep(id, baseNavyUpkeep);\n        return dailyNavyUpkeep * (10 ** 18);\n    }\n\n    ///@notice this function calculates additional nacy upkeep for a nation\n    ///@param id this is the nation ID of the nation where the additional navy upkeep is being calculated\n    ///@return uint256 this is additional navy upkeep costs that will be added to the daily navy upkeep costs\n    function getNavyUpkeepAppended(uint256 id) internal view returns (uint256) {\n        uint256 frigateCount = nav2.getFrigateCount(id);\n        uint256 frigateUpkeep = (frigateCount * 15000);\n        uint256 destroyerCount = nav2.getDestroyerCount(id);\n        uint256 destroyerUpkeep = (destroyerCount * 20000);\n        uint256 submarineCount = nav2.getSubmarineCount(id);\n        uint256 submarineUpkeep = (submarineCount * 25000);\n        uint256 aircraftCarrierCount = nav2.getAircraftCarrierCount(id);\n        uint256 aircraftCarrierUpkeep = (aircraftCarrierCount * 30000);\n        bool uranium = res.viewUranium(id);\n        if (uranium) {\n            submarineUpkeep = ((submarineUpkeep * 95) / 100);\n            aircraftCarrierUpkeep = ((aircraftCarrierUpkeep * 95) / 100);\n        }\n        uint256 additionalNavyUpkeep = frigateUpkeep +\n            destroyerUpkeep +\n            submarineUpkeep +\n            aircraftCarrierUpkeep;\n        return additionalNavyUpkeep;\n    }\n\n    ///@notice this function will adjust a nations navy bills based on resources, improvements and wonders that reduce navy upkeep\n    ///@param id this is the nation ID for the countey whose navy upkeep is being calculated\n    ///@param baseNavyUpkeep this is the base daily cost of navy bills before adjustments\n    ///@return uint256 this is a nations daily navy upkeep adjusted for resources, improvements and woneers\n    function getAdjustedNavyUpkeep(\n        uint256 id,\n        uint256 baseNavyUpkeep\n    ) public view returns (uint256) {\n        uint256 navyUpkeepModifier = 100;\n        bool lead = res.viewLead(id);\n        if (lead) {\n            navyUpkeepModifier -= 20;\n        }\n        bool oil = res.viewOil(id);\n        if (oil) {\n            navyUpkeepModifier -= 10;\n        }\n        bool logisticalSupport = won4.getSuperiorLogisticalSupport(id);\n        if (logisticalSupport) {\n            navyUpkeepModifier -= 10;\n        }\n        uint256 adjustedNavyUpkeep = ((baseNavyUpkeep * navyUpkeepModifier) /\n            100);\n        return adjustedNavyUpkeep;\n    }\n\n    ///@notice this function will calculate the upkeep cost per improvement for a given nation\n    ///@param id this is the nation ID for the country for the daily improvement upkeep calculation\n    ///@return improvementBillsPerLevel is the daily cost of imprvements per level for the nation\n    function calculateImprovementCostPerLevel(\n        uint256 id\n    ) public view returns (uint256 improvementBillsPerLevel) {\n        uint256 improvementCount = imp1.getImprovementCount(id);\n        uint256 upkeepPerLevel;\n        if (improvementCount < 5) {\n            upkeepPerLevel = 500;\n        } else if (improvementCount < 8) {\n            upkeepPerLevel = 600;\n        } else if (improvementCount < 15) {\n            upkeepPerLevel = 750;\n        } else if (improvementCount < 20) {\n            upkeepPerLevel = 950;\n        } else if (improvementCount < 30) {\n            upkeepPerLevel = 1200;\n        } else if (improvementCount < 40) {\n            upkeepPerLevel = 1500;\n        } else if (improvementCount < 50) {\n            upkeepPerLevel = 2000;\n        } else {\n            upkeepPerLevel = 3000;\n        }\n        return upkeepPerLevel * (10 ** 18);\n    }\n\n    ///@notice this function calculates bills from a nations improvements\n    ///@param id this is the nation ID for the country for the daily improvement upkeep calculation\n    ///@return improvementBills is the daily cost of imprvements for the nation\n    function calculateDailyBillsFromImprovements(\n        uint256 id\n    ) public view returns (uint256 improvementBills) {\n        uint256 improvementCount = imp1.getImprovementCount(id);\n        uint256 upkeepPerLevel = calculateImprovementCostPerLevel(id);\n        uint256 dailyImprovementBillsDue = (improvementCount * upkeepPerLevel);\n        uint256 modifiers = 100;\n        bool nuclearPowerPlant = won3.getNuclearPowerPlant(id);\n        if (nuclearPowerPlant) {\n            modifiers -= 5;\n        }\n        bool accomodativeGovernment = checkAccomodativeGovernmentForImprovementsAndWonders(\n                id\n            );\n        if (accomodativeGovernment) {\n            modifiers -= 5;\n        }\n        dailyImprovementBillsDue = ((dailyImprovementBillsDue * modifiers) /\n            100);\n        return dailyImprovementBillsDue;\n    }\n\n    ///@notice this function calculated bills from a nations wonders\n    ///@param id this is the nation ID for the calculaton of daily wonder bills\n    ///@return uint256 is the daily upkeep costs for wonders of the nation\n    function calculateWonderBillsPayable(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 wonderCount = won1.getWonderCount(id);\n        uint256 wonderBillsPayable = (wonderCount * 5000);\n        uint256 modifiers = 100;\n        bool nuclearPowerPlant = won3.getNuclearPowerPlant(id);\n        if (nuclearPowerPlant) {\n            modifiers -= 5;\n        }\n        bool accomodativeGovernment = checkAccomodativeGovernmentForImprovementsAndWonders(\n                id\n            );\n        if (accomodativeGovernment) {\n            modifiers -= 5;\n        }\n        wonderBillsPayable = ((wonderBillsPayable * modifiers) / 100);\n        return wonderBillsPayable * (10 ** 18);\n    }\n\n    ///@dev this is a public view function that will return a boolean value if a nations government type accomodates a reduced upkeep for wonders and improvements\n    ///@notice this function will check if the given nation has a governemnt type that accomodate a lower the upkeep for improvements and wonders by 5%\n    ///@param countryId is the nation ID of the country being queried\n    ///@return bool will be true if the nation's government type accomodates a lower infrastructure cost\n    function checkAccomodativeGovernmentForImprovementsAndWonders(\n        uint256 countryId\n    ) public view returns (bool) {\n        uint256 governmentType = param.getGovernmentType(countryId);\n        if (\n            governmentType == 1 ||\n            governmentType == 5 ||\n            governmentType == 8 ||\n            governmentType == 10\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    ///@dev this is a public view function that will return a boolean value if a nations government type accomodates a reduced upkeep for wonders and improvements\n    ///@notice this function will check if the given nation has a governemnt type that accomodate a lower the upkeep for improvements and wonders by 5%\n    ///@param countryId is the nation ID of the country being queried\n    ///@return bool will be true if the nation's government type accomodates a lower infrastructure cost\n    function checkAccomodativeGovernmentForMilitaryUpkeep(\n        uint256 countryId\n    ) public view returns (bool) {\n        uint256 governmentType = param.getGovernmentType(countryId);\n        if (governmentType == 2 || governmentType == 4 || governmentType == 9) {\n            return true;\n        }\n        return false;\n    }\n}\n"
    },
    "contracts/Bombers.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./Treasury.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Fighters.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n///@title BombersContract\n///@author OxSnosh\n///@notice this contract will store this information about each nation's bomber fleet\ncontract BombersContract is Ownable {\n    address public countryMinter;\n    address public bombersMarket1;\n    address public bombersMarket2;\n    address public airBattle;\n    address public fighters;\n    address public treasury;\n    address public infrastructure;\n    address public war;\n\n    CountryMinter mint;\n\n    struct Bombers {\n        uint256 ah1CobraCount;\n        uint256 ah64ApacheCount;\n        uint256 bristolBlenheimCount;\n        uint256 b52MitchellCount;\n        uint256 b17gFlyingFortressCount;\n        uint256 b52StratofortressCount;\n        uint256 b2SpiritCount;\n        uint256 b1bLancerCount;\n        uint256 tupolevTu160Count;\n    }\n\n    event Ah1CobraPurchased(uint256 indexed id, uint256 indexed amount);\n    event Ah64ApachePurchased(uint256 indexed id, uint256 indexed amount);\n    event BristolBlenheimPurchased(uint256 indexed id, uint256 indexed amount);\n    event B52MitchellPurchased(uint256 indexed id, uint256 indexed amount);\n    event B17gFlyingFortressPurchased(\n        uint256 indexed id,\n        uint256 indexed amount\n    );\n    event B52StratofortressPurchased(\n        uint256 indexed id,\n        uint256 indexed amount\n    );\n    event B2SpiritPurchased(uint256 indexed id, uint256 indexed amount);\n    event B1bLancerPurchased(uint256 indexed id, uint256 indexed amount);\n    event TupolevTu160Purchased(uint256 indexed id, uint256 indexed amount);\n\n    event Ah1CobraDecommissioned(uint256 indexed id, uint256 indexed amount);\n    event Ah64ApacheDecommissioned(uint256 indexed id, uint256 indexed amount);\n    event BristolBlenheimDecommissioned(uint256 indexed id, uint256 indexed amount);\n    event B52MitchellDecommissioned(uint256 indexed id, uint256 indexed amount);\n    event B17gFlyingFortressDecommissioned(uint256 indexed id, uint256 indexed amount);\n    event B52StratofortressDecommissioned(uint256 indexed id, uint256 indexed amount);\n    event B2SpiritDecommissioned(uint256 indexed id, uint256 indexed amount);\n    event B1bLancerDecommissioned(uint256 indexed id, uint256 indexed amount);\n    event TupolevTu160Decommissioned(uint256 indexed id, uint256 indexed amount);\n\n    mapping(uint256 => Bombers) public idToBombers;\n\n    ///@dev this function is only callable from the contact owner\n    ///@dev this function will be called right after contract deployment to set contract pointers\n    function settings(\n        address _countryMinter,\n        address _bombersMarket1,\n        address _bombersMarket2,\n        address _airBattle,\n        address _treasuryAddress,\n        address _fightersAddress,\n        address _infrastructure,\n        address _war\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        bombersMarket1 = _bombersMarket1;\n        bombersMarket2 = _bombersMarket2;\n        airBattle = _airBattle;\n        treasury = _treasuryAddress;\n        fighters = _fightersAddress;\n        infrastructure = _infrastructure;\n        war = _war;\n    }\n\n    modifier onlyCountryMinter() {\n        require(msg.sender == countryMinter, \"only countryMinter can call\");\n        _;\n    }\n\n    modifier onlyWar() {\n        require(\n            msg.sender == war,\n            \"this function can only be called by battle\"\n        );\n        _;\n    }\n\n    modifier onlyAirBattle() {\n        require(\n            msg.sender == airBattle,\n            \"function only callable from Air Battle Contract\"\n        );\n        _;\n    }\n\n    modifier onlyMarket() {\n        require(\n            msg.sender == bombersMarket1 || msg.sender == bombersMarket2,\n            \"this function can only be called by market\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable from the country minter contract\n    ///@notice this function will initiate a nation to be bale to buy bombers when a nation is minted\n    function generateBombers(uint256 id) public onlyCountryMinter {\n        Bombers memory newBombers = Bombers(0, 0, 0, 0, 0, 0, 0, 0, 0);\n        idToBombers[id] = newBombers;\n    }\n\n    ///@notice this function will return the amount of defending AH1 Cobra's of a nation\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending AH1 Cobra aircraft for the nation\n    function getAh1CobraCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToBombers[id].ah1CobraCount;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Bomber marketplace contract\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseAh1CobraCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToBombers[id].ah1CobraCount += amount;\n        emit Ah1CobraPurchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the war contract\n    ///@notice this function will decrease the amount of aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseAh1CobraCount(uint256 amount, uint256 id) internal {\n        uint256 currentAmount = idToBombers[id].ah1CobraCount;\n        if (currentAmount >= amount) {\n            idToBombers[id].ah1CobraCount -= amount;\n        } else {\n            idToBombers[id].ah1CobraCount = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission Ah1Cobras\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapAh1Cobra(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToBombers[id].ah1CobraCount;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToBombers[id].ah1CobraCount -= amount;\n        emit Ah1CobraDecommissioned(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending A64Apaches a nation owns\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending A64Apache aircraft for the nation\n    function getAh64ApacheCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToBombers[id].ah64ApacheCount;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Bomber marketplace contract\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseAh64ApacheCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToBombers[id].ah64ApacheCount += amount;\n        emit Ah64ApachePurchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the war contract\n    ///@notice this function will decrease the amount of aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseAh64ApacheCount(uint256 amount, uint256 id) internal {\n        uint256 currentAmount = idToBombers[id].ah64ApacheCount;\n        if (currentAmount >= amount) {\n            idToBombers[id].ah64ApacheCount -= amount;\n        } else {\n            idToBombers[id].ah64ApacheCount = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission Ah64 Apache's\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapAh64Apache(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToBombers[id].ah64ApacheCount;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToBombers[id].ah64ApacheCount -= amount;\n        emit Ah64ApacheDecommissioned(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending Bristol Blenheim's a nation owns\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending Bristol Blenheim aircraft for the nation\n    function getBristolBlenheimCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToBombers[id].bristolBlenheimCount;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Bomber marketplace contract\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseBristolBlenheimCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToBombers[id].bristolBlenheimCount += amount;\n        emit BristolBlenheimPurchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the war contract\n    ///@notice this function will decrease the amount of aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseBristolBlenheimCount(uint256 amount, uint256 id) internal {\n        uint256 currentAmount = idToBombers[id].bristolBlenheimCount;\n        if (currentAmount >= amount) {\n            idToBombers[id].bristolBlenheimCount -= amount;\n        } else {\n            idToBombers[id].bristolBlenheimCount = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission Bristol Blenheim's\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapBristolBlenheim(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToBombers[id].bristolBlenheimCount;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToBombers[id].bristolBlenheimCount -= amount;\n        emit BristolBlenheimDecommissioned(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending b52 Mitchell's a nation owns\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending b52 Mitchell aircraft for the nation\n    function getB52MitchellCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToBombers[id].b52MitchellCount;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Bomber marketplace contract\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseB52MitchellCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToBombers[id].b52MitchellCount += amount;\n        emit B52MitchellPurchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the war contract\n    ///@notice this function will decrease the amount of aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseB52MitchellCount(uint256 amount, uint256 id) internal {\n        uint256 currentAmount = idToBombers[id].b52MitchellCount;\n        if (currentAmount >= amount) {\n            idToBombers[id].b52MitchellCount -= amount;\n        } else {\n            idToBombers[id].b52MitchellCount = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission B52 Mitchell\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapB52Mitchell(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToBombers[id].b52MitchellCount;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToBombers[id].b52MitchellCount -= amount;\n        emit B52MitchellDecommissioned(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending B17's a nation owns\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending B17 aircraft for the nation\n    function getB17gFlyingFortressCount(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 count = idToBombers[id].b17gFlyingFortressCount;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Bomber marketplace contract\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseB17gFlyingFortressCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToBombers[id].b17gFlyingFortressCount += amount;\n        emit B17gFlyingFortressPurchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the war contract\n    ///@notice this function will decrease the amount of aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseB17gFlyingFortressCount(\n        uint256 amount,\n        uint256 id\n    ) internal {\n        uint256 currentAmount = idToBombers[id].b17gFlyingFortressCount;\n        if (currentAmount >= amount) {\n            idToBombers[id].b17gFlyingFortressCount -= amount;\n        } else {\n            idToBombers[id].b17gFlyingFortressCount = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission B17 Flying Fortresses\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapB17gFlyingFortress(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToBombers[id].b17gFlyingFortressCount;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToBombers[id].b17gFlyingFortressCount -= amount;\n        emit B17gFlyingFortressDecommissioned(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending b52Stratofortresses a nation owns\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending b52Stratofortress aircraft for the nation\n    function getB52StratofortressCount(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 count = idToBombers[id].b52StratofortressCount;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Bomber marketplace contract\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseB52StratofortressCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToBombers[id].b52StratofortressCount += amount;\n        emit B52StratofortressPurchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the war contract\n    ///@notice this function will decrease the amount of aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseB52StratofortressCount(\n        uint256 amount,\n        uint256 id\n    ) internal {\n        uint256 currentAmount = idToBombers[id].b52StratofortressCount;\n        if (currentAmount >= amount) {\n            idToBombers[id].b52StratofortressCount -= amount;\n        } else {\n            idToBombers[id].b52StratofortressCount = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission B52 Stratofortresses\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapB52Stratofortress(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToBombers[id].b52StratofortressCount;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToBombers[id].b52StratofortressCount -= amount;\n        emit B52StratofortressDecommissioned(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending B2Spirits's a nation owns\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending B2Spirit aircraft for the nation\n    function getB2SpiritCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToBombers[id].b2SpiritCount;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Bomber marketplace contract\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseB2SpiritCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToBombers[id].b2SpiritCount += amount;\n        emit B2SpiritPurchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the war contract\n    ///@notice this function will decrease the amount of aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseB2SpiritCount(uint256 amount, uint256 id) internal {\n        uint256 currentAmount = idToBombers[id].b2SpiritCount;\n        if (currentAmount >= amount) {\n            idToBombers[id].b2SpiritCount -= amount;\n        } else {\n            idToBombers[id].b2SpiritCount = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission B2 Spirit's\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapB2Spirit(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToBombers[id].b2SpiritCount;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToBombers[id].b2SpiritCount -= amount;\n        emit B2SpiritDecommissioned(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending B1bLancer's a nation owns\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending B1bLancer aircraft for the nation\n    function getB1bLancerCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToBombers[id].b1bLancerCount;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Bomber marketplace contract\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseB1bLancerCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToBombers[id].b1bLancerCount += amount;\n        emit B1bLancerPurchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the war contract\n    ///@notice this function will decrease the amount of aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseB1bLancerCount(uint256 amount, uint256 id) internal {\n        uint256 currentAmount = idToBombers[id].b1bLancerCount;\n        if (currentAmount >= amount) {\n            idToBombers[id].b1bLancerCount -= amount;\n        } else {\n            idToBombers[id].b1bLancerCount = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission B1B Lancers\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapB1bLancer(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToBombers[id].b1bLancerCount;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToBombers[id].b1bLancerCount -= amount;\n        emit B1bLancerDecommissioned(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending Tu160's a nation owns\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending Tu160 aircraft for the nation\n    function getTupolevTu160Count(uint256 id) public view returns (uint256) {\n        uint256 count = idToBombers[id].tupolevTu160Count;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Bomber marketplace contract\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseTupolevTu160Count(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToBombers[id].tupolevTu160Count += amount;\n        emit TupolevTu160Purchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the war contract\n    ///@notice this function will decrease the amount of aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseTupolevTu160Count(uint256 amount, uint256 id) internal {\n        uint256 currentAmount = idToBombers[id].tupolevTu160Count;\n        if (currentAmount >= amount) {\n            idToBombers[id].tupolevTu160Count -= amount;\n        } else {\n            idToBombers[id].tupolevTu160Count = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission Tupolev TU160's\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapTupolevTu160(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToBombers[id].tupolevTu160Count;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToBombers[id].tupolevTu160Count -= amount;\n        emit TupolevTu160Decommissioned(id, amount);\n    }\n\n    function getBomberCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToBombers[id].ah1CobraCount +\n            idToBombers[id].ah64ApacheCount +\n            idToBombers[id].bristolBlenheimCount +\n            idToBombers[id].b52MitchellCount +\n            idToBombers[id].b17gFlyingFortressCount +\n            idToBombers[id].b52StratofortressCount +\n            idToBombers[id].b2SpiritCount +\n            idToBombers[id].b1bLancerCount +\n            idToBombers[id].tupolevTu160Count;\n        return count;\n    }\n\n    ///@dev this is a public function that is only callable from the Air Battle contract\n    ///@notice this function will decrease the amount of fighers lost in battle from the FighersContract\n    ///@param losses is an array of uints that represent the fighters that the defender lost in battle\n    ///@param id is the nation ID of the defender\n    function decrementBomberLosses(\n        uint256[] memory losses,\n        uint256 id\n    ) public onlyAirBattle {\n        for (uint256 i; i < losses.length; i++) {\n            if (losses[i] == 1) {\n                decreaseAh1CobraCount(1, id);\n            } else if (losses[i] == 2) {\n                decreaseAh64ApacheCount(1, id);\n            } else if (losses[i] == 3) {\n                decreaseBristolBlenheimCount(1, id);\n            } else if (losses[i] == 4) {\n                decreaseB52MitchellCount(1, id);\n            } else if (losses[i] == 5) {\n                decreaseB17gFlyingFortressCount(1, id);\n            } else if (losses[i] == 6) {\n                decreaseB52StratofortressCount(1, id);\n            } else if (losses[i] == 7) {\n                decreaseB2SpiritCount(1, id);\n            } else if (losses[i] == 8) {\n                decreaseB1bLancerCount(1, id);\n            } else if (losses[i] == 9) {\n                decreaseTupolevTu160Count(1, id);\n            }\n        }\n    }\n}\n\n///@title BombersMarketplace1\n///@author OxSnosh\n///@notice this is the contract that will allow nation owners to purchase AH! Cobras, AH64 Apaches, Bristol Blenheims, B52 Mitchells and B17 Flying Fortresses\ncontract BombersMarketplace1 is Ownable {\n    address public countryMinter;\n    address public bombers1;\n    address public fighters;\n    address public fightersMarket1;\n    address public infrastructure;\n    address public treasury;\n    uint256 public ah1CobraCost = 10000 * (10 ** 18);\n    uint256 public ah1CobraRequiredInfrastructure = 100;\n    uint256 public ah1CobraRequiredTech = 30;\n    uint256 public ah64ApacheCost = 15000 * (10 ** 18);\n    uint256 public ah64ApacheRequiredInfrastructure = 200;\n    uint256 public ah64ApacheRequiredTech = 65;\n    uint256 public bristolBlenheimCost = 20000 * (10 ** 18);\n    uint256 public bristolBlenheimRequiredInfrastructure = 300;\n    uint256 public bristolBlenheimRequiredTech = 105;\n    uint256 public b52MitchellCost = 25000 * (10 ** 18);\n    uint256 public b52MitchellRequiredInfrastructure = 400;\n    uint256 public b52MitchellRequiredTech = 150;\n    uint256 public b17gFlyingFortressCost = 30000 * (10 ** 18);\n    uint256 public b17gFlyingFortressRequiredInfrastructure = 500;\n    uint256 public b17gFlyingFortressRequiredTech = 200;\n\n    CountryMinter mint;\n    FightersContract fight;\n    FightersMarketplace1 fightMarket1;\n    InfrastructureContract inf;\n    TreasuryContract tsy;\n    BombersContract bomb1;\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _countryMinter,\n        address _bombers1,\n        address _fighters,\n        address _fightersMarket1,\n        address _infrastructure,\n        address _treasury\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        bombers1 = _bombers1;\n        bomb1 = BombersContract(_bombers1);\n        fighters = _fighters;\n        fight = FightersContract(_fighters);\n        fightersMarket1 = _fightersMarket1;\n        fightMarket1 = FightersMarketplace1(_fightersMarket1);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        treasury = _treasury;\n        tsy = TreasuryContract(_treasury);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be used to update the price, infrastructure requirement and tech requirement in order to purchase a AH1 Cobra\n    function updateAh1CobraSpecs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        ah1CobraCost = newPrice;\n        ah1CobraRequiredInfrastructure = newInfra;\n        ah1CobraRequiredTech = newTech;\n    }\n\n    function getAh1CobraSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            ah1CobraCost,\n            ah1CobraRequiredInfrastructure,\n            ah1CobraRequiredTech\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be used to update the price, infrastructure requirement and tech requirement in order to purchase a A64 Apache\n    function updateAh64ApacheSpecs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        ah64ApacheCost = newPrice;\n        ah64ApacheRequiredInfrastructure = newInfra;\n        ah64ApacheRequiredTech = newTech;\n    }\n\n    function getAh64ApacheSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            ah64ApacheCost,\n            ah64ApacheRequiredInfrastructure,\n            ah64ApacheRequiredTech\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be used to update the price, infrastructure requirement and tech requirement in order to purchase a Bristol Blenheim\n    function updateBristolBlenheimSpecs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        bristolBlenheimCost = newPrice;\n        bristolBlenheimRequiredInfrastructure = newInfra;\n        bristolBlenheimRequiredTech = newTech;\n    }\n\n    function getBristolBlenheimSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            bristolBlenheimCost,\n            bristolBlenheimRequiredInfrastructure,\n            bristolBlenheimRequiredTech\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be used to update the price, infrastructure requirement and tech requirement in order to purchase a B52 Mitchell\n    function updateB52MitchellSpecs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        b52MitchellCost = newPrice;\n        b52MitchellRequiredInfrastructure = newInfra;\n        b52MitchellRequiredTech = newTech;\n    }\n\n    function getB52MitchellSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            b52MitchellCost,\n            b52MitchellRequiredInfrastructure,\n            b52MitchellRequiredTech\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be used to update the price, infrastructure requirement and tech requirement in order to purchase a B17 Flying Fortress\n    function updateB17gFlyingFortressSpecs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        b17gFlyingFortressCost = newPrice;\n        b17gFlyingFortressRequiredInfrastructure = newInfra;\n        b17gFlyingFortressRequiredTech = newTech;\n    }\n\n    function getB17gFlyingFortressSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            b17gFlyingFortressCost,\n            b17gFlyingFortressRequiredInfrastructure,\n            b17gFlyingFortressRequiredTech\n        );\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase an AH1 Cobra for their nation\n    ///@notice this function allowes the caller to purchase an AH1 Cobra for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyAh1Cobra(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = fightMarket1.getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = inf.getInfrastructureCount(id);\n        require(\n            callerInfra >= ah1CobraRequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = inf.getTechnologyCount(id);\n        require(callerTech >= ah1CobraRequiredTech, \"!enough tech\");\n        uint256 cost = getAh1CobraCost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = tsy.checkBalance(id);\n        require(balance >= purchasePrice);\n        bomb1.increaseAh1CobraCount(id, amount);\n        tsy.spendBalance(id, purchasePrice);\n    }\n\n    function getAh1CobraCost(uint256 id) public view returns (uint256) {\n        uint256 mod = fightMarket1.getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((ah1CobraCost * mod) / 100);\n        return cost;\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase an A64 Apache for their nation\n    ///@notice this function allowes the caller to purchase an A64 Apache for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyAh64Apache(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = fightMarket1.getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = inf.getInfrastructureCount(id);\n        require(\n            callerInfra >= ah64ApacheRequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = inf.getTechnologyCount(id);\n        require(callerTech >= ah64ApacheRequiredTech, \"!enough tech\");\n        uint256 cost = getAh64ApacheCost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = tsy.checkBalance(id);\n        require(balance >= purchasePrice);\n        bomb1.increaseAh64ApacheCount(id, amount);\n        tsy.spendBalance(id, purchasePrice);\n    }\n\n    function getAh64ApacheCost(uint256 id) public view returns (uint256) {\n        uint256 mod = fightMarket1.getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((ah64ApacheCost * mod) / 100);\n        return cost;\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a Bristol Blenheim for their nation\n    ///@notice this function allowes the caller to purchase a Bristol Blenheim for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyBristolBlenheim(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = fightMarket1.getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = inf.getInfrastructureCount(id);\n        require(\n            callerInfra >= bristolBlenheimRequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = inf.getTechnologyCount(id);\n        require(callerTech >= bristolBlenheimRequiredTech, \"!enough tech\");\n        uint256 cost = getBristolBlenheimCost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = tsy.checkBalance(id);\n        require(balance >= purchasePrice);\n        bomb1.increaseBristolBlenheimCount(id, amount);\n        tsy.spendBalance(id, purchasePrice);\n    }\n\n    function getBristolBlenheimCost(uint256 id) public view returns (uint256) {\n        uint256 mod = fightMarket1.getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((bristolBlenheimCost * mod) / 100);\n        return cost;\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a B52 Mitchell for their nation\n    ///@notice this function allowes the caller to purchase a B52 Mitchell for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyB52Mitchell(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = fightMarket1.getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = inf.getInfrastructureCount(id);\n        require(\n            callerInfra >= b52MitchellRequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = inf.getTechnologyCount(id);\n        require(callerTech >= b52MitchellRequiredTech, \"!enough tech\");\n        uint256 cost = getB52MitchellCost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = tsy.checkBalance(id);\n        require(balance >= purchasePrice);\n        bomb1.increaseB52MitchellCount(id, amount);\n        tsy.spendBalance(id, purchasePrice);\n    }\n\n    function getB52MitchellCost(uint256 id) public view returns (uint256) {\n        uint256 mod = fightMarket1.getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((b52MitchellCost * mod) / 100);\n        return cost;\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a B17 Flying Fortress for their nation\n    ///@notice this function allowes the caller to purchase a B17 Flying Fortress for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyB17gFlyingFortress(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = fightMarket1.getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = inf.getInfrastructureCount(id);\n        require(\n            callerInfra >= b17gFlyingFortressRequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = inf.getTechnologyCount(id);\n        require(callerTech >= b17gFlyingFortressRequiredTech, \"!enough tech\");\n        uint256 cost = getB17gFlyingFortressCost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = tsy.checkBalance(id);\n        require(balance >= purchasePrice);\n        bomb1.increaseB17gFlyingFortressCount(id, amount);\n        tsy.spendBalance(id, purchasePrice);\n    }\n\n    function getB17gFlyingFortressCost(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 mod = fightMarket1.getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((b17gFlyingFortressCost * mod) / 100);\n        return cost;\n    }\n}\n\n///@title BombersMarketplace2\n///@author OxSnosh\n///@notice this contract allows nation owners to purchase B52 Stratofortresses, B2 Spirits, B1B Lancers and Tupolev TO160s\ncontract BombersMarketplace2 is Ownable {\n    address public countryMinter;\n    address public bombers1;\n    address public fighters;\n    address public fightersMarket1;\n    address public infrastructure;\n    address public treasury;\n    uint256 public b52StratofortressCost = 35000 * (10 ** 18);\n    uint256 public b52StratofortressRequiredInfrastructure = 600;\n    uint256 public b52StratofortressRequiredTech = 255;\n    uint256 public b2SpiritCost = 40000 * (10 ** 18);\n    uint256 public b2SpiritRequiredInfrastructure = 700;\n    uint256 public b2SpiritRequiredTech = 315;\n    uint256 public b1bLancerCost = 45000 * (10 ** 18);\n    uint256 public b1bLancerRequiredInfrastructure = 850;\n    uint256 public b1bLancerRequiredTech = 405;\n    uint256 public tupolevTu160Cost = 50000 * (10 ** 18);\n    uint256 public tupolevTu160RequiredInfrastructure = 1000;\n    uint256 public tupolevTu160RequiredTech = 500;\n\n    CountryMinter mint;\n    FightersContract fight;\n    FightersMarketplace1 fightMarket1;\n    InfrastructureContract inf;\n    TreasuryContract tsy;\n    BombersContract bomb1;\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _countryMinter,\n        address _bombers1,\n        address _fighters,\n        address _fightersMarket1,\n        address _infrastructure,\n        address _treasury\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        bombers1 = _bombers1;\n        bomb1 = BombersContract(_bombers1);\n        fighters = _fighters;\n        fight = FightersContract(_fighters);\n        fightersMarket1 = _fightersMarket1;\n        fightMarket1 = FightersMarketplace1(_fightersMarket1);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        treasury = _treasury;\n        tsy = TreasuryContract(_treasury);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be used to update the price, infrastructure requirement and tech requirement in order to purchase a B52 Stratofortress\n    function updateB52StratofortressSpecs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        b52StratofortressCost = newPrice;\n        b52StratofortressRequiredInfrastructure = newInfra;\n        b52StratofortressRequiredTech = newTech;\n    }\n\n    function getB52StratofortressSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            b52StratofortressCost,\n            b52StratofortressRequiredInfrastructure,\n            b52StratofortressRequiredTech\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be used to update the price, infrastructure requirement and tech requirement in order to purchase a B2 Spirit\n    function updateb2SpiritSpecs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        b2SpiritCost = newPrice;\n        b2SpiritRequiredInfrastructure = newInfra;\n        b2SpiritRequiredTech = newTech;\n    }\n\n    function getb2SpiritSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            b2SpiritCost,\n            b2SpiritRequiredInfrastructure,\n            b2SpiritRequiredTech\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be used to update the price, infrastructure requirement and tech requirement in order to purchase a B1B Lancer\n    function updateB1bLancerSpecs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        b1bLancerCost = newPrice;\n        b1bLancerRequiredInfrastructure = newInfra;\n        b1bLancerRequiredTech = newTech;\n    }\n\n    function getB1bLancerSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            b1bLancerCost,\n            b1bLancerRequiredInfrastructure,\n            b1bLancerRequiredTech\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be used to update the price, infrastructure requirement and tech requirement in order to purchase a Tupolev TU160\n    function updateTupolevTu160Specs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        tupolevTu160Cost = newPrice;\n        tupolevTu160RequiredInfrastructure = newInfra;\n        tupolevTu160RequiredTech = newTech;\n    }\n\n    function getTupolevTu160Specs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            tupolevTu160Cost,\n            tupolevTu160RequiredInfrastructure,\n            tupolevTu160RequiredTech\n        );\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a B52 Stratofortress for their nation\n    ///@notice this function allowes the caller to purchase a B52 Stratofortress for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyB52Stratofortress(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = fightMarket1.getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = inf.getInfrastructureCount(id);\n        require(\n            callerInfra >= b52StratofortressRequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = inf.getTechnologyCount(id);\n        require(callerTech >= b52StratofortressRequiredTech, \"!enough tech\");\n        uint256 cost = getB52StratofortressCost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = tsy.checkBalance(id);\n        require(balance >= purchasePrice);\n        bomb1.increaseB52StratofortressCount(id, amount);\n        tsy.spendBalance(id, purchasePrice);\n    }\n\n    function getB52StratofortressCost(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 mod = fightMarket1.getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((b52StratofortressCost * mod) / 100);\n        return cost;\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a B2 Spirit for their nation\n    ///@notice this function allowes the caller to purchase a B2 Spirit for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyB2Spirit(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = fightMarket1.getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = inf.getInfrastructureCount(id);\n        require(\n            callerInfra >= b2SpiritRequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = inf.getTechnologyCount(id);\n        require(callerTech >= b2SpiritRequiredTech, \"!enough tech\");\n        uint256 cost = getB2SpiritCost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = tsy.checkBalance(id);\n        require(balance >= purchasePrice);\n        bomb1.increaseB2SpiritCount(id, amount);\n        tsy.spendBalance(id, purchasePrice);\n    }\n\n    function getB2SpiritCost(uint256 id) public view returns (uint256) {\n        uint256 mod = fightMarket1.getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((b2SpiritCost * mod) / 100);\n        return cost;\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a B1B Lancer for their nation\n    ///@notice this function allowes the caller to purchase a B1B Lancer for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyB1bLancer(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = fightMarket1.getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = inf.getInfrastructureCount(id);\n        require(\n            callerInfra >= b1bLancerRequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = inf.getTechnologyCount(id);\n        require(callerTech >= b1bLancerRequiredTech, \"!enough tech\");\n        uint256 cost = getB1bLancerCost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = tsy.checkBalance(id);\n        require(balance >= purchasePrice);\n        bomb1.increaseB1bLancerCount(id, amount);\n        tsy.spendBalance(id, purchasePrice);\n    }\n\n    function getB1bLancerCost(uint256 id) public view returns (uint256) {\n        uint256 mod = fightMarket1.getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((b1bLancerCost * mod) / 100);\n        return cost;\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a Tupolev TU160 for their nation\n    ///@notice this function allowes the caller to purchase a Tupolev TU160 for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyTupolevTu160(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = fightMarket1.getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = inf.getInfrastructureCount(id);\n        require(\n            callerInfra >= tupolevTu160RequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = inf.getTechnologyCount(id);\n        require(callerTech >= tupolevTu160RequiredTech, \"!enough tech\");\n        uint256 cost = getTupolevTu160Cost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = tsy.checkBalance(id);\n        require(balance >= purchasePrice);\n        bomb1.increaseTupolevTu160Count(id, amount);\n        tsy.spendBalance(id, purchasePrice);\n    }\n\n    function getTupolevTu160Cost(uint256 id) public view returns (uint256) {\n        uint256 mod = fightMarket1.getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((tupolevTu160Cost * mod) / 100);\n        return cost;\n    }\n}\n"
    },
    "contracts/CountryMinter.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./IWarBucks.sol\";\nimport \"./CountryParameters.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Resources.sol\";\nimport \"./Improvements.sol\";\nimport \"./Wonders.sol\";\nimport \"./Military.sol\";\nimport \"./Forces.sol\";\nimport \"./Treasury.sol\";\nimport \"./Navy.sol\";\nimport \"./Fighters.sol\";\nimport \"./Bombers.sol\";\nimport \"./Aid.sol\";\nimport \"./Senate.sol\";\nimport \"hardhat/console.sol\";\n\n///@title CountryMinter\n///@author OxSnosh\n///@notice this is the contract that will allow the user to mint a nation!\ncontract CountryMinter is ERC721, Ownable {\n    uint256 public countryId;\n\n    address public countryParameters;\n    address public infrastructure;\n    address public resources;\n    address public improvements1;\n    address public improvements2;\n    address public improvements3;\n    address public improvements4;\n    address public wonders1;\n    address public wonders2;\n    address public wonders3;\n    address public wonders4;\n    address public wonders;\n    address public military;\n    address public forces;\n    address public treasury;\n    address public navy;\n    address public navy2;\n    address public navalActions;\n    address public fighters;\n    address public bombers;\n    address public missiles;\n    address public senate;\n    address public warbucks;\n    address public bonusResources;\n\n    mapping(uint256 => address) public idToOwner;\n    mapping(address => uint256) public ownerCountryCount;\n    mapping(address => uint256[]) public ownerCountryIds;\n\n    event NationCreated(\n        string nationName,\n        string ruler,\n        uint256 indexed countryId,\n        address owner\n    );\n\n    constructor (\n    ) ERC721 (\"St8craft\", \"ST8\") {\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings (\n        address _countryParameters,\n        address _treasury,\n        address _infrastructure,\n        address _resources,\n        address _missiles,\n        address _senate,\n        address _warbucks,\n        address _bonusResources\n    ) public onlyOwner {\n        countryParameters = _countryParameters;\n        treasury = _treasury;\n        infrastructure = _infrastructure;\n        resources = _resources;\n        missiles = _missiles;\n        senate = _senate;\n        warbucks = _warbucks;\n        bonusResources = _bonusResources;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings2 (\n        address _improvements1,\n        address _improvements2,\n        address _improvements3,\n        address _improvements4,\n        address _wonders1,\n        address _wonders2,\n        address _wonders3,\n        address _wonders4\n    ) public onlyOwner {\n        improvements1 = _improvements1;\n        improvements2 = _improvements2;\n        improvements3 = _improvements3;\n        improvements4 = _improvements4;\n        wonders1 = _wonders1;\n        wonders2 = _wonders2;\n        wonders3 = _wonders3;\n        wonders4 = _wonders4;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings3 (\n        address _military,\n        address _forces,\n        address _navy,\n        address _navy2,\n        address _navalActions,\n        address _fighters,\n        address _bombers\n    ) public onlyOwner {\n        military = _military;\n        forces = _forces;\n        navy = _navy;\n        navy2 = _navy2;\n        navalActions = _navalActions;\n        fighters = _fighters;\n        bombers = _bombers;\n    }\n\n    ///@dev this is a public function that allows the caller to mint a nation\n    ///@notice this function allows the caller to mint a nation\n    ///@notice each wallet address can only contain one country\n    ///@param ruler this is a string that is the nation ruler name\n    ///@param nationName this is a string that is the name of the nation\n    ///@param capitalCity this is a string that is the name of the capital city of the nation\n    ///@param nationSlogan this is a string that represents that slogan of the nation\n    function generateCountry(\n        string memory ruler,\n        string memory nationName,\n        string memory capitalCity,\n        string memory nationSlogan\n    ) public {\n        uint256 seedMoney = TreasuryContract(treasury).getSeedMoney();\n        IWarBucks(warbucks).burnFromMint(msg.sender, seedMoney);\n        _safeMint(msg.sender, countryId);\n        idToOwner[countryId] = msg.sender;\n        ownerCountryCount[msg.sender]++;\n        ownerCountryIds[msg.sender].push(countryId);\n        BombersContract(bombers).generateBombers(countryId);\n        CountryParametersContract(countryParameters).generateCountryParameters(\n            countryId,\n            ruler,\n            nationName,\n            capitalCity,\n            nationSlogan \n        );\n        FightersContract(fighters).generateFighters(countryId);\n        ForcesContract(forces).generateForces(countryId);\n        MissilesContract(missiles).generateMissiles(countryId);\n        ImprovementsContract1(improvements1).generateImprovements(countryId);\n        ImprovementsContract2(improvements2).generateImprovements(countryId);\n        ImprovementsContract3(improvements3).generateImprovements(countryId);\n        ImprovementsContract4(improvements4).generateImprovements(countryId);\n        InfrastructureContract(infrastructure).generateInfrastructure(countryId);\n        MilitaryContract(military).generateMilitary(countryId);\n        NavalActionsContract(navalActions).generateNavalActions(countryId);\n        NavyContract(navy).generateNavy(countryId);\n        NavyContract2(navy2).generateNavy2(countryId);\n        ResourcesContract(resources).generateResources(countryId);\n        BonusResourcesContract(bonusResources).generateBonusResources(countryId);\n        SenateContract(senate).generateVoter(countryId);\n        TreasuryContract(treasury).generateTreasury(countryId);\n        WondersContract1(wonders1).generateWonders1(countryId);\n        WondersContract2(wonders2).generateWonders2(countryId);\n        WondersContract3(wonders3).generateWonders3(countryId);\n        WondersContract4(wonders4).generateWonders4(countryId);\n        emit NationCreated(nationName, ruler, countryId, msg.sender);\n        countryId++;\n    }\n\n    ///@dev this function will return the current country Id that gets incremented every time a county is minted\n    ///@return uint256 will be number of countries minted\n    function getCountryCount() public view returns (uint256) {\n        return countryId;\n    }\n\n    function checkOwnership(uint256 nationId, address caller) public view returns (bool) {\n        address owner = ownerOf(nationId);\n        if (owner == caller) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function tokensOfOwner(address owner) public view returns (uint256[] memory) {\n        return ownerCountryIds[owner];\n    }\n}\n"
    },
    "contracts/CountryParameters.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./CountryMinter.sol\";\nimport \"./Senate.sol\";\nimport \"./KeeperFile.sol\";\nimport \"./Wonders.sol\";\nimport \"./Treasury.sol\";    \nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"hardhat/console.sol\";\n\n///@title CountryParametersContract\n///@author OxSnosh\n///@dev this contract will inferit from Chainlink VRF and OpenZeppelin Ownable\ncontract CountryParametersContract is VRFConsumerBaseV2, Ownable {\n    address public spyAddress;\n    address public senateAddress;\n    uint256[] private s_randomWords;\n    address public countryMinter;\n    address public keeper;\n    address public nuke;\n    address public groundBattle;\n    address public wonders1;\n    address public treasury;\n\n    //chainlink variables\n    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;\n    uint64 private immutable i_subscriptionId;\n    bytes32 private immutable i_gasLane;\n    uint32 private immutable i_callbackGasLimit;\n    uint16 private constant REQUEST_CONFIRMATIONS = 3;\n    uint32 private constant NUM_WORDS = 2;\n\n    CountryMinter mint;\n    SenateContract senate;\n    KeeperContract keep;\n    WondersContract1 won1;\n    TreasuryContract tres;\n\n    struct CountryParameters {\n        uint256 id;\n        string rulerName;\n        string nationName;\n        string capitalCity;\n        string nationSlogan;\n    }\n\n    struct CountrySettings {\n        uint256 dayCreated;\n        string alliance;\n        uint256 nationTeam;\n        uint256 governmentType;\n        uint256 dayGovernmentChanged;\n        uint256 nationalReligion;\n        uint256 dayReligionChanged;\n        uint256 dayOfAnarchy;\n    }\n\n    event RulerNameChanged(\n        uint256 indexed countryId,\n        string indexed newRulerName\n    );\n\n    event NationNameChanged(\n        uint256 indexed countryId,\n        string indexed newNationName\n    );\n\n    event CapitalCityChanged(\n        uint256 indexed countryId,\n        string indexed newCapitalCity\n    );\n\n    event NationSloganChanged(\n        uint256 indexed countryId,\n        string indexed newNationSlogan\n    );\n\n    event AllianceChanged(\n        uint256 indexed countryId,\n        string indexed newAlliance\n    );\n\n    event TeamChanged(uint256 indexed countryId, uint256 indexed newTeam);\n\n    event GovernmentChanged(\n        uint256 indexed countryId,\n        uint256 indexed newGovernment\n    );\n\n    event ReligionChanged(\n        uint256 indexed countryId,\n        uint256 indexed newReligion\n    );\n\n    event AnarchyInflicted(uint256 indexed countryId);\n\n    mapping(uint256 => CountryParameters) public idToCountryParameters;\n    mapping(uint256 => CountrySettings) public idToCountrySettings;\n    mapping(uint256 => uint256) s_requestIdToRequestIndex;\n    mapping(uint256 => uint256[]) public s_requestIndexToRandomWords;\n    mapping(uint256 => uint256) private idToReligionPreference;\n    mapping(uint256 => uint256) private idToGovernmentPreference;\n\n    // mapping(uint256 => address) public idToOwnerParameters;\n\n    modifier onlyNukeAndGroundBattle() {\n        require(\n            msg.sender == nuke || msg.sender == groundBattle,\n            \"function only callable from nuke or battle contract\"\n        );\n        _;\n    }\n\n    ///@dev the consructor will inherit parameters required to initialize the chainlinh VRF functionality\n    constructor(\n        address vrfCoordinatorV2,\n        uint64 subscriptionId,\n        bytes32 gasLane,\n        uint32 callbackGasLimit\n    ) VRFConsumerBaseV2(vrfCoordinatorV2) {\n        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2);\n        i_gasLane = gasLane;\n        i_subscriptionId = subscriptionId;\n        i_callbackGasLimit = callbackGasLimit;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _spy,\n        address _countryMinter,\n        address _senate,\n        address _keeper,\n        address _nuke,\n        address _groundBattle,\n        address _wonders1,\n        address _treasury\n    ) public onlyOwner {\n        spyAddress = _spy;\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        senateAddress = _senate;\n        senate = SenateContract(_senate);\n        keeper = _keeper;\n        keep = KeeperContract(_keeper);\n        nuke = _nuke;\n        groundBattle = _groundBattle;\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        treasury = _treasury;\n        tres = TreasuryContract(_treasury);\n    }\n\n    modifier onlySpyContract() {\n        require(\n            msg.sender == spyAddress,\n            \"function only callable from spy contract\"\n        );\n        _;\n    }\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"function only callable from the country minter contract\"\n        );\n        _;\n    }\n\n    ///@dev this is a public function but only callable from the counry minter contract\n    ///@notice this function will get called only when a nation is minted\n    ///@param id this will be the nations ID that is passed in from the country minter contact\n    ///@param rulerName name passed in from country minter contract when a nation is minted\n    ///@param nationName passed in from the country minter contract when a nation is minted\n    ///@param capitalCity passed in from the country minter contract when a nation is minted\n    ///@param nationSlogan passed in from the country minter contract when a nation is minted\n    function generateCountryParameters(\n        uint256 id,\n        string memory rulerName,\n        string memory nationName,\n        string memory capitalCity,\n        string memory nationSlogan\n    ) public onlyCountryMinter {\n        CountryParameters memory newCountryParameters = CountryParameters(\n            id,\n            rulerName,\n            nationName,\n            capitalCity,\n            nationSlogan\n        );\n        uint256 day = keep.getGameDay();\n        CountrySettings memory newCountrySettings = CountrySettings(\n            day,\n            \"No Alliance Yet\",\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        );\n        idToCountryParameters[id] = newCountryParameters;\n        idToCountrySettings[id] = newCountrySettings;\n        fulfillRequest(id);\n    }\n\n    ///@dev this is an internal function that will initalize the call for randomness from the chainlink VRF contract\n    ///@param id is the nation ID of the nation being minted\n    function fulfillRequest(uint256 id) internal {\n        uint256 requestId = i_vrfCoordinator.requestRandomWords(\n            i_gasLane,\n            i_subscriptionId,\n            REQUEST_CONFIRMATIONS,\n            i_callbackGasLimit,\n            NUM_WORDS\n        );\n        s_requestIdToRequestIndex[requestId] = id;\n    }\n\n    ///@dev this is the function that gets called by the chainlink VRF contract\n    ///@param requestId is the parameter that will allow the chainlink VRF to store a nations corresponding random words\n    ///@param randomWords this array will contain 2 random numbers that will be used to determine a nations desired religion and government upon minting\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) internal override {\n        uint256 requestNumber = s_requestIdToRequestIndex[requestId];\n        s_requestIndexToRandomWords[requestNumber] = randomWords;\n        s_randomWords = s_requestIndexToRandomWords[requestNumber];\n        uint256 religionPreference = ((randomWords[0] % 14) + 1);\n        uint256 governmentPreference = ((randomWords[1] % 9) + 1);\n        idToReligionPreference[requestNumber] = religionPreference;\n        idToGovernmentPreference[requestNumber] = governmentPreference;\n    }\n\n    ///@dev this is public function that will allow a nation ruler to reset a nations ruler name\n    ///@notice use this function to reset a nations ruler name\n    ///@notice this function is only callable by the nation owner\n    ///@param newRulerName is the updated name for the nation ruler\n    ///@param id is the nation ID for the update\n    function setRulerName(string memory newRulerName, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        tres.spendBalance(id, 20000000 * (10**18));\n        idToCountryParameters[id].rulerName = newRulerName;\n        emit RulerNameChanged(id, newRulerName);\n    }\n\n    ///@dev this is public function that will allow a nation ruler to reset a nations name\n    ///@notice use this function to reset a nations name\n    ///@notice this function is only callable by the nation owner\n    ///@param newNationName is the updated name for the nation ruler\n    ///@param id is the nation ID for the update\n    function setNationName(string memory newNationName, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        tres.spendBalance(id, 20000000 * (10**18));\n        idToCountryParameters[id].nationName = newNationName;\n        emit NationNameChanged(id, newNationName);\n    }\n\n    ///@dev this is public function that will allow a nation ruler to reset a nations capital city name\n    ///@notice use this function to reset a nations capital city name\n    ///@notice this function is only callable by the nation owner\n    ///@param newCapitalCity is the updated name for the nation ruler\n    ///@param id is the nation ID for the update\n    function setCapitalCity(string memory newCapitalCity, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        idToCountryParameters[id].capitalCity = newCapitalCity;\n        emit CapitalCityChanged(id, newCapitalCity);\n    }\n\n    ///@dev this is public function that will allow a nation ruler to reset a nations slogan\n    ///@notice use this function to reset a nations slogan\n    ///@notice this function is only callable by the nation owner\n    ///@param newNationSlogan is the updated name for the nation ruler\n    ///@param id is the nation ID for the update\n    function setNationSlogan(string memory newNationSlogan, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        idToCountryParameters[id].nationSlogan = newNationSlogan;\n        emit NationSloganChanged(id, newNationSlogan);\n    }\n\n    ///@dev this is public function that will allow a nation ruler to set an alliance\n    ///@notice use this function to set an alliance\n    ///@notice this function is only callable by the nation owner\n    ///@notice there are an unlimited number of alliances , anyone can start an alliance\n    ///@param newAlliance is the updated name for the nation ruler\n    ///@param id is the nation ID for the update\n    function setAlliance(string memory newAlliance, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        idToCountrySettings[id].alliance = newAlliance;\n        emit AllianceChanged(id, newAlliance);\n    }\n\n    ///@dev this is public function that will allow a nation ruler to set a team membership for the nation\n    ///@notice use this function to set a team membership for the nation\n    ///@notice this function is only callable by the nation owner\n    ///@notice there are only 15 teams in the game, each team has senators that can sanction nations on that team from trading and send sending aid to eachother\n    ///@param newTeam is the updated name for the nation ruler\n    ///@param id is the nation ID for the update\n    function setTeam(uint256 id, uint256 newTeam) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(newTeam <= 15, \"invalid team selection\");\n        bool isSenator = senate.isSenator(id);\n        require(isSenator == false, \"cannot chenge teams as a senator\");\n        senate.updateTeam(id, newTeam);\n        idToCountrySettings[id].nationTeam = newTeam;\n        emit TeamChanged(id, newTeam);\n    }\n\n    ///@dev this is public function that will allow a nation ruler to chenge their government type\n    ///@notice use this function to reset a nations government type\n    ///@notice this function is only callable by the nation owner\n    ///@notice there are 10 government types each with different advantages\n    ///@param newType is the updated type of government\n    /** @notice for newType:\n     * 0 = Anarchy\n     * 1 = Capitalism\n     * 2 = Communist\n     * 3 = Democracy\n     * 4 = Dictatorship\n     * 5 = Federal Government\n     * 6 = Monarchy\n     * 7 = Republic\n     * 8 = Revolutionary\n     * 9 = Totalitarian\n     * 10 = Transitional\n     ***/\n    ///@param id is the nation ID for the update\n    function setGovernment(uint256 id, uint256 newType) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 gameDay = keep.getGameDay();\n        uint256 anarchyDay = idToCountrySettings[id].dayOfAnarchy;\n        bool falloutShelter = won1.getFalloutShelterSystem(id);\n        if (falloutShelter) {\n            require(\n                (gameDay - anarchyDay) >= 4,\n                \"nation in anarchy, must wait 4 days\"\n            );\n        } else {\n            require(\n                (gameDay - anarchyDay) >= 5,\n                \"nation in anarchy, must wait 5 days\"\n            );\n        }\n        uint256 dayOfChange = idToCountrySettings[id].dayGovernmentChanged;\n        require(\n            (gameDay - dayOfChange) >= 3,\n            \"need to wait 3 days before changing\"\n        );\n        require(newType <= 10, \"invalid type\");\n        require(newType > 0, \"invalid type\");\n        idToCountrySettings[id].governmentType = newType;\n        idToCountrySettings[id].dayGovernmentChanged = gameDay;\n        emit GovernmentChanged(id, newType);\n    }\n\n    ///@dev this is a public function but it is only callable from the spy contract\n    ///@notice this is the function that the spy contract calls when a successful spy attack updates your desired governemnt\n    ///@param id is the nation id of the updated desired government\n    ///@param newType is the updated governemnt type\n    function updateDesiredGovernment(\n        uint256 id,\n        uint256 newType\n    ) public onlySpyContract {\n        idToGovernmentPreference[id] = newType;\n    }\n\n    ///@dev this is public function that will allow a nation ruler to chenge their religion type\n    ///@notice use this function to reset a nations religion type\n    ///@notice this function is only callable by the nation owner\n    ///@notice there are 14 religion types\n    ///@param newType is the updated name for the nation ruler\n    ///@param id is the nation ID for the update\n    function setReligion(uint256 id, uint256 newType) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 gameDay = keep.getGameDay();\n        uint256 dayOfChange = idToCountrySettings[id].dayReligionChanged;\n        require(\n            (gameDay - dayOfChange) >= 3,\n            \"need to wait 3 days before changing\"\n        );\n        require(newType > 0, \"invalid type\");\n        require(newType <= 14, \"invalid type\");\n        idToCountrySettings[id].nationalReligion = newType;\n        idToCountrySettings[id].dayReligionChanged = gameDay;\n        emit ReligionChanged(id, newType);\n    }\n\n    ///@dev this is a public function but it is only callable from the spy contract\n    ///@notice this is the function that the spy contract calls when a successful spy attack updates your desired religion\n    ///@param id is the nation id of the updated desired religion\n    ///@param newType is the updated religion type\n    function updateDesiredReligion(\n        uint256 id,\n        uint256 newType\n    ) public onlySpyContract {\n        idToReligionPreference[id] = newType;\n    }\n\n    function inflictAnarchy(uint256 id) public onlyNukeAndGroundBattle {\n        uint256 gameDay = keep.getGameDay();\n        idToCountrySettings[id].governmentType = 0;\n        idToCountrySettings[id].dayOfAnarchy = gameDay;\n        emit AnarchyInflicted(id);\n        emit GovernmentChanged(id, 0);\n    }\n\n    ///@dev this is a view funtion that will return the ruler name for a country\n    ///@param countryId this is the ID for the nation being queried\n    function getRulerName(\n        uint256 countryId\n    ) public view returns (string memory) {\n        string memory ruler = idToCountryParameters[countryId].rulerName;\n        return ruler;\n    }\n\n    ///@dev this is a view funtion that will return the nation name for a country\n    ///@param countryId this is the ID for the nation being queried\n    function getNationName(\n        uint256 countryId\n    ) public view returns (string memory) {\n        string memory nationName = idToCountryParameters[countryId].nationName;\n        return nationName;\n    }\n\n    ///@dev this is a view funtion that will return the capital city for a country\n    ///@param countryId this is the ID for the nation being queried\n    function getCapital(uint256 countryId) public view returns (string memory) {\n        string memory capital = idToCountryParameters[countryId].capitalCity;\n        return capital;\n    }\n\n    ///@dev this is a view funtion that will return the slogan for a country\n    ///@param countryId this is the ID for the nation being queried\n    function getSlogan(uint256 countryId) public view returns (string memory) {\n        string memory slogan = idToCountryParameters[countryId].nationSlogan;\n        return slogan;\n    }\n\n    ///@dev this is a view funtion that will return the alliance name for a country\n    ///@param countryId this is the ID for the nation being queried\n    function getAlliance(\n        uint256 countryId\n    ) public view returns (string memory) {\n        string memory alliance = idToCountrySettings[countryId].alliance;\n        return alliance;\n    }\n\n    ///@dev this is a view funtion that will return the team for a country\n    ///@param countryId this is the ID for the nation being queried\n    function getTeam(uint256 countryId) public view returns (uint256) {\n        return idToCountrySettings[countryId].nationTeam;\n    }\n\n    ///@dev this is a view funtion that will return the goverment type for a country\n    ///@param countryId this is the ID for the nation being queried\n    function getGovernmentType(\n        uint256 countryId\n    ) public view returns (uint256) {\n        return idToCountrySettings[countryId].governmentType;\n    }\n\n    ///@dev this is a view funtion that will return the religion type for a country\n    ///@param countryId this is the ID for the nation being queried\n    function getReligionType(uint256 countryId) public view returns (uint256) {\n        return idToCountrySettings[countryId].nationalReligion;\n    }\n\n    ///@dev this is a view funtion that will return the time a nation was minted\n    ///@param countryId this is the ID for the nation being queried\n    function getDayCreated(uint256 countryId) public view returns (uint256) {\n        return idToCountrySettings[countryId].dayCreated;\n    }\n\n    ///@dev this is a view funtion that will return the government preference for a country\n    ///@param id this is the ID for the nation being queried\n    function getGovernmentPreference(\n        uint256 id\n    ) public view returns (uint256 preference) {\n        return idToGovernmentPreference[id];\n    }\n\n    ///@dev this is a view funtion that will return the religion preference for a country\n    ///@param id this is the ID for the nation being queried\n    function getReligionPreference(\n        uint256 id\n    ) public view returns (uint256 preference) {\n        return idToReligionPreference[id];\n    }\n\n    ///@dev this is a view funtion that will return the days since a religion and governemnt change for a nation\n    ///@param id this is the ID for the nation being queried\n    ///@return uint256 will return an array with [0] as the days since governemtn change and [1] as days since religion change\n    function getDaysSince(uint256 id) public view returns (uint256, uint256) {\n        uint256 gameDay = keep.getGameDay();\n        uint256 dayOfGovChange = idToCountrySettings[id].dayGovernmentChanged;\n        uint256 daysSinceGovChange = gameDay - dayOfGovChange;\n        uint256 dayReligionChanged = idToCountrySettings[id].dayReligionChanged;\n        uint256 daysSinceReligionChange = gameDay - dayReligionChanged;\n        return (daysSinceGovChange, daysSinceReligionChange);\n    }\n}\n"
    },
    "contracts/Crime.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./Infrastructure.sol\";\nimport \"./Improvements.sol\";\nimport \"./CountryParameters.sol\";\nimport \"./Wonders.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"hardhat/console.sol\";\n\n///@title CrimeContract\n///@author OxSnosh\n///@notice this contract will calculate the number of criminals in a nations population\ncontract CrimeContract is Ownable {\n    address public infrastructure;\n    address public improvements1;\n    address public improvements2;\n    address public improvements3;\n    address public improvements4;\n    address public parameters;\n    address public wonders2;\n\n    InfrastructureContract inf;\n    ImprovementsContract1 imp1;\n    ImprovementsContract2 imp2;\n    ImprovementsContract3 imp3;\n    ImprovementsContract4 imp4;\n    CountryParametersContract cp;\n    WondersContract2 won2;\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _infrastructure,\n        address _improvements1,\n        address _improvements2,\n        address _improvements3,\n        address _improvements4,\n        address _parameters,\n        address _wonders2\n    ) public onlyOwner {\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        improvements1 = _improvements1;\n        imp1 = ImprovementsContract1(_improvements1);\n        improvements2 = _improvements2;\n        imp2 = ImprovementsContract2(_improvements2);\n        improvements3 = _improvements3;\n        imp3 = ImprovementsContract3(_improvements3);\n        parameters = _parameters;\n        improvements4 = _improvements4;\n        imp4 = ImprovementsContract4(_improvements4);\n        cp = CountryParametersContract(_parameters);\n        wonders2 = _wonders2;\n        won2 = WondersContract2(_wonders2);\n    }\n\n    ///@dev this is a public view function that will calculate the number of criminals in a nations population\n    ///@notice this will calulate the number of criminals in a nations population\n    ///@notice criminals will rduce the amount of your tax paying citizens\n    ///@notice you will also lose population happiness as your criminal population increases\n    ///@notice jails, labor camps, border walls and prisons will reduce the number of criminals in your nation\n    ///@param id this is the nation ID for the nation being queried\n    ///@return uint256 this function will return the number of criminals in your population\n    function getCriminalCount(\n        uint256 id\n    ) public view returns (uint256, uint256, uint256) {\n        uint256 totalPopulation = inf.getTotalPopulationCount(id);\n        uint256 crimeIndex = getCrimeIndex(id);\n        uint256 criminalPercentage = (crimeIndex + 1);\n        uint256 baseCriminalCount = ((totalPopulation * criminalPercentage) /\n            100);\n        uint256 rehabs = imp3.getRehabilitationFacilityCount(id);\n        uint256 rehabilitatedCitizens = (rehabs * 1000);\n        if (baseCriminalCount <= rehabilitatedCitizens) {\n            rehabilitatedCitizens = baseCriminalCount;\n            baseCriminalCount = 0;\n        } else {\n            baseCriminalCount = baseCriminalCount - rehabilitatedCitizens;\n        }\n        (uint256 criminalCount, uint256 incarcerated) = incarcerateCriminals(baseCriminalCount, id);\n        return (criminalCount, rehabilitatedCitizens, incarcerated);\n    }\n\n    function incarcerateCriminals(\n        uint256 baseCriminalCount,\n        uint256 countryId\n    ) public view returns (uint256, uint256) {\n        uint256 jailCount = imp2.getJailCount(countryId);\n        uint256 laborCamps = imp2.getLaborCampCount(countryId);\n        uint256 prisons = imp3.getPrisonCount(countryId);\n        uint256 incarceratedCriminals = 0;\n        uint256 roomForIncarceration = ((jailCount * 500) +\n            (laborCamps * 200) +\n            (prisons * 5000));\n        if (baseCriminalCount <= roomForIncarceration) {\n            incarceratedCriminals = baseCriminalCount;\n            baseCriminalCount = 0;\n        } else {\n            baseCriminalCount = baseCriminalCount - roomForIncarceration;\n            incarceratedCriminals = roomForIncarceration;\n        }\n        uint256 criminalCountPercentageModifier = 100;\n        uint256 borderWalls = imp1.getBorderWallCount(countryId);\n        if (borderWalls > 0) {\n            criminalCountPercentageModifier -= borderWalls;\n        }\n        uint256 criminalCount = ((baseCriminalCount *\n            criminalCountPercentageModifier) / 100);\n        return (criminalCount, incarceratedCriminals);\n    }\n\n    ///@dev this function will take your nation's crime prevention score and return a crime index\n    ///@notice the higher your crime prevention score the lower your crime index\n    ///@notice the higher your crime index the more criminals you will have in your population\n    ///@param id this is the nation ID of the country being queried\n    ///@return uint256 this is crime index of the nation\n    ///@notice the percentage of your population that is criminals = crime index +1\n    function getCrimeIndex(uint256 id) public view returns (uint256) {\n        uint256 cps = getCrimePreventionScore(id);\n        uint256 crimeIndex;\n        if (cps < 200) {\n            crimeIndex = 6;\n        } else if (cps < 250) {\n            crimeIndex = 5;\n        } else if (cps < 300) {\n            crimeIndex = 4;\n        } else if (cps < 350) {\n            crimeIndex = 3;\n        } else if (cps < 400) {\n            crimeIndex = 2;\n        } else if (cps < 500) {\n            crimeIndex = 1;\n        } else {\n            crimeIndex = 0;\n        }\n        return crimeIndex;\n    }\n\n    ///@dev this is a public view function that calculates a nations crime prevention score\n    ///@notice this function calculates crime prevention score\n    ///@notice the higher the CPS the lower the number of criminals in your population\n    ///@param id is the nation ID of the nation being queried\n    ///@return uint256 is the crime prevention score being returned by the function\n    function getCrimePreventionScore(uint256 id) public view returns (uint256) {\n        uint256 litPoints = getLiteracyPoints(id);\n        uint256 improvementPoints = getImprovementPoints(id);\n        uint256 taxRatePoints = getTaxRateCrimeMultiplier(id);\n        uint256 governmentPoints = getPointsFromGovernmentType(id);\n        uint256 getPointsFromInfrastructure = getPointsFromInfrastruture(id);\n        uint256 populationPoints = getPointsFromPopulation(id);\n        uint256 cps = (litPoints +\n            improvementPoints +\n            taxRatePoints +\n            governmentPoints +\n            getPointsFromInfrastructure +\n            populationPoints);\n        return cps;\n    }\n\n    ///@dev this is a public view function that returns the literace rate of the nation\n    ///@notice this function will return a nations literacy rate\n    ///@param id is the nation ID of the countey being queried\n    ///@return uint256 is the literacy rate of the nation\n    ///@notice literacy is increased by the amount of technology of a nation as well as the amount of schools and universities\n    ///@notice increased literacy will increase crime prevention score\n    function getLiteracy(uint256 id) public view returns (uint256) {\n        uint256 tech = inf.getTechnologyCount(id);\n        uint256 litBeforeModifiers;\n        if (tech <= 50) {\n            litBeforeModifiers = 20;\n        } else {\n            uint256 addedLiteracy = ((tech - 50) / 3);\n            litBeforeModifiers = (20 + addedLiteracy);\n        }\n        uint256 schoolPoints = imp3.getSchoolCount(id);\n        uint256 universities = imp3.getUniversityCount(id);\n        uint256 universityPoints = (universities * 3);\n        bool greatUniversity = won2.getGreatUniversity(id);\n        if (greatUniversity == true) {\n            universityPoints += 10;\n        }\n        uint256 literacy = (litBeforeModifiers +\n            schoolPoints +\n            universityPoints);\n        if (literacy > 100) {\n            literacy = 100;\n        }\n        return literacy;\n    }\n\n    ///@dev this function is a public view function that will calculate the amount of points that a nations literace rate will add to the crime prevention score\n    ///@notice literaacy will increse the crime prevention score of a nation\n    ///@notice crime prevention score points added will be 80% of literacy (max of 80 points added)\n    ///@param id is the nation ID of the nation being queried\n    ///@return uint256 is the amount of points being added to the crime prevention score\n    function getLiteracyPoints(uint256 id) public view returns (uint256) {\n        uint256 literacyPercentage = getLiteracy(id);\n        uint256 litPoints = ((literacyPercentage * 80) / 100);\n        return litPoints;\n    }\n\n    ///@dev this is a publci view function that will calculate the amount of crime prevention score points from a nations improvements and tax rate\n    ///@notice schools, universities, polive headquarters, casinos and red light districts all affect a nations crime prevention score\n    ///@notice a nations tax rate will change the magnitude of these improvements affect on crime prevention score\n    ///@notice the higher a tax rate the lower the crime prevention score will be and the more criminals a population will have\n    ///@param id this is the nation ID of the nation being queried\n    ///@return uint256 is the number of points added to crime prevention score from imrpovements and tax rate\n    function getImprovementPoints(uint256 id) public view returns (uint256) {\n        uint256 schools = imp3.getSchoolCount(id);\n        uint256 universities = imp3.getUniversityCount(id);\n        uint256 policeHqs = imp4.getPoliceHeadquartersCount(id);\n        uint256 casinoCount = imp1.getCasinoCount(id);\n        uint256 redLightDistricts = imp3.getRedLightDistrictCount(id);\n        uint256 schoolPoints = (schools * 3);\n        uint256 universityPoints = (universities * 10);\n        uint256 policeHqPoints = (policeHqs * 2);\n        uint256 casinoPoints = (casinoCount * 2);\n        uint256 redLightDistrictPoints = (redLightDistricts * 2);\n        uint256 improvementPoints = (8 +\n            schoolPoints +\n            universityPoints +\n            policeHqPoints -\n            casinoPoints -\n            redLightDistrictPoints);\n        return improvementPoints;\n    }\n\n    ///@dev this a public vuew function that will return the multiplier used to adjust the affect that a nations tax rate will have on crime prevention score\n    ///@notice the higher a nations tax rate the lower the multiplier will be and the lower the crime prevention score will be\n    ///@param id is the nation ID of the nation being queried\n    ///@return uint256 is the munliplier used to adjust the points added to crime prevention score from taxes and improvements\n    function getTaxRateCrimeMultiplier(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 taxRate = inf.getTaxRate(id);\n        uint256 taxRateCrimeMultiplier;\n        if (taxRate <= 15) {\n            taxRateCrimeMultiplier = 35;\n        } else if (taxRate == 16) {\n            taxRateCrimeMultiplier = 34;\n        } else if (taxRate == 17) {\n            taxRateCrimeMultiplier = 33;\n        } else if (taxRate == 18) {\n            taxRateCrimeMultiplier = 32;\n        } else if (taxRate == 19) {\n            taxRateCrimeMultiplier = 31;\n        } else if (taxRate == 20) {\n            taxRateCrimeMultiplier = 30;\n        } else if (taxRate == 21) {\n            taxRateCrimeMultiplier = 29;\n        } else if (taxRate == 22) {\n            taxRateCrimeMultiplier = 28;\n        } else if (taxRate == 23) {\n            taxRateCrimeMultiplier = 27;\n        } else if (taxRate == 24) {\n            taxRateCrimeMultiplier = 26;\n        } else if (taxRate == 25) {\n            taxRateCrimeMultiplier = 25;\n        } else if (taxRate == 26) {\n            taxRateCrimeMultiplier = 24;\n        } else if (taxRate == 27) {\n            taxRateCrimeMultiplier = 23;\n        } else if (taxRate == 28) {\n            taxRateCrimeMultiplier = 22;\n        } else if (taxRate == 29) {\n            taxRateCrimeMultiplier = 21;\n        } else if (taxRate == 30) {\n            taxRateCrimeMultiplier = 20;\n        }\n        uint256 taxMultiplier = (taxRateCrimeMultiplier);\n        return taxMultiplier;\n    }\n\n    ///@dev this is a public view function that will add points to crime prevention score based on government type\n    ///@notice different govermnet types will affect a nations crime prevenetion score differently\n    ///@param id is the nation ID of the nation being queried\n    ///@return uint256 is the points added to crime prevention score from governemtn type\n    function getPointsFromGovernmentType(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 governmentPoints;\n        uint256 gov = cp.getGovernmentType(id);\n        if (gov == 0) {\n            /** Anarchy */\n            governmentPoints = 50;\n        } else if (gov == 1) {\n            /** Capitalist */\n            governmentPoints = 110;\n        } else if (gov == 2) {\n            /** Communist */\n            governmentPoints = 150;\n        } else if (gov == 3) {\n            /** Democracy */\n            governmentPoints = 120;\n        } else if (gov == 4) {\n            /** Dictatorship */\n            governmentPoints = 175;\n        } else if (gov == 5) {\n            /** Federal Goverment */\n            governmentPoints = 160;\n        } else if (gov == 6) {\n            /** Monarchy */\n            governmentPoints = 140;\n        } else if (gov == 7) {\n            /** Republic */\n            governmentPoints = 165;\n        } else if (gov == 8) {\n            /** Revolutuionary */\n            governmentPoints = 150;\n        } else if (gov == 9) {\n            /** Totalitarian State */\n            governmentPoints = 190;\n        } else {\n            /** Transitional */\n            governmentPoints = 100;\n        }\n        return governmentPoints;\n    }\n\n    ///@dev this is a public view function that will return the crime prevention score points from infrastructure\n    ///@notice more infrastructure will increase crime prevention score reducing criminals\n    ///@param id is the nation ID for the countrtry being queried\n    ///@return uint256 is the points added to crime prevention score from infrastructure\n    function getPointsFromInfrastruture(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 infra = inf.getInfrastructureCount(id);\n        uint256 infraPoints = (infra / 400);\n        return infraPoints;\n    }\n\n    ///@dev this is a public view function that will add points to crime prevention score based on population\n    ///@notice increased population will reduce croime prevention score\n    ///@param id is the nation id of the nation being queries\n    ///@return uint256 is the amount of points being added to crime prevention score\n    function getPointsFromPopulation(uint256 id) public view returns (uint256) {\n        uint256 population = inf.getTotalPopulationCount(id);\n        uint256 populationPointsDeduction = (population / 250);\n        if (populationPointsDeduction >= 350) {\n            populationPointsDeduction = 350;\n        }\n        uint256 populationPoints = (350 - populationPointsDeduction);\n        return populationPoints;\n    }\n}\n"
    },
    "contracts/CruiseMissile.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./Forces.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./War.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Wonders.sol\";\nimport \"./Missiles.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport \"hardhat/console.sol\";\n\n///@title CruiseMissileContract\n///@author OxSnosh\n///@notice this contract will allow a nation owner to launch a cruise missile attack against another nation\n///@dev this contract inherits from OpenZeppelin ownable and Chainlink VRF\ncontract CruiseMissileContract is Ownable, VRFConsumerBaseV2 {\n    uint256 public cruiseMissileAttackId;\n    address public forces;\n    address public countryMinter;\n    address public warAddress;\n    address public infrastructure;\n    address public missiles;\n    address public improvements1;\n    address public improvements3;\n    address public improvements4;\n    address public wonders2;\n\n    //Chainlik Variables\n    uint256[] private s_randomWords;\n    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;\n    uint64 private immutable i_subscriptionId;\n    bytes32 private immutable i_gasLane;\n    uint32 private immutable i_callbackGasLimit;\n    uint16 private constant REQUEST_CONFIRMATIONS = 3;\n    uint32 private constant NUM_WORDS = 3;\n\n    ForcesContract force;\n    CountryMinter mint;\n    WarContract war;\n    InfrastructureContract inf;\n    MissilesContract mis;\n    ImprovementsContract1 imp1;\n    ImprovementsContract3 imp3;\n    ImprovementsContract4 imp4;\n    WondersContract2 won2;\n\n    struct CruiseMissileAttack {\n        uint256 warId;\n        uint256 attackerId;\n        uint256 defenderId;\n        uint256 tanksDestroyed;\n        uint256 technologyDestroyed;\n        uint256 infrastructureDestroyed;\n    }\n\n    mapping(uint256 => CruiseMissileAttack) attackIdToCruiseMissile;\n    mapping(uint256 => uint256) s_requestIdToRequestIndex;\n    mapping(uint256 => uint256[]) public s_requestIndexToRandomWords;\n\n    event CruiseMissileLaunched(\n        uint256 indexed attackId,\n        uint256 indexed attackerId,\n        uint256 indexed defenderId,\n        uint256 warId\n    );\n\n    event CruiseMissileAttackResults(\n        uint256 indexed attackId,\n        uint256 indexed attackerId,\n        uint256 indexed defenderId,\n        bool landed,\n        uint256 warId,\n        uint256 damageTypeNumber\n    );\n\n    ///@dev this is the constructor that inherits chainlink variables to use chainlink VRF\n    constructor(\n        address vrfCoordinatorV2,\n        uint64 subscriptionId,\n        bytes32 gasLane, // keyHash\n        uint32 callbackGasLimit\n    ) VRFConsumerBaseV2(vrfCoordinatorV2) {\n        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2);\n        i_gasLane = gasLane;\n        i_subscriptionId = subscriptionId;\n        i_callbackGasLimit = callbackGasLimit;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _forces,\n        address _countryMinter,\n        address _war,\n        address _infrastructure,\n        address _missiles\n    ) public onlyOwner {\n        forces = _forces;\n        force = ForcesContract(_forces);\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        warAddress = _war;\n        war = WarContract(_war);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        missiles = _missiles;\n        mis = MissilesContract(_missiles);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings2(\n        address _improvements1,\n        address _improvements3,\n        address _improvements4,\n        address _wonders2\n    ) public onlyOwner {\n        improvements1 = _improvements1;\n        imp1 = ImprovementsContract1(_improvements1);\n        improvements3 = _improvements3;\n        imp3 = ImprovementsContract3(_improvements3);\n        improvements4 = _improvements4;\n        imp4 = ImprovementsContract4(_improvements4);\n        wonders2 = _wonders2;\n        won2 = WondersContract2(_wonders2);\n    }\n\n    ///@dev this is a public function that will allow a nation to launch a cruise missile attack against another nation\n    ///@notice this function allows a nation owner to launch a cruise missile attack\n    ///@notice can only attack another nation where war is currently declared\n    ///@param attackerId is the ID of the attacking nation\n    ///@param defenderId is the ID of the defendin nation\n    ///@param warId is the ID for the war between the two nations\n    function launchCruiseMissileAttack(\n        uint256 attackerId,\n        uint256 defenderId,\n        uint256 warId\n    ) public {\n        bool isOwner = mint.checkOwnership(attackerId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 missileCount = mis.getCruiseMissileCount(attackerId);\n        require(missileCount > 0, \"no cruise missiles\");\n        bool isWarActive = war.isWarActive(warId);\n        require(isWarActive, \"not active war\");\n        (uint256 offense, uint256 defense) = war.getInvolvedParties(warId);\n        require(\n            (attackerId == offense && defenderId == defense) ||\n                (attackerId == defense && defenderId == offense),\n            \"not involved in war\"\n        );\n        CruiseMissileAttack memory newAttack = CruiseMissileAttack(\n            warId,\n            attackerId,\n            defenderId,\n            0,\n            0,\n            0\n        );\n        war.incrementCruiseMissileAttack(warId, attackerId);\n        attackIdToCruiseMissile[cruiseMissileAttackId] = newAttack;\n        emit CruiseMissileLaunched(\n            cruiseMissileAttackId,\n            attackerId,\n            defenderId,\n            warId\n        );\n        war.cancelPeaceOffersUponAttack(warId);\n        fulfillRequest(cruiseMissileAttackId);\n        cruiseMissileAttackId++;\n    }\n\n    ///@dev this is an internal function that will call the VRFCoordinator from randomness from chainlink\n    ///@param id this is the ID of the cruise missile attack\n    function fulfillRequest(uint256 id) internal {\n        uint256 requestId = i_vrfCoordinator.requestRandomWords(\n            i_gasLane,\n            i_subscriptionId,\n            REQUEST_CONFIRMATIONS,\n            i_callbackGasLimit,\n            NUM_WORDS\n        );\n        s_requestIdToRequestIndex[requestId] = id;\n    }\n\n    ///@dev this is the fnction that the ChainlinkVRF contract will call when it responds\n    ///@dev this function randomly determine the outcome of the cruise missile attack\n    ///@notice this function will randomly determine is the cruise missile attacke was successful\n    ///@notice attacker satellites increase the odds of a successful attack\n    ///@notice defender satellites and intercepor middile system will increase the odds of a missile attack being thwarted\n    ///@notice a successful cruise missile attacke will reduce defender tanks, tech or infrastructure (type selected randomly)\n    ///@param requestId id the ID number for the request made to the VRF contract\n    ///@param randomWords is the random numbers that the ChainlinkVRF contract responds with\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) internal override {\n        uint256 requestNumber = s_requestIdToRequestIndex[requestId];\n        s_requestIndexToRandomWords[requestNumber] = randomWords;\n        s_randomWords = randomWords;\n        uint256 defenderId = attackIdToCruiseMissile[requestNumber].defenderId;\n        uint256 attackerId = attackIdToCruiseMissile[requestNumber].attackerId;\n        uint256 successOdds = getSuccessOdds(attackerId, defenderId);\n        uint256[] memory randomNumbers = s_requestIndexToRandomWords[\n            requestNumber\n        ];\n        uint256 successNumber = (randomNumbers[0] % 100);\n        uint256 damageTypeNumber = (randomNumbers[1] % 3);\n        if (successNumber < successOdds) {\n            emit CruiseMissileAttackResults(\n                requestNumber,\n                attackerId,\n                defenderId,\n                true,\n                attackIdToCruiseMissile[requestNumber].warId,\n                damageTypeNumber\n            );\n            if (damageTypeNumber == 0) {\n                console.log(\"destroying tanks\");\n                destroyTanks(requestNumber);\n            } else if (damageTypeNumber == 1) {\n                console.log(\"destroying tech\");\n                destroyTech(requestNumber);\n            } else if (damageTypeNumber == 2) {\n                console.log(\"destroying infrastructure\");\n                destroyInfrastructure(requestNumber);\n            }\n        } else {\n            emit CruiseMissileAttackResults(\n                requestNumber,\n                attackerId,\n                defenderId,\n                false,\n                attackIdToCruiseMissile[requestNumber].warId,\n                0\n            );\n        }\n    }\n\n    function getSuccessOdds(\n        uint256 attackerId,\n        uint256 defenderId\n    ) public view returns (uint256) {\n        uint256 successOdds = 75;\n        uint256 defenderMissileDefenses = imp4.getMissileDefenseCount(\n            defenderId\n        );\n        uint256 attackerSattelites = imp3.getSatelliteCount(attackerId);\n        bool interceptor = won2.getInterceptorMissileSystem(defenderId);\n        if (interceptor) {\n            successOdds -= 25;\n        }\n        if (defenderMissileDefenses > 0) {\n            successOdds -= (5 * defenderMissileDefenses);\n        }\n        if (attackerSattelites > 0) {\n            successOdds += (5 * attackerSattelites);\n        }\n        return successOdds;\n    }\n\n    ///@dev this is the internal function that will determine the number of tanks destroyed in a cruise missile attack\n    ///@notice this function will decrease the number of tanks of the defender in a successful cruise missile attack\n    ///@notice attacker munitions factories will increase the damage inflicted by a cruise missile attack on tanks\n    ///@notice defender bunkers will decrease the damage infilcted by a cruise missile attack on tanks\n    ///@param attackId is the ID of the cruise missile attack\n    function destroyTanks(uint256 attackId) internal {\n        uint256 defenderId = attackIdToCruiseMissile[attackId].defenderId;\n        uint256 attackerId = attackIdToCruiseMissile[attackId].attackerId;\n        uint256 tankCount = force.getDefendingTankCount(defenderId);\n        if (tankCount == 0) {\n            destroyInfrastructure(attackId);\n        } else {\n            uint256[] memory randomNumbers = s_requestIndexToRandomWords[attackId];\n            uint256 defenderBunkerCount = imp1.getBunkerCount(defenderId);\n            uint256 attackerMunitionsFactory = imp4.getMunitionsFactoryCount(\n                attackerId\n            );\n            uint256 randomTankCount = (10 +\n                (randomNumbers[2] % 6) +\n                attackerMunitionsFactory -\n                defenderBunkerCount);\n            if (tankCount <= randomTankCount) {\n                force.decreaseDefendingTankCountFromCruiseMissileContract(\n                    tankCount,\n                    defenderId\n                );\n            } else {\n                force.decreaseDefendingTankCountFromCruiseMissileContract(\n                    randomTankCount,\n                    defenderId\n                );\n            }\n        }\n    }\n\n    ///@dev this is an internal function that will decrease defender Tech in the event of a successful cruise missile launch\n    ///@notice this function will decrease the tech of a defending nation in the event of a successful cruise missile attack\n    ///@notice attacker munitions factories will increase the damage inflicted by a cruise missile attack on tech\n    ///@notice defender bunkers will decrease the damage infilcted by a cruise missile attack on tech\n    ///@param attackId is the ID of the cruise missile attack\n    function destroyTech(uint256 attackId) internal {\n        uint256 defenderId = attackIdToCruiseMissile[attackId].defenderId;\n        uint256 attackerId = attackIdToCruiseMissile[attackId].attackerId;\n        uint256 techCount = inf.getTechnologyCount(defenderId);\n        if (techCount >= 5) {\n            uint256 defenderBunkerCount = imp1.getBunkerCount(defenderId);\n            uint256 attackerMunitionsFactory = imp4.getMunitionsFactoryCount(\n                attackerId\n            );\n            uint256 amount = 6;\n            if (defenderBunkerCount >= 1) {\n                amount -= defenderBunkerCount;\n            }\n            if (attackerMunitionsFactory >= 1) {\n                amount += attackerMunitionsFactory;\n            }\n            inf.decreaseTechCountFromCruiseMissileContract(defenderId, amount);\n        }\n    }\n\n    ///@dev this is an internal function that will decrease defender Infrastructure in the event of a successful cruise missile attack\n    ///@notice this function will decrease the infrastructure of a defending nation in the event of a successful cruise missile attack\n    ///@notice attacker munitions factories will increase the damage inflicted by a cruise missile attack on infrastructure\n    ///@notice defender bunkers will decrease the damage infilcted by a cruise missile attack on infrastructure\n    ///@param attackId is the ID of the cruise missile attack\n    function destroyInfrastructure(uint256 attackId) internal {\n        uint256 defenderId = attackIdToCruiseMissile[attackId].defenderId;\n        uint256 attackerId = attackIdToCruiseMissile[attackId].attackerId;\n        uint256[] memory randomNumbers = s_requestIndexToRandomWords[\n            attackId\n        ];\n        uint256 defenderBunkerCount = imp1.getBunkerCount(defenderId);\n        uint256 attackerMunitionsFactory = imp4.getMunitionsFactoryCount(\n            attackerId\n        );\n        uint256 randomInfrastructureCount = 6;\n        uint256 randomModulus = randomNumbers[2] % 6;\n        randomInfrastructureCount += randomModulus;\n        randomInfrastructureCount += attackerMunitionsFactory;\n        randomInfrastructureCount -= defenderBunkerCount;\n        inf.decreaseInfrastructureCountFromCruiseMissileContract(\n            defenderId,\n            randomInfrastructureCount\n        );\n    }\n}\n"
    },
    "contracts/Environment.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./CountryMinter.sol\";\nimport \"./Resources.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Improvements.sol\";\nimport \"./Wonders.sol\";\nimport \"./Forces.sol\";\nimport \"./Taxes.sol\";\nimport \"./Nuke.sol\";\nimport \"./CountryParameters.sol\";\nimport \"./Missiles.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n///@title EnvironmentContract\n///@author OxSnosh\n///@notice this contract will calculate the environment score for a nation\n///@dev this contact inherits from OpenZeppelin ownable \ncontract EnvironmentContract is Ownable {\n    address public countryMinter;\n    address public resources;\n    address public infrastructure;\n    address public improvements1;\n    address public improvements3;\n    address public improvements4;\n    address public wonders3;\n    address public wonders4;\n    address public forces;\n    address public parameters;\n    address public additionalTaxes;\n    address public missiles;\n    address public nukes;\n    address public bonusResources;\n\n    CountryMinter mint;\n    ResourcesContract res;\n    InfrastructureContract inf;\n    ImprovementsContract1 imp1;\n    ImprovementsContract3 imp3;\n    ImprovementsContract4 imp4;\n    WondersContract3 won3;\n    WondersContract4 won4;\n    ForcesContract force;\n    CountryParametersContract param;\n    AdditionalTaxesContract addTax;\n    MissilesContract mis;\n    NukeContract nuke;\n    BonusResourcesContract bonus;\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers \n    function settings (\n        address _countryMinter,\n        address _resources,\n        address _infrastructure,\n        address _wonders3,\n        address _wonders4,\n        address _forces,\n        address _parameters,\n        address _additionalTaxes,\n        address _missiles,\n        address _nukes\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        wonders3 = _wonders3;\n        won3 = WondersContract3(_wonders3);\n        wonders4 = _wonders4;\n        won4 = WondersContract4(_wonders4);\n        forces = _forces;\n        force = ForcesContract(_forces);\n        parameters = _parameters;\n        param = CountryParametersContract(_parameters);\n        additionalTaxes = _additionalTaxes;\n        addTax = AdditionalTaxesContract(_additionalTaxes);\n        missiles = _missiles;\n        mis = MissilesContract(_missiles);\n        nukes = _nukes;\n        nuke = NukeContract(_nukes);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings2 (\n        address _improvements1,\n        address _improvements3,\n        address _improvements4,\n        address _bonusResources\n    ) public onlyOwner {\n        improvements1 = _improvements1;\n        imp1 = ImprovementsContract1(_improvements1);\n        improvements3 = _improvements3;\n        imp3 = ImprovementsContract3(_improvements3);\n        improvements4 = _improvements4;\n        imp4 = ImprovementsContract4(_improvements4);\n        bonusResources = _bonusResources;\n        bonus = BonusResourcesContract(_bonusResources);\n    }\n\n    ///@dev this is a public view function that will return the environment score for a nation\n    ///@notice a higher environment score will decrease a nations happiness and population\n    ///@param id is the nation ID of the nation being queried\n    ///@return uint256 is the environement score for the nation (environment scores are 0 - 10)\n    function getEnvironmentScore(uint256 id) public view returns (uint256) {\n        uint256 environmentScore;\n        int256 grossScore = getGrossEnvironmentScore(id);\n        uint256 globalRadiation = nuke.getGlobalRadiation();\n        if (globalRadiation > 5) {\n            globalRadiation = 5;\n        }\n        uint256 radiationContainmentChambers = imp3\n            .getRadiationContainmentChamberCount(id);\n        if (radiationContainmentChambers >= 0) {\n            globalRadiation -= radiationContainmentChambers;\n        }\n        bool radiationCleanup = bonus.viewRadiationCleanup(id);\n        if (radiationCleanup) {\n            globalRadiation = (globalRadiation / 2);\n        }\n        if (grossScore <= 0) {\n            environmentScore = 0;\n        } else if (grossScore <= 10) {\n            environmentScore = 1;\n        } else if (grossScore <= 20) {\n            environmentScore = 2;\n        } else if (grossScore <= 30) {\n            environmentScore = 3;\n        } else if (grossScore <= 40) {\n            environmentScore = 4;\n        } else if (grossScore <= 50) {\n            environmentScore = 5;\n        } else if (grossScore <= 60) {\n            environmentScore = 6;\n        } else if (grossScore <= 70) {\n            environmentScore = 7;\n        } else if (grossScore <= 80) {\n            environmentScore = 8;\n        } else if (grossScore <= 90) {\n            environmentScore = 9;\n        } else if (grossScore > 90) {\n            environmentScore = 10;\n        }\n        if ((globalRadiation + environmentScore) > 10) {\n            environmentScore = 10;\n        } else {\n            environmentScore += globalRadiation;\n        }\n        return environmentScore;\n    }\n\n    ///@dev this is a public view function that will generate the gross environment score\n    ///@notice the gross environment score generated here will be converted into the environment score\n    ///@notice every 10 points of gross score is equal to one point of environement\n    ///@param id this is the nation ID being queried\n    ///@return int256 this is the gross environment score\n    function getGrossEnvironmentScore(uint256 id) public view returns (int256) {\n        int256 scoreFromResources = getEnvironmentScoreFromResources(id);\n        int256 scoreFromImprovementsAndWonders = getEnvironmentScoreFromImprovementsAndWonders(\n                id\n            );\n        int256 scoreFromTech = getEnvironmentScoreFromTech(id);\n        int256 scoreFromMilitaryRatio = getEnvironmentScoreFromMilitaryDensity(\n            id\n        );\n        int256 scoreFromInfrastructure = getEnvironmentScoreFromInfrastructure(\n            id\n        );\n        int256 scoreFromNukes = getScoreFromNukes(id);\n        int256 scoreFromGovernment = getScoreFromGovernment(id);\n        int256 grossEnvironmentScore = scoreFromResources +\n            scoreFromImprovementsAndWonders +\n            scoreFromTech +\n            scoreFromMilitaryRatio +\n            scoreFromInfrastructure +\n            scoreFromNukes +\n            scoreFromGovernment;\n        return grossEnvironmentScore;\n    }\n\n    ///@dev this is a public view function that will generate environment points from resources\n    ///@notice coal, oil, iron, uranium, water and radiation cleanup resources will all affect environemnt\n    ///@param id is the nation ID of the nation being queried\n    ///@return int256 is gross environment points from resources\n    function getEnvironmentScoreFromResources(uint256 id)\n        public\n        view\n        returns (int256)\n    {\n        int256 pointsFromResources;\n        bool isCoal = res.viewCoal(id);\n        bool isOil = res.viewOil(id);\n        bool isUranium = res.viewUranium(id);\n        bool isWater = res.viewWater(id);\n        bool isRadiationCleanup = bonus.viewRadiationCleanup(id);\n        bool nationalEnvironmentalOffice = won3.getNationalEnvironmentOffice(id);\n        if (isCoal && !nationalEnvironmentalOffice) {\n            pointsFromResources += 10;\n        }\n        if (isOil && !nationalEnvironmentalOffice) {\n            pointsFromResources += 10;\n        }\n        if (isUranium && !nationalEnvironmentalOffice) {\n            pointsFromResources += 10;\n        }\n        if (isWater) {\n            pointsFromResources -= 10;\n        }\n        if (isRadiationCleanup) {\n            pointsFromResources -= 10;\n        }\n        return pointsFromResources;\n    }\n\n    ///@dev this is a public view function that will generate gross environment score from improvements and wonders\n    ///@notice this function will return gross environment points from improvements and wonders\n    ///@notice border walls, munitions factories and red light districts affect a nations environment score\n    ///@param id this is the nation ID of the nation being queried\n    ///@return int256 is the gross environment points from improvements and wonders\n    function getEnvironmentScoreFromImprovementsAndWonders(uint256 id)\n        public\n        view\n        returns (int256)\n    {\n        uint256 borderWallCount = imp1.getBorderWallCount(id);\n        uint256 munitionsFactories = imp4.getMunitionsFactoryCount(id);\n        uint256 redLightDistricts = imp3.getRedLightDistrictCount(id);\n        bool isNationalEnvironmentOffice = won3.getNationalEnvironmentOffice(\n            id\n        );\n        bool isWeaponsResearchCenter = won4.getWeaponsResearchCenter(id);\n        int256 pointsFromWondersAndImprovements;\n        if (borderWallCount == 0) {\n            pointsFromWondersAndImprovements += 0;\n        } else if (borderWallCount == 1) {\n            pointsFromWondersAndImprovements -= 10;\n        } else if (borderWallCount == 2) {\n            pointsFromWondersAndImprovements -= 20;\n        } else if (borderWallCount == 3) {\n            pointsFromWondersAndImprovements -= 30;\n        } else if (borderWallCount == 4) {\n            pointsFromWondersAndImprovements -= 40;\n        } else if (borderWallCount == 5) {\n            pointsFromWondersAndImprovements -= 50;\n        }\n        if (munitionsFactories == 0) {\n            pointsFromWondersAndImprovements += 0;\n        } else if (munitionsFactories == 1) {\n            pointsFromWondersAndImprovements += 3;\n        } else if (munitionsFactories == 2) {\n            pointsFromWondersAndImprovements += 6;\n        } else if (munitionsFactories == 3) {\n            pointsFromWondersAndImprovements += 9;\n        } else if (munitionsFactories == 4) {\n            pointsFromWondersAndImprovements += 12;\n        } else if (munitionsFactories == 5) {\n            pointsFromWondersAndImprovements += 15;\n        }\n        if (redLightDistricts == 0) {\n            pointsFromWondersAndImprovements += 0;\n        } else if (redLightDistricts == 1) {\n            pointsFromWondersAndImprovements += 5;\n        } else if (redLightDistricts == 2) {\n            pointsFromWondersAndImprovements += 10;\n        }\n        if (isNationalEnvironmentOffice) {\n            pointsFromWondersAndImprovements -= 10;\n        }\n        if (isWeaponsResearchCenter) {\n            pointsFromWondersAndImprovements += 10;\n        }\n        return pointsFromWondersAndImprovements;\n    }\n\n    ///@dev this is a public view function that will generate gross environment score from a nations technology level\n    ///@notice this function will return gross environment points from a nations technology level\n    ///@notice a nations environment score will be penalized if the tech level is less than 6\n    ///@param id this is the nation ID of the nation being queried\n    ///@return int256 is the gross environment points from a nations technology level\n    function getEnvironmentScoreFromTech(uint256 id)\n        public\n        view\n        returns (int256)\n    {\n        uint256 techCount = inf.getTechnologyCount(id);\n        int256 pointsFromTech;\n        if (techCount >= 6) {\n            pointsFromTech = -10;\n        }\n        return pointsFromTech;\n    }\n\n    ///@dev this is a public view function that will generate gross environment score from a nations soldier to population ratio\n    ///@notice this function will return gross environment points from a nations soldier to population ratio\n    ///@notice a soldier to population ratio greater than 60% will result in an environmental penalty\n    ///@param id this is the nation ID of the nation being queried\n    ///@return int256 is the gross environment points from a nations soldier to population ratio   \n    function getEnvironmentScoreFromMilitaryDensity(uint256 id)\n        public\n        view\n        returns (int256)\n    {\n        int256 pointsFromMilitaryRatiio;\n        ( , bool environmentPenalty, ) = addTax.soldierToPopulationRatio(id);\n        if (environmentPenalty) {\n            pointsFromMilitaryRatiio += 10;\n        }\n        return pointsFromMilitaryRatiio;\n    }\n\n    ///@dev this is a public view function that will generate gross environment score from a nations infrastructure to land ratio\n    ///@notice this function will return gross environment points from a nations infrastructure to land ratio\n    ///@notice a infrastructure to land ratio greater than 2:1 will result in an environmental penalty\n    ///@param id this is the nation ID of the nation being queried\n    ///@return int256 is the gross environment points from a nations infrastructure to land ratio  \n    function getEnvironmentScoreFromInfrastructure(uint256 id)\n        public\n        view\n        returns (int256)\n    {\n        int256 pointsFromInfrastructure;\n        uint256 area = inf.getAreaOfInfluence(id);\n        uint256 infra = inf.getInfrastructureCount(id);\n        if ((infra / 2) >= area) {\n            pointsFromInfrastructure += 10;\n        }\n        return pointsFromInfrastructure;\n    }\n\n    ///@dev this is a public view function that will generate gross environment score from a nations nuke count\n    ///@notice this function will return gross environment points from a nations nuke count\n    ///@notice a nations environment score will go up 1 point every ten nukes owned\n    ///@param id this is the nation ID of the nation being queried\n    ///@return int256 is the gross environment points from a nations nuke count\n    function getScoreFromNukes(uint256 id) public view returns (int256) {\n        int256 pointsFromNukes;\n        uint256 nukeCount = mis.getNukeCount(id);\n        if (nukeCount > 0) {\n            pointsFromNukes = (int256(nukeCount));\n        }\n        bool isLead = res.viewLead(id);\n        if (isLead) {\n            pointsFromNukes = (pointsFromNukes / 2);\n        }\n        return pointsFromNukes;\n    }\n\n    ///@dev this is a public view function that will generate gross environment score from a nations government type\n    ///@notice this function will return gross environment points from a nations government type\n    ///@notice a nations environment score will go up 10 points for anarchy, communist, dictatorship, and transitional gov types\n    ///@notice a nations environment score will go down 10 points for capitalist, democracy, and republic gov types\n    ///@param id this is the nation ID of the nation being queried\n    ///@return int256 is the gross environment points from a nations government\n    function getScoreFromGovernment(uint256 id) public view returns (int256) {\n        int256 pointsFromGovernmentType = 0;\n        uint256 governmentType = param.getGovernmentType(id);\n        if (\n            //anarchy\n            governmentType == 0 ||\n            //communist            \n            governmentType == 2 ||\n            //dictatorship\n            governmentType == 4 ||\n            //transitional\n            governmentType == 10\n        ) {\n            pointsFromGovernmentType += 10;\n        } else if (\n            //capitalist\n            governmentType == 1 ||\n            //democracy            \n            governmentType == 3 ||\n            //republic\n            governmentType == 7\n        ) {\n            pointsFromGovernmentType -= 10;\n        }\n        return pointsFromGovernmentType;\n    }\n}\n"
    },
    "contracts/Fighters.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./Treasury.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./Bombers.sol\";\nimport \"./Resources.sol\";\nimport \"./Improvements.sol\";\nimport \"./Wonders.sol\";\nimport \"./Navy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n///@title FightersContract\n///@author OxSnosh\n///@notice this contract will store data for the figher aircraft owned by a nation\ncontract FightersContract is Ownable {\n    address public countryMinter;\n    address public fightersMarket1;\n    address public fightersMarket2;\n    address public bombers;\n    address public treasuryAddress;\n    address public infrastructure;\n    address public war;\n    address public resources;\n    address public improvements1;\n    address public airBattle;\n    address public wonders1;\n    address public losses;\n    address public navy;\n\n    CountryMinter mint;\n    ResourcesContract res;\n    ImprovementsContract1 imp1;\n    WondersContract1 won1;\n    NavyContract nav;\n    BombersContract bomb;\n\n    struct Fighters {\n        uint256 yak9Count;\n        uint256 p51MustangCount;\n        uint256 f86SabreCount;\n        uint256 mig15Count;\n        uint256 f100SuperSabreCount;\n        uint256 f35LightningCount;\n        uint256 f15EagleCount;\n        uint256 su30MkiCount;\n        uint256 f22RaptorCount;\n    }\n\n    event Yak9Purchased(uint256 indexed id, uint256 indexed amount);\n    event P51MustangPurchased(uint256 indexed id, uint256 indexed amount);\n    event F86SabrePurchased(uint256 indexed id, uint256 indexed amount);\n    event Mig15Purchased(uint256 indexed id, uint256 indexed amount);\n    event F100SuperSabrePurchased(uint256 indexed id, uint256 indexed amount);\n    event F35LightningPurchased(uint256 indexed id, uint256 indexed amount);\n    event F15EaglePurchased(uint256 indexed id, uint256 indexed amount);\n    event Su30MkiPurchased(uint256 indexed id, uint256 indexed amount);\n    event F22RaptorPurchased(uint256 indexed id, uint256 indexed amount);\n\n    event Yak9Scrapped(uint256 indexed id, uint256 indexed amount);\n    event P51MustangScrapped(uint256 indexed id, uint256 indexed amount);\n    event F86SabreScrapped(uint256 indexed id, uint256 indexed amount);\n    event Mig15Scrapped(uint256 indexed id, uint256 indexed amount);\n    event F100SuperSabreScrapped(uint256 indexed id, uint256 indexed amount);\n    event F35LightningScrapped(uint256 indexed id, uint256 indexed amount);\n    event F15EagleScrapped(uint256 indexed id, uint256 indexed amount);\n    event Su30MkiScrapped(uint256 indexed id, uint256 indexed amount);\n    event F22RaptorScrapped(uint256 indexed id, uint256 indexed amount);\n\n    mapping(uint256 => Fighters) public idToFighters;\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _countryMinter,\n        address _fightersMarket1,\n        address _fightersMarket2,\n        address _treasuryAddress,\n        address _war,\n        address _infrastructure,\n        address _resources,\n        address _improvements1,\n        address _airBattle,\n        address _wonders1,\n        address _losses\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        improvements1 = _improvements1;\n        imp1 = ImprovementsContract1(_improvements1);\n        fightersMarket1 = _fightersMarket1;\n        fightersMarket2 = _fightersMarket2;\n        treasuryAddress = _treasuryAddress;\n        war = _war;\n        infrastructure = _infrastructure;\n        airBattle = _airBattle;\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        losses = _losses;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings2(address _navy, address _bombers) public onlyOwner {\n        navy = _navy;\n        nav = NavyContract(_navy);\n        bombers = _bombers;\n        bomb = BombersContract(_bombers);\n    }\n\n    modifier onlyCountryMinter() {\n        require(msg.sender == countryMinter, \"only countryMinter can call\");\n        _;\n    }\n\n    modifier onlyMarket() {\n        require(\n            msg.sender == fightersMarket1 || msg.sender == fightersMarket2,\n            \"this function can only be called by market\"\n        );\n        _;\n    }\n\n    modifier onlyLossesContract() {\n        require(msg.sender == losses, \"only callable from losses contract\");\n        _;\n    }\n    \n    ///@dev this function is a public function but only callable from the country minter contact when a country is minted\n    ///@notice this function allows a nation to purchase fighter aircraft once a country is minted\n    ///@param id this is the nation ID of the nation being minted\n    function generateFighters(uint256 id) public onlyCountryMinter {\n        Fighters memory newFighters = Fighters(0, 0, 0, 0, 0, 0, 0, 0, 0);\n        idToFighters[id] = newFighters;\n    }\n\n    ///@notice this function will return the amount of defending Yak9's of a nation\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending Yak9 aircraft for the nation\n    function getYak9Count(uint256 id) public view returns (uint256) {\n        uint256 count = idToFighters[id].yak9Count;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Fighter Market contracts\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseYak9Count(uint256 id, uint256 amount) public onlyMarket {\n        idToFighters[id].yak9Count += amount;\n        emit Yak9Purchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the losses contract\n    ///@notice this function will decrease the amount of defending aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseYak9Count(\n        uint256 amount,\n        uint256 id\n    ) public onlyLossesContract {\n        uint256 currentAmount = idToFighters[id].yak9Count;\n        if (currentAmount >= amount) {\n            idToFighters[id].yak9Count -= amount;\n        } else {\n            idToFighters[id].yak9Count = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission Yak9's\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapYak9(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToFighters[id].yak9Count;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToFighters[id].yak9Count -= amount;\n        emit Yak9Scrapped(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending P51 Mustangs's of a nation\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending P51 Mustang aircraft for the nation\n    function getP51MustangCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToFighters[id].p51MustangCount;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Fighter Market contracts\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseP51MustangCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToFighters[id].p51MustangCount += amount;\n        emit P51MustangPurchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the losses contract\n    ///@notice this function will decrease the amount of defending aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseP51MustangCount(\n        uint256 amount,\n        uint256 id\n    ) public onlyLossesContract {\n        uint256 currentAmount = idToFighters[id].p51MustangCount;\n        if (currentAmount >= amount) {\n            idToFighters[id].p51MustangCount -= amount;\n        } else {\n            idToFighters[id].p51MustangCount = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission P51 Mustangs's\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapP51Mustang(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToFighters[id].p51MustangCount;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToFighters[id].p51MustangCount -= amount;\n        emit P51MustangScrapped(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending F86 Sabre's of a nation\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending F86 Sabre aircraft for the nation\n    function getF86SabreCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToFighters[id].f86SabreCount;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Fighter Market contracts\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseF86SabreCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToFighters[id].f86SabreCount += amount;\n        emit F86SabrePurchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the losses contract\n    ///@notice this function will decrease the amount of defending aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseF86SabreCount(\n        uint256 amount,\n        uint256 id\n    ) public onlyLossesContract {\n        uint256 currentAmount = idToFighters[id].f86SabreCount;\n        if (currentAmount >= amount) {\n            idToFighters[id].f86SabreCount -= amount;\n        } else {\n            idToFighters[id].f86SabreCount = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission F86 Sabre's\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapF86Sabre(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToFighters[id].f86SabreCount;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToFighters[id].f86SabreCount -= amount;\n        emit F86SabreScrapped(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending Mig15's of a nation\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending Mig15's aircraft for the nation\n    function getMig15Count(uint256 id) public view returns (uint256) {\n        uint256 count = idToFighters[id].mig15Count;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Fighter Market contracts\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseMig15Count(uint256 id, uint256 amount) public onlyMarket {\n        idToFighters[id].mig15Count += amount;\n        emit Mig15Purchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the losses contract\n    ///@notice this function will decrease the amount of defending aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseMig15Count(\n        uint256 amount,\n        uint256 id\n    ) public onlyLossesContract {\n        uint256 currentAmount = idToFighters[id].mig15Count;\n        if (currentAmount >= amount) {\n            idToFighters[id].mig15Count -= amount;\n        } else {\n            idToFighters[id].mig15Count = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission Mig15's\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapMig15(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToFighters[id].mig15Count;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToFighters[id].mig15Count -= amount;\n        emit Mig15Scrapped(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending F100 Super Sabre's of a nation\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending F100 Super Sabre aircraft for the nation\n    function getF100SuperSabreCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToFighters[id].f100SuperSabreCount;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Fighter Market contracts\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseF100SuperSabreCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToFighters[id].f100SuperSabreCount += amount;\n        emit F100SuperSabrePurchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the losses contract\n    ///@notice this function will decrease the amount of defending aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseF100SuperSabreCount(\n        uint256 amount,\n        uint256 id\n    ) public onlyLossesContract {\n        uint256 currentAmount = idToFighters[id].f100SuperSabreCount;\n        if (currentAmount >= amount) {\n            idToFighters[id].f100SuperSabreCount -= amount;\n        } else {\n            idToFighters[id].f100SuperSabreCount = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission F100 Super Sabre's\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapF100SuperSabre(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToFighters[id].f100SuperSabreCount;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToFighters[id].f100SuperSabreCount -= amount;\n        emit F100SuperSabreScrapped(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending F35 Lightning's of a nation\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending F35 Lightning aircraft for the nation\n    function getF35LightningCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToFighters[id].f35LightningCount;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Fighter Market contracts\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseF35LightningCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToFighters[id].f35LightningCount += amount;\n        emit F35LightningPurchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the losses contract\n    ///@notice this function will decrease the amount of defending aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseF35LightningCount(\n        uint256 amount,\n        uint256 id\n    ) public onlyLossesContract {\n        uint256 currentAmount = idToFighters[id].f35LightningCount;\n        if (currentAmount >= amount) {\n            idToFighters[id].f35LightningCount -= amount;\n        } else {\n            idToFighters[id].f35LightningCount = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission F35's\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapF35Lightning(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToFighters[id].f35LightningCount;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToFighters[id].f35LightningCount -= amount;\n        emit F35LightningScrapped(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending F15 Eagle's of a nation\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending F15 Eagle aircraft for the nation\n    function getF15EagleCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToFighters[id].f15EagleCount;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Fighter Market contracts\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseF15EagleCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToFighters[id].f15EagleCount += amount;\n        emit F15EaglePurchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the losses contract\n    ///@notice this function will decrease the amount of defending aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseF15EagleCount(\n        uint256 amount,\n        uint256 id\n    ) public onlyLossesContract {\n        uint256 currentAmount = idToFighters[id].f15EagleCount;\n        if (currentAmount >= amount) {\n            idToFighters[id].f15EagleCount -= amount;\n        } else {\n            idToFighters[id].f15EagleCount = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission F15's\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapF15Eagle(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToFighters[id].f15EagleCount;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToFighters[id].f15EagleCount -= amount;\n        emit F15EagleScrapped(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending Su30 Mki's of a nation\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending Su30 Mki aircraft for the nation\n    function getSu30MkiCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToFighters[id].su30MkiCount;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Fighter Market contracts\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseSu30MkiCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToFighters[id].su30MkiCount += amount;\n        emit Su30MkiPurchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the losses contract\n    ///@notice this function will decrease the amount of defending aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseSu30MkiCount(\n        uint256 amount,\n        uint256 id\n    ) public onlyLossesContract {\n        uint256 currentAmount = idToFighters[id].su30MkiCount;\n        if (currentAmount >= amount) {\n            idToFighters[id].su30MkiCount -= amount;\n        } else {\n            idToFighters[id].su30MkiCount = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission Su30's\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapSu30Mki(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToFighters[id].su30MkiCount;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToFighters[id].su30MkiCount -= amount;\n        emit Su30MkiScrapped(id, amount);\n    }\n\n    ///@notice this function will return the amount of defending F22 Raptor's of a nation\n    ///@param id is the nation ID of the nation\n    ///@return uint256 is the number of defending F22 Raptor aircraft for the nation\n    function getF22RaptorCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToFighters[id].f22RaptorCount;\n        return count;\n    }\n\n    ///@dev this function is only callabel from the Fighter Market contracts\n    ///@notice this function will increase the number of aircraft when they are purchased in the marketplace\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being purchased\n    function increaseF22RaptorCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyMarket {\n        idToFighters[id].f22RaptorCount += amount;\n        emit F22RaptorPurchased(id, amount);\n    }\n\n    ///@dev this function is only callable from the losses contract\n    ///@notice this function will decrease the amount of defending aircraft lost in a battle\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function decreaseF22RaptorCount(\n        uint256 amount,\n        uint256 id\n    ) public onlyLossesContract {\n        uint256 currentAmount = idToFighters[id].f22RaptorCount;\n        if (currentAmount >= amount) {\n            idToFighters[id].f22RaptorCount -= amount;\n        } else {\n            idToFighters[id].f22RaptorCount = 0;\n        }\n    }\n\n    ///@notice this function will allow a nation owner to decommission F22's\n    ///@param id is the nation ID of the nation\n    ///@param amount is the amount of aircraft being destroyed\n    function scrapF22Raptor(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 currentAmount = idToFighters[id].f22RaptorCount;\n        require(currentAmount >= amount, \"cannot delete that many\");\n        idToFighters[id].f22RaptorCount -= amount;\n        emit F22RaptorScrapped(id, amount);\n    }\n\n    function getFighterCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToFighters[id].yak9Count +\n            idToFighters[id].p51MustangCount +\n            idToFighters[id].f86SabreCount +\n            idToFighters[id].mig15Count +\n            idToFighters[id].f100SuperSabreCount +\n            idToFighters[id].f35LightningCount +\n            idToFighters[id].f15EagleCount +\n            idToFighters[id].su30MkiCount +\n            idToFighters[id].f22RaptorCount;\n        return count;\n    }\n\n    function getAircraftCount(uint256 id) public view returns (uint256) {\n        uint256 bomberCount = bomb.getBomberCount(id);\n        uint256 fighterCount = getFighterCount(id);\n        uint256 total = bomberCount + fighterCount;\n        return total;\n    }\n}\n\n///@title FighterLosses\n///@author OxSnosh\n///@notice this contract will decrease the amount of fighters lost in battle\ncontract FighterLosses is Ownable {\n    address public fighters;\n    address public airBattle;\n\n    FightersContract fight;\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(address _fighters, address _airBattle) public onlyOwner {\n        fighters = _fighters;\n        fight = FightersContract(_fighters);\n        airBattle = _airBattle;\n    }\n\n    modifier onlyAirBattle() {\n        require(\n            msg.sender == airBattle,\n            \"this function can only be called by air battle\"\n        );\n        _;\n    }\n\n    ///@dev this is a public function that is only callable from the Air Battle contract\n    ///@notice this function will decrease the amount of fighers lost in battle from the FighersContract\n    ///@param losses is an array of uints that represent the fighters that the defender lost in battle\n    ///@param id is the nation ID of the defender\n    function decrementLosses(\n        uint256[] memory losses,\n        uint256 id\n    ) public onlyAirBattle {\n        for (uint256 i; i < losses.length; i++) {\n            if (losses[i] == 1) {\n                fight.decreaseYak9Count(1, id);\n            } else if (losses[i] == 2) {\n                fight.decreaseP51MustangCount(1, id);\n            } else if (losses[i] == 3) {\n                fight.decreaseF86SabreCount(1, id);\n            } else if (losses[i] == 4) {\n                fight.decreaseMig15Count(1, id);\n            } else if (losses[i] == 5) {\n                fight.decreaseF100SuperSabreCount(1, id);\n            } else if (losses[i] == 6) {\n                fight.decreaseF35LightningCount(1, id);\n            } else if (losses[i] == 7) {\n                fight.decreaseF15EagleCount(1, id);\n            } else if (losses[i] == 8) {\n                fight.decreaseSu30MkiCount(1, id);\n            } else if (losses[i] == 9) {\n                fight.decreaseF22RaptorCount(1, id);\n            }\n        }\n    }\n}\n\n///@title FightersMarketplace1\n///@author OxSnosh\n///@dev this contact inherits from openzeppelin's ownable contract\n///@notice this contract will allow the nation owner to buy Yak9s, P51 Mustangs, F86 Sabres, Mig15s, and F100's\ncontract FightersMarketplace1 is Ownable {\n    address public countryMinter;\n    address public fighters;\n    address public bombers;\n    address public treasury;\n    address public infrastructure;\n    address public resources;\n    address public improvements1;\n    address public wonders1;\n    address public wonders4;\n    address public navy;\n    address public bonusResources;\n    address public navy2;\n    uint256 public yak9Cost = 10000 * (10 ** 18);\n    uint256 public yak9RequiredInfrastructure = 100;\n    uint256 public yak9RequiredTech = 30;\n    uint256 public p51MustangCost = 15000 * (10 ** 18);\n    uint256 public p51MustangRequiredInfrastructure = 200;\n    uint256 public p51MustangRequiredTech = 65;\n    uint256 public f86SabreCost = 20000 * (10 ** 18);\n    uint256 public f86SabreRequiredInfrastructure = 300;\n    uint256 public f86SabreRequiredTech = 105;\n    uint256 public mig15Cost = 25000 * (10 ** 18);\n    uint256 public mig15RequiredInfrastructure = 400;\n    uint256 public mig15RequiredTech = 150;\n    uint256 public f100SuperSabreCost = 30000 * (10 ** 18);\n    uint256 public f100SuperSabreRequiredInfrastructure = 500;\n    uint256 public f100SuperSabreRequiredTech = 200;\n\n    CountryMinter mint;\n    BombersContract bomb;\n    ResourcesContract res;\n    ImprovementsContract1 imp1;\n    WondersContract1 won1;\n    WondersContract4 won4;\n    FightersContract fight;\n    NavyContract nav;\n    BonusResourcesContract bonus;\n    NavyContract2 nav2;\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _countryMinter,\n        address _bombers,\n        address _fighters,\n        address _treasury,\n        address _infrastructure,\n        address _resources,\n        address _improvements1,\n        address _wonders1,\n        address _wonders4,\n        address _navy\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        bombers = _bombers;\n        bomb = BombersContract(_bombers);\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        improvements1 = _improvements1;\n        imp1 = ImprovementsContract1(_improvements1);\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        wonders4 = _wonders4;\n        won4 = WondersContract4(_wonders4);\n        treasury = _treasury;\n        fighters = _fighters;\n        fight = FightersContract(_fighters);\n        infrastructure = _infrastructure;\n        navy = _navy;\n        nav = NavyContract(_navy);\n    }\n\n    function settings2(\n        address _bonusResources,\n        address _navy2\n    ) public onlyOwner {\n        bonusResources = _bonusResources;\n        bonus = BonusResourcesContract(_bonusResources);\n        navy2 = _navy2;\n        nav2 = NavyContract2(_navy2);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be user to update the price, infrastructure requirement and tech requirement in order to purchase a Yak9\n    function updateYak9Specs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        yak9Cost = newPrice;\n        yak9RequiredInfrastructure = newInfra;\n        yak9RequiredTech = newTech;\n    }\n\n    function getYak9Specs() public view returns (uint256, uint256, uint256) {\n        return (yak9Cost, yak9RequiredInfrastructure, yak9RequiredTech);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be user to update the price, infrastructure requirement and tech requirement in order to purchase a P51 Mustang\n    function updateP51MustangSpecs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        p51MustangCost = newPrice;\n        p51MustangRequiredInfrastructure = newInfra;\n        p51MustangRequiredTech = newTech;\n    }\n\n    function getP51MustangSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            p51MustangCost,\n            p51MustangRequiredInfrastructure,\n            p51MustangRequiredTech\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be user to update the price, infrastructure requirement and tech requirement in order to purchase a F86 Sabre\n    function updateF86SabreSpecs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        f86SabreCost = newPrice;\n        f86SabreRequiredInfrastructure = newInfra;\n        f86SabreRequiredTech = newTech;\n    }\n\n    function getF86SabreSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            f86SabreCost,\n            f86SabreRequiredInfrastructure,\n            f86SabreRequiredTech\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be user to update the price, infrastructure requirement and tech requirement in order to purchase a Mig15\n    function updateMig15Specs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        mig15Cost = newPrice;\n        mig15RequiredInfrastructure = newInfra;\n        mig15RequiredTech = newTech;\n    }\n\n    function getMig15Specs() public view returns (uint256, uint256, uint256) {\n        return (mig15Cost, mig15RequiredInfrastructure, mig15RequiredTech);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be user to update the price, infrastructure requirement and tech requirement in order to purchase a F100 Super Sabre\n    function updateF100SuperSabreSpecs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        f100SuperSabreCost = newPrice;\n        f100SuperSabreRequiredInfrastructure = newInfra;\n        f100SuperSabreRequiredTech = newTech;\n    }\n\n    function getF100SuperSabreSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            f100SuperSabreCost,\n            f100SuperSabreRequiredInfrastructure,\n            f100SuperSabreRequiredTech\n        );\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a Yak9 for their nation\n    ///@notice this function allowes the caller to purchase a Yak9 for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyYak9(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = InfrastructureContract(infrastructure)\n            .getInfrastructureCount(id);\n        require(\n            callerInfra >= yak9RequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = InfrastructureContract(infrastructure)\n            .getTechnologyCount(id);\n        require(callerTech >= yak9RequiredTech, \"!enough tech\");\n        uint256 cost = getYak9Cost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = TreasuryContract(treasury).checkBalance(id);\n        require(balance >= purchasePrice, \"insufficient money to buy aircraft\");\n        FightersContract(fighters).increaseYak9Count(id, amount);\n        TreasuryContract(treasury).spendBalance(id, purchasePrice);\n    }\n\n    function getYak9Cost(uint256 id) public view returns (uint256) {\n        uint256 mod = getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((yak9Cost * mod) / 100);\n        return cost;\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a P51 for their nation\n    ///@notice this function allowes the caller to purchase a P51 for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyP51Mustang(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = InfrastructureContract(infrastructure)\n            .getInfrastructureCount(id);\n        require(\n            callerInfra >= p51MustangRequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = InfrastructureContract(infrastructure)\n            .getTechnologyCount(id);\n        require(callerTech >= p51MustangRequiredTech, \"!enough tech\");\n        uint256 cost = getP51MustangCost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = TreasuryContract(treasury).checkBalance(id);\n        require(balance >= purchasePrice);\n        FightersContract(fighters).increaseP51MustangCount(id, amount);\n        TreasuryContract(treasury).spendBalance(id, purchasePrice);\n    }\n\n    function getP51MustangCost(uint256 id) public view returns (uint256) {\n        uint256 mod = getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((p51MustangCost * mod) / 100);\n        return cost;\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a F86 for their nation\n    ///@notice this function allowes the caller to purchase a F86 for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyF86Sabre(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = InfrastructureContract(infrastructure)\n            .getInfrastructureCount(id);\n        require(\n            callerInfra >= f86SabreRequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = InfrastructureContract(infrastructure)\n            .getTechnologyCount(id);\n        require(callerTech >= f86SabreRequiredTech, \"!enough tech\");\n        uint256 cost = getF86SabreCost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = TreasuryContract(treasury).checkBalance(id);\n        require(balance >= purchasePrice);\n        FightersContract(fighters).increaseF86SabreCount(id, amount);\n        TreasuryContract(treasury).spendBalance(id, purchasePrice);\n    }\n\n    function getF86SabreCost(uint256 id) public view returns (uint256) {\n        uint256 mod = getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((f86SabreCost * mod) / 100);\n        return cost;\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a Mig15 for their nation\n    ///@notice this function allowes the caller to purchase a Mig15 for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyMig15(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = InfrastructureContract(infrastructure)\n            .getInfrastructureCount(id);\n        require(\n            callerInfra >= mig15RequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = InfrastructureContract(infrastructure)\n            .getTechnologyCount(id);\n        require(callerTech >= mig15RequiredTech, \"!enough tech\");\n        uint256 cost = getMig15Cost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = TreasuryContract(treasury).checkBalance(id);\n        require(balance >= purchasePrice);\n        FightersContract(fighters).increaseMig15Count(id, amount);\n        TreasuryContract(treasury).spendBalance(id, purchasePrice);\n    }\n\n    function getMig15Cost(uint256 id) public view returns (uint256) {\n        uint256 mod = getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((mig15Cost * mod) / 100);\n        return cost;\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a F100 Super Sabre for their nation\n    ///@notice this function allowes the caller to purchase a F100 Super Sabre for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyF100SuperSabre(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = InfrastructureContract(infrastructure)\n            .getInfrastructureCount(id);\n        require(\n            callerInfra >= f100SuperSabreRequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = InfrastructureContract(infrastructure)\n            .getTechnologyCount(id);\n        require(callerTech >= f100SuperSabreRequiredTech, \"!enough tech\");\n        uint256 cost = getF100SuperSabreCost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = TreasuryContract(treasury).checkBalance(id);\n        require(balance >= purchasePrice);\n        FightersContract(fighters).increaseF100SuperSabreCount(id, amount);\n        TreasuryContract(treasury).spendBalance(id, purchasePrice);\n    }\n\n    function getF100SuperSabreCost(uint256 id) public view returns (uint256) {\n        uint256 mod = getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((f100SuperSabreCost * mod) / 100);\n        return cost;\n    }\n\n    ///@dev this is public view function that will adjust the cost of the aircraft being purchased based on resources, improvements and wonders of that nation\n    ///@notice this function will adjust the cost of aircraft based on resources, improvements and wonders\n    ///@notice aluminium, oil, rubber, airports and space programs decrease the cost of aircraft\n    ///@param id is the nation ID of the nation being queried\n    ///@return uint256 is the percentage modifier used to adjust the aircraft purchase price\n    function getAircraftPurchaseCostModifier(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 aircraftPurchaseModifier = 100;\n        bool aluminium = res.viewAluminium(id);\n        if (aluminium) {\n            aircraftPurchaseModifier -= 8;\n        }\n        bool oil = res.viewOil(id);\n        if (oil) {\n            aircraftPurchaseModifier -= 4;\n        }\n        bool rubber = res.viewRubber(id);\n        if (rubber) {\n            aircraftPurchaseModifier -= 4;\n        }\n        uint256 airports = imp1.getAirportCount(id);\n        if (airports > 0) {\n            aircraftPurchaseModifier -= (2 * airports);\n        }\n        bool spaceProgram = won4.getSpaceProgram(id);\n        if (spaceProgram) {\n            aircraftPurchaseModifier -= 5;\n        }\n        return aircraftPurchaseModifier;\n    }\n\n    ///@dev this a public view function that will return the maximum amonut of aircraft a nation can own\n    ///@notice this is a function that will return the maximum amount of aircraft a nation can own\n    ///@notice the base amount of aircraft a nation can own is 50\n    ///@notice access to the construction resource will increase the amount of aircraft a nation can own by 10\n    ///@notice a foreign air force base will increase the maximum amount of aircraft for a nation by 20\n    ///@notice the maxmimum aircraft a nation can own will increase by 5 for each aircraft carrier owned\n    ///@param id is the nation ID of the nation being queried\n    ///@return uint256 is the maximum amount of aircraft a nation can own\n    function getMaxAircraftCount(uint256 id) public view returns (uint256) {\n        uint256 maxAircraftCount = 50;\n        bool construction = bonus.viewConstruction(id);\n        if (construction) {\n            maxAircraftCount += 10;\n        }\n        bool foreignAirForceBase = won1.getForeignAirforceBase(id);\n        if (foreignAirForceBase) {\n            maxAircraftCount += 20;\n        }\n        uint256 aircraftCarrierCount = nav2.getAircraftCarrierCount(id);\n        if (aircraftCarrierCount > 5) {\n            aircraftCarrierCount = 5;\n        }\n        if (aircraftCarrierCount > 0) {\n            maxAircraftCount += (aircraftCarrierCount * 5);\n        }\n        return maxAircraftCount;\n    }\n}\n\n///@title FightersMarketplace2\n///@author OxSnosh\n///@notice this contract allows a nation owner to purchase F35's, F15's, SU30's and F22's\n///@dev this contact inherits from owpenzeppelin's ownable contact\ncontract FightersMarketplace2 is Ownable {\n    address public countryMinter;\n    address public fighters;\n    address public fightersMarket1;\n    address public bombers;\n    address public treasury;\n    address public infrastructure;\n    address public resources;\n    address public improvements1;\n    uint256 public f35LightningCost = 35000 * (10 ** 18);\n    uint256 public f35LightningRequiredInfrastructure = 600;\n    uint256 public f35LightningRequiredTech = 255;\n    uint256 public f15EagleCost = 40000 * (10 ** 18);\n    uint256 public f15EagleRequiredInfrastructure = 700;\n    uint256 public f15EagleRequiredTech = 315;\n    uint256 public su30MkiCost = 45000 * (10 ** 18);\n    uint256 public su30MkiRequiredInfrastructure = 850;\n    uint256 public su30MkiRequiredTech = 405;\n    uint256 public f22RaptorCost = 50000 * (10 ** 18);\n    uint256 public f22RaptorRequiredInfrastructure = 1000;\n    uint256 public f22RaptorRequiredTech = 500;\n\n    CountryMinter mint;\n    BombersContract bomb;\n    ResourcesContract res;\n    ImprovementsContract1 imp1;\n    FightersContract fight;\n    FightersMarketplace1 fightMarket1;\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _countryMinter,\n        address _bombers,\n        address _fighters,\n        address _fightersMarket1,\n        address _treasury,\n        address _infrastructure,\n        address _resources,\n        address _improvements1\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        bombers = _bombers;\n        bomb = BombersContract(_bombers);\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        improvements1 = _improvements1;\n        imp1 = ImprovementsContract1(_improvements1);\n        treasury = _treasury;\n        fighters = _fighters;\n        fight = FightersContract(_fighters);\n        fightersMarket1 = _fightersMarket1;\n        fightMarket1 = FightersMarketplace1(_fightersMarket1);\n        infrastructure = _infrastructure;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be user to update the price, infrastructure requirement and tech requirement in order to purchase a F35 Lightning\n    function updateF35LightningSpecs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        f35LightningCost = newPrice;\n        f35LightningRequiredInfrastructure = newInfra;\n        f35LightningRequiredTech = newTech;\n    }\n\n    function getF35LightningSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            f35LightningCost,\n            f35LightningRequiredInfrastructure,\n            f35LightningRequiredTech\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be user to update the price, infrastructure requirement and tech requirement in order to purchase a F15 Eagle\n    function updateF15EagleSpecs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        f15EagleCost = newPrice;\n        f15EagleRequiredInfrastructure = newInfra;\n        f15EagleRequiredTech = newTech;\n    }\n\n    function getF15EagleSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            f15EagleCost,\n            f15EagleRequiredInfrastructure,\n            f15EagleRequiredTech\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be user to update the price, infrastructure requirement and tech requirement in order to purchase a SU30 Mki\n    function updateSU30MkiSpecs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        su30MkiCost = newPrice;\n        su30MkiRequiredInfrastructure = newInfra;\n        su30MkiRequiredTech = newTech;\n    }\n\n    function getSU30MkiSpecs() public view returns (uint256, uint256, uint256) {\n        return (\n            su30MkiCost,\n            su30MkiRequiredInfrastructure,\n            su30MkiRequiredTech\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be user to update the price, infrastructure requirement and tech requirement in order to purchase a F22\n    function updateF22RaptorSpecs(\n        uint256 newPrice,\n        uint256 newInfra,\n        uint256 newTech\n    ) public onlyOwner {\n        f22RaptorCost = newPrice;\n        f22RaptorRequiredInfrastructure = newInfra;\n        f22RaptorRequiredTech = newTech;\n    }\n\n    function getF22RaptorSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            f22RaptorCost,\n            f22RaptorRequiredInfrastructure,\n            f22RaptorRequiredTech\n        );\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a F35 Lightning for their nation\n    ///@notice this function allowes the caller to purchase a F35 Lightning for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyF35Lightning(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = fightMarket1.getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = InfrastructureContract(infrastructure)\n            .getInfrastructureCount(id);\n        require(\n            callerInfra >= f35LightningRequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = InfrastructureContract(infrastructure)\n            .getTechnologyCount(id);\n        require(callerTech >= f35LightningRequiredTech, \"!enough tech\");\n        uint256 cost = getF35LightningCost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = TreasuryContract(treasury).checkBalance(id);\n        require(balance >= purchasePrice);\n        FightersContract(fighters).increaseF35LightningCount(id, amount);\n        TreasuryContract(treasury).spendBalance(id, purchasePrice);\n    }\n\n    function getF35LightningCost(uint256 id) public view returns (uint256) {\n        uint256 mod = fightMarket1.getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((f35LightningCost * mod) / 100);\n        return cost;\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a F15 Eagle for their nation\n    ///@notice this function allowes the caller to purchase a F15 Eagle for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyF15Eagle(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = fightMarket1.getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = InfrastructureContract(infrastructure)\n            .getInfrastructureCount(id);\n        require(\n            callerInfra >= f15EagleRequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = InfrastructureContract(infrastructure)\n            .getTechnologyCount(id);\n        require(callerTech >= f15EagleRequiredTech, \"!enough tech\");\n        uint256 cost = getF15EagleCost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = TreasuryContract(treasury).checkBalance(id);\n        require(balance >= purchasePrice);\n        FightersContract(fighters).increaseF15EagleCount(id, amount);\n        TreasuryContract(treasury).spendBalance(id, purchasePrice);\n    }\n\n    function getF15EagleCost(uint256 id) public view returns (uint256) {\n        uint256 mod = fightMarket1.getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((f15EagleCost * mod) / 100);\n        return cost;\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a Su30 Mki for their nation\n    ///@notice this function allowes the caller to purchase a Su30 Mki for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buySu30Mki(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = fightMarket1.getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = InfrastructureContract(infrastructure)\n            .getInfrastructureCount(id);\n        require(\n            callerInfra >= su30MkiRequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = InfrastructureContract(infrastructure)\n            .getTechnologyCount(id);\n        require(callerTech >= su30MkiRequiredTech, \"!enough tech\");\n        uint256 cost = getSu30MkiCost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = TreasuryContract(treasury).checkBalance(id);\n        require(balance >= purchasePrice);\n        FightersContract(fighters).increaseSu30MkiCount(id, amount);\n        TreasuryContract(treasury).spendBalance(id, purchasePrice);\n    }\n\n    function getSu30MkiCost(uint256 id) public view returns (uint256) {\n        uint256 mod = fightMarket1.getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((su30MkiCost * mod) / 100);\n        return cost;\n    }\n\n    ///@dev this is a public view function that will allow the caller to purchase a F22 Raptor for their nation\n    ///@notice this function allowes the caller to purchase a F22 Raptor for their nation\n    ///@param amount specifies the number of aircraft being purchased\n    ///@param id is the nation ID\n    function buyF22Raptor(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation ruler\");\n        uint256 aircraftCount = fight.getAircraftCount(id);\n        uint256 maxAircraft = fightMarket1.getMaxAircraftCount(id);\n        require((aircraftCount + amount) <= maxAircraft, \"too many aircraft\");\n        uint256 callerInfra = InfrastructureContract(infrastructure)\n            .getInfrastructureCount(id);\n        require(\n            callerInfra >= f22RaptorRequiredInfrastructure,\n            \"!enough infrastructure\"\n        );\n        uint256 callerTech = InfrastructureContract(infrastructure)\n            .getTechnologyCount(id);\n        require(callerTech >= f22RaptorRequiredTech, \"!enough tech\");\n        uint256 cost = getF22RaptorCost(id);\n        uint256 purchasePrice = (cost * amount);\n        uint256 balance = TreasuryContract(treasury).checkBalance(id);\n        require(balance >= purchasePrice);\n        FightersContract(fighters).increaseF22RaptorCount(id, amount);\n        TreasuryContract(treasury).spendBalance(id, purchasePrice);\n    }\n\n    function getF22RaptorCost(uint256 id) public view returns (uint256) {\n        uint256 mod = fightMarket1.getAircraftPurchaseCostModifier(id);\n        uint256 cost = ((f22RaptorCost * mod) / 100);\n        return cost;\n    }\n}\n"
    },
    "contracts/Forces.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./CountryMinter.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Resources.sol\";\nimport \"./Wonders.sol\";\nimport \"./Improvements.sol\";\nimport \"./War.sol\";\nimport \"./GroundBattle.sol\";\nimport \"./CountryParameters.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"hardhat/console.sol\";\n\n///@title ForcesContract\n///@author OxSnosh\n///@dev this contract inherits from the openzeppelin Ownable contract\n///@notice this contract allows a nation owner to purchase soldiers, tanks and spies\ncontract ForcesContract is Ownable {\n    // uint256 public spyCost = 100000;\n    address public countryMinter;\n    address public treasuryAddress;\n    address public aid;\n    address public spyAddress;\n    address public cruiseMissile;\n    address public infrastructure;\n    address public resources;\n    address public improvements1;\n    address public improvements2;\n    address public wonders1;\n    address public nukeAddress;\n    address public airBattle;\n    address public groundBattle;\n    address public warAddress;\n    address public keeper;\n    address public parameters;\n\n    CountryMinter mint;\n    InfrastructureContract inf;\n    ResourcesContract res;\n    WondersContract1 won1;\n    ImprovementsContract1 imp1;\n    ImprovementsContract2 imp2;\n    WarContract war;\n    GroundBattleContract ground;\n    CountryParametersContract params;\n\n    struct Forces {\n        uint256 numberOfSoldiers;\n        uint256 defendingSoldiers;\n        uint256 deployedSoldiers;\n        uint256 numberOfTanks;\n        uint256 defendingTanks;\n        uint256 deployedTanks;\n        bool nationExists;\n    }\n\n    struct GroundBattleCasualties {\n        uint256 soldierCasualties;\n        uint256 tankCasualties;\n    }\n\n    event SoldiersPurchased(uint256 indexed id, uint256 indexed amount);\n\n    event SoldiersDecommissioned(uint256 indexed id, uint256 indexed amount);\n\n    event TanksPurchased(uint256 indexed id, uint256 indexed amount);\n\n    event TanksDecommissioned(uint256 indexed id, uint256 indexed amount);\n\n    event ForcesDeployed(\n        uint256 indexed id,\n        uint256 indexed soldiers,\n        uint256 indexed tanks,\n        uint256 warId\n    );\n\n    event SoldierDamageFromNukeAttack(\n        uint256 indexed id,\n        uint256 indexed amount\n    );\n\n    event TankDamageFromAirAssault(uint256 indexed id, uint256 indexed amount);\n\n    event TankDamageFromCruiseMissile(\n        uint256 indexed id,\n        uint256 indexed amount\n    );\n\n    event TankDamageFromNukeAttack(uint256 indexed id, uint256 indexed amount);\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _treasuryAddress,\n        address _aid,\n        address _spyAddress,\n        address _cruiseMissile,\n        address _nukeAddress,\n        address _airBattle,\n        address _groundBattle,\n        address _warAddress\n    ) public onlyOwner {\n        treasuryAddress = _treasuryAddress;\n        spyAddress = _spyAddress;\n        cruiseMissile = _cruiseMissile;\n        aid = _aid;\n        nukeAddress = _nukeAddress;\n        airBattle = _airBattle;\n        warAddress = _warAddress;\n        war = WarContract(_warAddress);\n        groundBattle = _groundBattle;\n        ground = GroundBattleContract(_groundBattle);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings2(\n        address _infrastructure,\n        address _resources,\n        address _improvements1,\n        address _improvements2,\n        address _wonders1,\n        address _countryMinter,\n        address _keeper,\n        address _parameters\n    ) public onlyOwner {\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        improvements1 = _improvements1;\n        imp1 = ImprovementsContract1(_improvements1);\n        improvements2 = _improvements2;\n        imp2 = ImprovementsContract2(_improvements2);\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        keeper = _keeper;\n        parameters = _parameters;\n        params = CountryParametersContract(_parameters);\n    }\n\n    mapping(uint256 => Forces) public idToForces;\n    mapping(uint256 => GroundBattleCasualties) public idToCasualties;\n\n    ///@dev this function is a public function but only callable from the country minter contact when a country is minted\n    ///@notice this function allows a nation to purchase forces once a country is minted\n    ///@param id this is the nation ID of the nation being minted\n    function generateForces(uint256 id) public {\n        Forces memory newForces = Forces(20, 20, 0, 0, 0, 0, true);\n        idToForces[id] = newForces;\n    }\n\n    modifier onlyAidContract() {\n        require(msg.sender == aid);\n        _;\n    }\n\n    modifier onlySpyContract() {\n        require(msg.sender == spyAddress, \"only callable from spy contract\");\n        _;\n    }\n\n    modifier onlyCruiseMissileContract() {\n        require(\n            msg.sender == cruiseMissile,\n            \"only callable from cruise missile contract\"\n        );\n        _;\n    }\n\n    modifier onlyNukeContract() {\n        require(msg.sender == nukeAddress, \"only callable from nuke contract\");\n        _;\n    }\n\n    modifier onlyAirBattle() {\n        require(\n            msg.sender == airBattle,\n            \"only callable from air battle contract\"\n        );\n        _;\n    }\n\n    modifier onlyGroundBattle() {\n        require(\n            msg.sender == groundBattle,\n            \"only callable from ground battle contract\"\n        );\n        _;\n    }\n\n    modifier onlyWar() {\n        require(msg.sender == warAddress, \"only callable from war contract\");\n        _;\n    }\n\n    ///@dev this is a public function that allows a nation owner to purchase soldiers\n    ///@notice this function will allow a nation owner to purchase soldiers\n    ///@param amount is the amount of soldiers being purchased\n    ///@param id is the nation id of the nation being queried\n    function buySoldiers(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 populationCount = inf.getTotalPopulationCount(id);\n        uint256 maxSoldierCount = ((populationCount * 80) / 100);\n        uint256 currentSoldierCount = idToForces[id].numberOfSoldiers;\n        require(\n            (currentSoldierCount + amount) <= maxSoldierCount,\n            \"population cannot support that many soldiers\"\n        );\n        uint256 soldierCost = getSoldierCost(id);\n        uint256 purchasePrice = soldierCost * amount;\n        uint256 balance = TreasuryContract(treasuryAddress).checkBalance(id);\n        require(\n            balance >= purchasePrice,\n            \"insufficient funds for soldier purchase\"\n        );\n        idToForces[id].numberOfSoldiers += amount;\n        idToForces[id].defendingSoldiers += amount;\n        TreasuryContract(treasuryAddress).spendBalance(id, purchasePrice);\n        emit SoldiersPurchased(id, amount);\n    }\n\n    ///@dev this is a public view function that will retrun the cost of soldiers for a nation\n    ///@notice this will return the cost of a soldier for a nation\n    ///@notice access to iron and oil resources decrease the cost of soldiers\n    ///@param id is the nation ID of the nation being queried\n    ///@return uint256 is the soldier cost for that nation\n    function getSoldierCost(uint256 id) public view returns (uint256) {\n        uint256 soldierCost = 12;\n        bool iron = res.viewIron(id);\n        if (iron) {\n            soldierCost -= 3;\n        }\n        bool oil = res.viewOil(id);\n        if (oil) {\n            soldierCost -= 3;\n        }\n        return soldierCost;\n    }\n\n    ///@dev this function is only callable from the aid contract\n    ///@notice this function will allow the aid contact to send soldiers in an aid package\n    ///@param idSender is the nation id of the aid sender\n    ///@param idReciever is the nation id of the aid reciever\n    ///@param amount is the amount of soldiers being sent\n    function sendSoldiers(\n        uint256 idSender,\n        uint256 idReciever,\n        uint256 amount\n    ) public onlyAidContract {\n        uint256 defendingSoldierCount = idToForces[idSender].defendingSoldiers;\n        require(\n            defendingSoldierCount >= amount,\n            \"You do not have enough defending soldiers to send\"\n        );\n        require(\n            idToForces[idReciever].nationExists = true,\n            \"Destination nation does not exist\"\n        );\n        idToForces[idSender].defendingSoldiers -= amount;\n        idToForces[idSender].numberOfSoldiers -= amount;\n        idToForces[idReciever].defendingSoldiers += amount;\n        idToForces[idReciever].numberOfSoldiers += amount;\n    }\n\n    ///@dev this is a public view function that will return the amount of defending soldiers of a nation\n    ///@notice this function will return the number of defending soldiers for a nation\n    ///@param id is the nation ID of the nation being queried\n    ///@return uint256 is the number of defending soldiers for the queried nation\n    function getDefendingSoldierCount(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 count = idToForces[id].defendingSoldiers;\n        return count;\n    }\n\n    ///@dev this is a public view function that will return the number of soldiers for a nation\n    ///@notice this function will return the number of soldiers a nation has\n    ///@param id this is the nation ID of the nation being queried\n    ///@return soldiers is the nations soldier count\n    function getSoldierCount(\n        uint256 id\n    ) public view returns (uint256 soldiers) {\n        uint256 soldierAmount = idToForces[id].numberOfSoldiers;\n        return soldierAmount;\n    }\n\n    ///@dev this is a public view function that will return a nations deployed soldier count\n    ///@notice this function returns the amount of deployed solders a nation has\n    ///@param id is the nation ID for the nation being queried\n    ///@return soldiers is the number of deployed soldiers for that nation\n    function getDeployedSoldierCount(\n        uint256 id\n    ) public view returns (uint256 soldiers) {\n        uint256 soldierAmount = idToForces[id].deployedSoldiers;\n        return soldierAmount;\n    }\n\n    ///@dev this is a public function that will allow a nation woner to deploy soldiers to a war\n    ///@notice this function allows a nation owner to deploy soldiers to an active war\n    ///@param soldiersToDeploy is the number of soldiers being deployed\n    ///@param tanksToDeploy is the number of tanks being deployed\n    ///@param id is the nation id of the nation deploying soldiers\n    ///@param warId is the id of the active war\n    function deployForces(\n        uint256 soldiersToDeploy,\n        uint256 tanksToDeploy,\n        uint256 id,\n        uint256 warId\n    ) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 totalSoldiers = getSoldierCount(id);\n        uint256 deployedSoldiers = getDeployedSoldierCount(id);\n        uint256 maxDeployablePercentage = getMaxDeployablePercentage(id);\n        uint256 defendingSoldierCount = idToForces[id].defendingSoldiers;\n        require(\n            defendingSoldierCount >= soldiersToDeploy,\n            \"cannot deploy that many soldiers\"\n        );\n        if (soldiersToDeploy > 0) {\n            require(\n                (((deployedSoldiers + soldiersToDeploy) * 100) /\n                    totalSoldiers) <= maxDeployablePercentage,\n                \"deployment exceeds max deployable percentage\"\n            );\n        }\n        uint256 defendingTankCount = idToForces[id].defendingTanks;\n        require(\n            defendingTankCount >= tanksToDeploy,\n            \"deploying too many tanks\"\n        );\n        idToForces[id].defendingSoldiers -= soldiersToDeploy;\n        idToForces[id].deployedSoldiers += soldiersToDeploy;\n        idToForces[id].defendingTanks -= tanksToDeploy;\n        idToForces[id].deployedTanks += tanksToDeploy;\n        war.deployForcesToWar(id, warId, soldiersToDeploy, tanksToDeploy);\n        emit ForcesDeployed(id, soldiersToDeploy, tanksToDeploy, warId);\n    }\n\n    ///@dev this is a public view function that will return the maximum percentage of a population that is deployable\n    ///@notice this function returns the maximum percentage of a population that is deployable to war\n    ///@param id is the nation id of the nation deploying soldiers\n    ///@return uint256 is the maximum percentage of a nations population that is deployable\n    function getMaxDeployablePercentage(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 maxDeployablePercentage = 80;\n        uint256 borderFortificationCount = imp1.getBorderFortificationCount(id);\n        console.log(\"border fortification count\", borderFortificationCount);\n        if (borderFortificationCount > 0) {\n            maxDeployablePercentage -= (2 * borderFortificationCount);\n            console.log(\"max deployable percentage\", maxDeployablePercentage);\n        }\n        return maxDeployablePercentage;\n    }\n\n    ///@dev this is a public function that allows a nation owner to withdraw deployed troops\n    ///@notice this function lets a nation owner deploy troops from war\n    ///@param amountToWithdraw is the amount of soldiers the nation owner is looking to withdraw\n    ///@param id is the nation id of the nation withdrawing soldeirs\n    function withdrawSoldiers(\n        uint256 amountToWithdraw,\n        uint256 id\n    ) public onlyWar {\n        console.log(\"withdraw soldiers function\");\n        console.log(\"amount to withdraw\", amountToWithdraw);\n        console.log(\"id\", id);\n        uint256 deployedSoldierCount = idToForces[id].deployedSoldiers;\n        require(\n            deployedSoldierCount >= amountToWithdraw,\n            \"not enough deployed soldiers to withdraw that many\"\n        );\n        idToForces[id].defendingSoldiers += amountToWithdraw;\n        idToForces[id].deployedSoldiers -= amountToWithdraw;\n    }\n\n    ///@dev this is a public function only callable from the Nuke Contract that will decrease the number of soldiers during a nuke attack\n    ///@notice this function is only callable from the nuke contract\n    ///@notice this function will decrease the amount of soldiers from a nuke strike\n    ///@notice a fallout shelter system will decrease the number of soldiers lost by 50%\n    ///@param id is the nation ID of the nation being attacked\n    function decreaseDefendingSoldierCountFromNukeAttack(\n        uint256 id\n    ) public onlyNukeContract {\n        bool falloutShelter = won1.getFalloutShelterSystem(id);\n        if (!falloutShelter) {\n            uint256 numberOfDefendingSoldiers = idToForces[id]\n                .defendingSoldiers;\n            idToForces[id].defendingSoldiers = 0;\n            idToForces[id].numberOfSoldiers -= numberOfDefendingSoldiers;\n            idToCasualties[id].soldierCasualties += numberOfDefendingSoldiers;\n            emit SoldierDamageFromNukeAttack(id, numberOfDefendingSoldiers);\n        } else {\n            uint256 numberOfDefendingSoldierCasualties = ((\n                idToForces[id].defendingSoldiers\n            ) / 2);\n            idToForces[id]\n                .defendingSoldiers = numberOfDefendingSoldierCasualties;\n            idToForces[id]\n                .numberOfSoldiers -= numberOfDefendingSoldierCasualties;\n            idToCasualties[id]\n                .soldierCasualties += numberOfDefendingSoldierCasualties;\n            emit SoldierDamageFromNukeAttack(\n                id,\n                numberOfDefendingSoldierCasualties\n            );\n        }\n    }\n\n    ///@dev this is a public view function that will adjust the efficiency of a nations deployed soldiers\n    ///@notice this function will adjust the efficiency of a nations deployed soldiers\n    ///@notice aluminium, coal, oil, pigs, barracks, guerilla camps all increase the efficiency od deployed soldiers\n    ///@param id this is the nation ID for the nation being queried\n    ///@return uint256 this is the percentage modifier for a nations deployed forces\n    function getDeployedSoldierEfficiencyModifier(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 efficiencyModifier = 100;\n        bool aluminum = res.viewAluminium(id);\n        if (aluminum) {\n            efficiencyModifier += 20;\n        }\n        bool coal = res.viewCoal(id);\n        if (coal) {\n            efficiencyModifier += 8;\n        }\n        bool oil = res.viewOil(id);\n        if (oil) {\n            efficiencyModifier += 10;\n        }\n        bool pigs = res.viewPigs(id);\n        if (pigs) {\n            efficiencyModifier += 15;\n        }\n        uint256 barracks = imp1.getBarracksCount(id);\n        if (barracks > 0) {\n            efficiencyModifier += (10 * barracks);\n        }\n        uint256 guerillaCamps = imp2.getGuerillaCampCount(id);\n        if (guerillaCamps > 0) {\n            efficiencyModifier += (35 * guerillaCamps);\n        }\n        uint256 governmentType = params.getGovernmentType(id);\n        if (\n            governmentType == 2 ||\n            governmentType == 3 ||\n            governmentType == 4 ||\n            governmentType == 5 ||\n            governmentType == 10\n        ) {\n            efficiencyModifier += 8;\n        }\n        return efficiencyModifier;\n    }\n\n    ///@dev this is a public view function that will adjust the efficiency of a nations defending soldiers\n    ///@notice this function will adjust the efficiency of a nations defending soldiers\n    ///@notice aluminium, coal, oil, pigs, barracks, border fortifications and forward operating bases all increase the efficiency od defending soldiers\n    ///@param id this is the nation ID for the nation being queried\n    ///@return uint256 this is the percentage modifier for a nations defending forces\n    function getDefendingSoldierEfficiencyModifier(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 efficiencyModifier = 100;\n        bool aluminum = res.viewAluminium(id);\n        if (aluminum) {\n            efficiencyModifier += 20;\n        }\n        bool coal = res.viewCoal(id);\n        if (coal) {\n            efficiencyModifier += 8;\n        }\n        bool oil = res.viewOil(id);\n        if (oil) {\n            efficiencyModifier += 10;\n        }\n        bool pigs = res.viewPigs(id);\n        if (pigs) {\n            efficiencyModifier += 15;\n        }\n        uint256 barracks = imp1.getBarracksCount(id);\n        if (barracks > 0) {\n            efficiencyModifier += (10 * barracks);\n        }\n        uint256 borderFortification = imp1.getBorderFortificationCount(id);\n        if (borderFortification > 0) {\n            efficiencyModifier += (borderFortification * 2);\n        }\n        uint256 fobCount = imp2.getForwardOperatingBaseCount(id);\n        if (fobCount > 0) {\n            efficiencyModifier -= (fobCount * 3);\n        }\n        uint256 guerillaCamps = imp2.getGuerillaCampCount(id);\n        if (guerillaCamps > 0) {\n            efficiencyModifier += (35 * guerillaCamps);\n        }\n        uint256 governmentType = params.getGovernmentType(id);\n        if (\n            governmentType == 2 ||\n            governmentType == 3 ||\n            governmentType == 4 ||\n            governmentType == 5 ||\n            governmentType == 10\n        ) {\n            efficiencyModifier += 8;\n        }\n        return efficiencyModifier;\n    }\n\n    ///@dev this is a public function that allows a nation owner to decommission soldiers\n    ///@notice this function allows a nation owner to decomission soldiers\n    ///@param amount is the amount of soldiers being decomissioned\n    ///@param id is the nation ID of the nation\n    function decommissionSoldiers(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 defendingSoldierCount = getDefendingSoldierCount(id);\n        require(\n            (defendingSoldierCount - amount) >= 0,\n            \"not enough defending soldiers\"\n        );\n        idToForces[id].defendingSoldiers -= amount;\n        idToForces[id].numberOfSoldiers -= amount;\n        emit SoldiersDecommissioned(id, amount);\n    }\n\n    ///@dev this is a public function that allows a nation owner to buy tanks\n    ///@notice this function allows a nation owner to buy tanks\n    ///@notice tanks cost 40X what soldeirs cost a nation\n    ///@notice factories reduce the cost of tanks 5% per factory\n    ///@param amount is the number of tanks being purchased\n    ///@param id is the nation ID of the nation purchasing tanks\n    function buyTanks(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 maxTanks = getMaxTankCount(id);\n        uint256 currentTanks = idToForces[id].numberOfTanks;\n        require(\n            (currentTanks + amount) <= maxTanks,\n            \"cannot buy that many tanks\"\n        );\n        uint256 costPerTank = getTankCost(id);\n        uint256 cost = (costPerTank * amount);\n        uint256 balance = TreasuryContract(treasuryAddress).checkBalance(id);\n        require(balance >= cost);\n        idToForces[id].numberOfTanks += amount;\n        idToForces[id].defendingTanks += amount;\n        TreasuryContract(treasuryAddress).spendBalance(id, cost);\n        emit TanksPurchased(id, amount);\n    }\n\n    ///@dev this is a public function that allows a nation owner to decommission soldiers\n    ///@notice this function allows a nation owner to decomission soldiers\n    ///@param amount is the amount of soldiers being decomissioned\n    ///@param id is the nation ID of the nation\n    function decommissionTanks(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 defendingTankCount = getDefendingTankCount(id);\n        require(\n            (defendingTankCount - amount) >= 0,\n            \"not enough defending tanks\"\n        );\n        idToForces[id].defendingTanks -= amount;\n        idToForces[id].numberOfTanks -= amount;\n        emit TanksDecommissioned(id, amount);\n    }\n\n    ///@dev this is a public view function that will return the maximum amount of tanks a nation can own\n    ///@notice this function returns the maximum amount of tanks a nation can own\n    ///@notice a nation's max tanks is the lesser of 10% of soldier efficiency or 8% of citizens\n    ///@param id is the nation ID of the nation being queried\n    ///@return uint256 is the maximum amount of tanks that nation can own\n    function getMaxTankCount(uint256 id) public view returns (uint256) {\n        uint256 soldiers = getSoldierCount(id);\n        uint256 efficiency = getDefendingSoldierEfficiencyModifier(id);\n        uint256 modifiedSoldierCount = ((soldiers * efficiency) / 100);\n        uint256 tankMax = (modifiedSoldierCount / 10);\n        uint256 citizenCount = inf.getTotalPopulationCount(id);\n        uint256 tankMaxByCitizen = ((citizenCount * 8) / 100);\n        if (tankMaxByCitizen < tankMax) {\n            tankMax = tankMaxByCitizen;\n        }\n        return tankMax;\n    }\n\n    ///@dev this is a public view function that will return the cost a nation has to pay for tanks\n    ///@notice the default cost of a tnak is soldier cost * 40\n    ///@notice tank cost will be reduced by 5% for every factory owned\n    ///@param id is the nation id of the nation buying tanks\n    ///@return cost is the cost per tank for a given nation\n    function getTankCost(uint256 id) public view returns (uint256) {\n        uint256 soldierCost = getSoldierCost(id);\n        uint256 purchasePrice = soldierCost * 40;\n        uint256 factoryCount = imp1.getFactoryCount(id);\n        uint256 costModifier = 100;\n        if (factoryCount > 0) {\n            costModifier -= (factoryCount * 5);\n        }\n        bool lead = res.viewLead(id);\n        if (lead) {\n            costModifier -= 8;\n        }\n        uint256 cost = ((purchasePrice * costModifier) / 100);\n        return cost;\n    }\n\n    function withdrawTanks(\n        uint256 amountToWithdraw,\n        uint256 id\n    ) public onlyWar {\n        uint256 deployedTankCount = idToForces[id].deployedTanks;\n        require(deployedTankCount >= amountToWithdraw, \"not enough tanks to withdraw that many\");\n        idToForces[id].defendingTanks += amountToWithdraw;\n        idToForces[id].deployedTanks -= amountToWithdraw;\n    }\n\n    ///@dev this is a public view function that can only be called by the Spy Contract\n    ///@notice this funtion will allow the spy contract to decrease the number of defending tanks in a spy attack\n    ///@param amount is the amount of tanks being decreased\n    ///@param id is the nation id of the nation being attacked\n    function decreaseDefendingTankCount(\n        uint256 amount,\n        uint256 id\n    ) public onlySpyContract {\n        idToForces[id].defendingTanks -= amount;\n        idToForces[id].numberOfTanks -= amount;\n    }\n\n    ///@dev this is a public function that can only be called from the cruise missile contract\n    ///@notice this funtion will allow the cruise missile contact to decrease the number of tanks in a cruise missile attack\n    ///@param amount is the number of tanks being decreased\n    ///@param id is the nation id of the nation being attacked\n    function decreaseDefendingTankCountFromCruiseMissileContract(\n        uint256 amount,\n        uint256 id\n    ) public onlyCruiseMissileContract {\n        idToForces[id].defendingTanks -= amount;\n        idToForces[id].numberOfTanks -= amount;\n        emit TankDamageFromCruiseMissile(id, amount);\n    }\n\n    ///@dev this is a public function that can only be called from the nuke contract\n    ///@notice this funtion will allow the cruise missile contact to decrease the number of tanks in a nuke attack\n    ///@param id is the nation id of the nation being attacked\n    function decreaseDefendingTankCountFromNukeContract(\n        uint256 id\n    ) public onlyNukeContract {\n        uint256 defendingTanks = idToForces[id].defendingTanks;\n        uint256 percentage = 35;\n        bool falloutShelter = won1.getFalloutShelterSystem(id);\n        if (falloutShelter) {\n            percentage = 25;\n        }\n        uint256 defendingTanksToDecrease = ((defendingTanks * percentage) /\n            100);\n        idToForces[id].numberOfTanks -= defendingTanksToDecrease;\n        idToForces[id].defendingTanks -= defendingTanksToDecrease;\n        emit TankDamageFromNukeAttack(id, defendingTanksToDecrease);\n    }\n\n    ///@dev this is a public function that can only be called from the air battle contract\n    ///@notice this funtion will allow the cruise missile contact to decrease the number of tanks in a bombing attack\n    ///@param amountToDecrease is the number of tanks being decreased\n    ///@param id is the nation id of the nation being attacked\n    function decreaseDefendingTankCountFromAirBattleContract(\n        uint256 id,\n        uint256 amountToDecrease\n    ) public onlyAirBattle {\n        uint256 defendingTanks = idToForces[id].defendingTanks;\n        if (amountToDecrease > 30) {\n            amountToDecrease = 30;\n        }\n        if (amountToDecrease >= defendingTanks) {\n            idToForces[id].numberOfTanks -= defendingTanks;\n            idToForces[id].defendingTanks = 0;\n            amountToDecrease = defendingTanks;\n        } else {\n            idToForces[id].numberOfTanks -= amountToDecrease;\n            idToForces[id].defendingTanks -= amountToDecrease;\n        }\n        emit TankDamageFromAirAssault(id, amountToDecrease);\n    }\n\n    ///@dev this is a public view function that will return the number of tanks a nation has\n    ///@notice this function will return the number of tanks for a nation\n    ///@param id is the nation id for the nation being queried\n    ///@return tanks is the number of tanks for the nation being queried\n    function getTankCount(uint256 id) public view returns (uint256 tanks) {\n        uint256 tankAmount = idToForces[id].numberOfTanks;\n        return tankAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of deployed tanks a nation has\n    ///@notice this function will return the number of deployed tanks for a nation\n    ///@param id is the nation id for the nation being queried\n    ///@return tanks is the number of deployed tanks for the nation being queried\n    function getDeployedTankCount(\n        uint256 id\n    ) public view returns (uint256 tanks) {\n        uint256 tankAmount = idToForces[id].deployedTanks;\n        return tankAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of defending tanks a nation has\n    ///@notice this function will return the number of defending tanks for a nation\n    ///@param id is the nation id for the nation being queried\n    ///@return tanks is the number of defending tanks for the nation being queried\n    function getDefendingTankCount(\n        uint256 id\n    ) public view returns (uint256 tanks) {\n        uint256 tankAmount = idToForces[id].defendingTanks;\n        return tankAmount;\n    }\n\n    ///@dev this is a public function only callable from the ground battle contract\n    ///@dev this function will decrease the losses of an attacker during a ground battle\n    ///@notice this function will decrease the number of losses of an attacker during a ground battle\n    ///@param attackerSoldierLosses is the soldier losses for an attacker from a battle\n    ///@param attackerTankLosses is the tank losses for an attacker from a battle\n    ///@param attackerId is the nation ID of the nation suffering losses\n    function decreaseUnits(\n        uint256 attackerSoldierLosses,\n        uint256 attackerTankLosses,\n        uint256 attackerId,\n        uint256 defenderSoldierLosses,\n        uint256 defenderTankLosses,\n        uint256 defenderId\n    ) public onlyGroundBattle {\n        idToForces[attackerId].numberOfSoldiers -= attackerSoldierLosses;\n        idToForces[attackerId].deployedSoldiers -= attackerSoldierLosses;\n        idToForces[attackerId].numberOfTanks -= attackerTankLosses;\n        idToForces[attackerId].deployedTanks -= attackerTankLosses;\n        idToForces[defenderId].numberOfSoldiers -= defenderSoldierLosses;\n        idToForces[defenderId].defendingSoldiers -= defenderSoldierLosses;\n        idToForces[defenderId].numberOfTanks -= defenderTankLosses;\n        idToForces[defenderId].defendingTanks -= defenderTankLosses;\n        idToCasualties[attackerId].soldierCasualties += attackerSoldierLosses;\n        idToCasualties[attackerId].tankCasualties += attackerTankLosses;\n        idToCasualties[defenderId].soldierCasualties += defenderSoldierLosses;\n        idToCasualties[defenderId].tankCasualties += defenderTankLosses;\n    }\n\n    ///@dev this is a function for the development environment that will assist in testing wonders and improvements that are available after a certain number of casualties\n    function increaseSoldierCasualties(\n        uint256 id,\n        uint256 amount\n    ) public onlyOwner {\n        idToCasualties[id].soldierCasualties += amount;\n    }\n\n    ///@dev this is a public view function that will return a nations casualty count\n    ///@notice this function will return a nations casualty count\n    ///@param id is a nation id for the nation being queried\n    ///@return uint256 is the soldier casualty count for a given nation\n    ///@return uint256 is the tank casualty count for a given nation\n    function getCasualties(uint256 id) public view returns (uint256, uint256) {\n        uint256 soldierCasualties = idToCasualties[id].soldierCasualties;\n        uint256 tankCasualties = idToCasualties[id].tankCasualties;\n        return (soldierCasualties, tankCasualties);\n    }\n}\n\n\n\n\n"
    },
    "contracts/GroundBattle.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./War.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Forces.sol\";\nimport \"./Treasury.sol\";\nimport \"./Improvements.sol\";\nimport \"./Wonders.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./Taxes.sol\";\nimport \"./CountryParameters.sol\";\nimport \"./Military.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\nimport \"hardhat/console.sol\";\n\n///@title GroundBattleContract\n///@author OxSnosh\n///@dev this contract inherits from the openzeppelin ownable contract\n///@dev this contract inherits from the chainlink vrf contract\n///@notice the GroundBattleContract will allow nations at war to launch ground attacks against each other\ncontract GroundBattleContract is Ownable, VRFConsumerBaseV2, ChainlinkClient {\n    using Chainlink for Chainlink.Request;\n\n    uint256 groundBattleId;\n    address warAddress;\n    address infrastructure;\n    address forces;\n    address treasury;\n    address improvements2;\n    address improvements4;\n    address wonders3;\n    address wonders4;\n    address countryMinter;\n    address additionalTaxes;\n    address parameters;\n    address military;\n\n    uint256[] public todaysGroundBattles;\n\n    WarContract war;\n    InfrastructureContract inf;\n    ForcesContract force;\n    TreasuryContract tsy;\n    ImprovementsContract2 imp2;\n    ImprovementsContract4 imp4;\n    WondersContract3 won3;\n    WondersContract4 won4;\n    CountryMinter mint;\n    AdditionalTaxesContract addTax;\n    CountryParametersContract param;\n    MilitaryContract mil;\n\n    struct GroundForcesToBattle {\n        uint256 attackType;\n        uint256 soldierCount;\n        uint256 tankCount;\n        uint256 strength;\n        uint256 countryId;\n        uint256 warId;\n    }\n\n    struct BattleResults {\n        uint256 nationId;\n        uint256 soldierLosses;\n        uint256 tankLosses;\n        uint256 defenderId;\n        uint256 defenderSoldierLosses;\n        uint256 defenderTankLosses;\n    }\n\n    //Chainlik Variables\n    uint256[] private s_randomWords;\n    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;\n    uint64 private immutable i_subscriptionId;\n    bytes32 private immutable i_gasLane;\n    uint32 private immutable i_callbackGasLimit;\n    uint16 private constant REQUEST_CONFIRMATIONS = 3;\n    uint32 private constant NUM_WORDS = 10;\n\n    mapping(uint256 => GroundForcesToBattle) groundBattleIdToAttackerForces;\n    mapping(uint256 => GroundForcesToBattle) groundBattleIdToDefenderForces;\n    mapping(uint256 => BattleResults) groundBattleIdToBattleResults;\n    mapping(uint256 => bool) groundBattleIdToAtackerVictory;\n    \n    mapping(uint256 => uint256) s_requestIdToRequestIndex;\n    mapping(uint256 => uint256[]) public s_requestIndexToRandomWords;\n\n    event BattleResultsEvent (\n        uint256 indexed battleId,\n        uint256 attackSolderLosses,\n        uint256 attackTankLosses,\n        uint256 defenderSoldierLosses,\n        uint256 defenderTankLosses\n    );\n\n    constructor(\n        address vrfCoordinatorV2,\n        uint64 subscriptionId,\n        bytes32 gasLane, // keyHash\n        uint32 callbackGasLimit\n    ) VRFConsumerBaseV2(vrfCoordinatorV2) {\n        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2);\n        i_gasLane = gasLane;\n        i_subscriptionId = subscriptionId;\n        i_callbackGasLimit = callbackGasLimit;\n    }\n\n    function settings(\n        address _warAddress,\n        address _infrastructure,\n        address _forces,\n        address _treasury,\n        address _countryMinter,\n        address _military\n    ) public onlyOwner {\n        warAddress = _warAddress;\n        war = WarContract(_warAddress);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        forces = _forces;\n        force = ForcesContract(_forces);\n        treasury = _treasury;\n        tsy = TreasuryContract(_treasury);\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        military = _military;\n        mil = MilitaryContract(_military);\n    }\n\n    function settings2(\n        address _improvements2,\n        address _improvements4,\n        address _wonders3,\n        address _wonders4,\n        address _additionalTaxes,\n        address _parameters\n    ) public onlyOwner {\n        improvements2 = _improvements2;\n        imp2 = ImprovementsContract2(_improvements2);\n        improvements4 = _improvements4;\n        imp4 = ImprovementsContract4(_improvements4);\n        wonders3 = _wonders3;\n        won3 = WondersContract3(_wonders3);\n        wonders4 = _wonders4;\n        won4 = WondersContract4(_wonders4);\n        additionalTaxes = _additionalTaxes;\n        addTax = AdditionalTaxesContract(_additionalTaxes);\n        parameters = _parameters;\n        param = CountryParametersContract(_parameters);\n    }\n\n    function updateWarContract(address newAddress) public onlyOwner {\n        warAddress = newAddress;\n        war = WarContract(newAddress);\n    }\n\n    function updateInfrastructureContract(address newAddress) public onlyOwner {\n        infrastructure = newAddress;\n        inf = InfrastructureContract(newAddress);\n    }\n\n    function updateForcesContract(address newAddress) public onlyOwner {\n        forces = newAddress;\n        force = ForcesContract(newAddress);\n    }\n\n    function updateTreasuryContract(address newAddress) public onlyOwner {\n        treasury = newAddress;\n        tsy = TreasuryContract(newAddress);\n    }\n\n    function updateImprovemetsContract2(address newAddress) public onlyOwner {\n        improvements2 = newAddress;\n        imp2 = ImprovementsContract2(newAddress);\n    }\n\n    function updateWondersContract3(address newAddress) public onlyOwner {\n        wonders3 = newAddress;\n        won3 = WondersContract3(newAddress);\n    }\n\n    function updateWondersContract4(address newAddress) public onlyOwner {\n        wonders4 = newAddress;\n        won4 = WondersContract4(newAddress);\n    }\n\n    function battleOdds(\n        uint256 _warId,\n        uint256 attackerId\n    ) public view returns (uint256 attackerOdds, uint256 defenderOdds) {\n        (uint256 warOffense, uint256 warDefense) = war.getInvolvedParties(\n            _warId\n        );\n        uint256 attackerStrength;\n        uint256 defenderStrength;\n        uint256 attackerOddsOfVictory;\n        uint256 defenderOddsOfVictory;\n        if (attackerId == warOffense) {\n            attackerStrength = getAttackerForcesStrength(warOffense, _warId);\n            defenderStrength = getDefenderForcesStrength(warDefense, _warId);\n            attackerOddsOfVictory = ((attackerStrength * 100) /\n                (attackerStrength + defenderStrength));\n            defenderOddsOfVictory = ((defenderStrength * 100) /\n                (attackerStrength + defenderStrength));\n        } else if (attackerId == warDefense) {\n            attackerStrength = getAttackerForcesStrength(warDefense, _warId);\n            defenderStrength = getDefenderForcesStrength(warOffense, _warId);\n            attackerOddsOfVictory = ((attackerStrength * 100) /\n                (attackerStrength + defenderStrength));\n            defenderOddsOfVictory = ((defenderStrength * 100) /\n                (attackerStrength + defenderStrength));\n        }\n        return (attackerOddsOfVictory, defenderOddsOfVictory);\n    }\n\n    ///@dev this is a public function callable only from a nation owner\n    ///@dev this contract allows nations at war to launch a ground attack against each other\n    ///@notice this contract allows nations at war to launch a ground attack against each other\n    ///@param warId is the war id of the war between the 2 nations in the battle\n    ///@param attackerId is the nation id of the attacking nation\n    ///@param defenderId is the nation id of the defending nation\n    ///@param attackType 1. planned 2. standard 3. aggressive 4. beserk\n    function groundAttack(\n        uint256 warId,\n        uint256 attackerId,\n        uint256 defenderId,\n        uint256 attackType\n    ) public {\n        bool isOwner = mint.checkOwnership(attackerId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        bool isActiveWar = war.isWarActive(warId);\n        require(isActiveWar, \"!not active war\");\n        (uint256 warOffense, uint256 warDefense) = war.getInvolvedParties(\n            warId\n        );\n        require(\n            warOffense == attackerId || warOffense == defenderId,\n            \"invalid parameters\"\n        );\n        require(\n            warDefense == attackerId || warDefense == defenderId,\n            \"invalid parameters\"\n        );\n        require(\n            attackType == 1 ||\n                attackType == 2 ||\n                attackType == 3 ||\n                attackType == 4,\n            \"invalid attack type\"\n        );\n        generateAttackerForcesStruct(\n            warId,\n            groundBattleId,\n            attackerId,\n            attackType\n        );\n        generateDefenderForcesStruct(warId, groundBattleId, defenderId);\n        war.cancelPeaceOffersUponAttack(warId);\n        fulfillRequest(groundBattleId);\n        groundBattleId++;\n        console.log(\"GROUND BATTLE ID: \", groundBattleId);\n    }\n\n    function generateAttackerForcesStruct(\n        uint256 warId,\n        uint256 battleId,\n        uint256 attackerId,\n        uint256 attackType\n    ) internal {\n        (uint256 soldiersDeployed, uint256 tanksDeployed) = war\n            .getDeployedGroundForces(warId, attackerId);\n        uint256 attackerForcesStrength = getAttackerForcesStrength(\n            attackerId,\n            warId\n        );\n        GroundForcesToBattle memory newGroundForces = GroundForcesToBattle(\n            attackType,\n            soldiersDeployed,\n            tanksDeployed,\n            attackerForcesStrength,\n            attackerId,\n            warId\n        );\n        groundBattleIdToAttackerForces[battleId] = newGroundForces;\n    }\n\n    function returnAttackerForcesStruct(\n        uint256 battleId\n    )\n        public\n        view\n        returns (uint256, uint256, uint256, uint256, uint256, uint256)\n    {\n        uint256 attackType = groundBattleIdToAttackerForces[battleId]\n            .attackType;\n        uint256 soldiersDeployed = groundBattleIdToAttackerForces[battleId]\n            .soldierCount;\n        uint256 tanksDeployed = groundBattleIdToAttackerForces[battleId]\n            .tankCount;\n        uint256 attackerForcesStrength = groundBattleIdToAttackerForces[\n            battleId\n        ].strength;\n        uint256 attackerId = groundBattleIdToAttackerForces[battleId].countryId;\n        uint256 warId = groundBattleIdToAttackerForces[battleId].warId;\n        return (\n            attackType,\n            soldiersDeployed,\n            tanksDeployed,\n            attackerForcesStrength,\n            attackerId,\n            warId\n        );\n    }\n\n    function generateDefenderForcesStruct(\n        uint256 warId,\n        uint256 battleId,\n        uint256 defenderId\n    ) internal {\n        uint256 soldiers = force.getDefendingSoldierCount(defenderId);\n        uint256 tanks = force.getDefendingTankCount(defenderId);\n        uint256 defenderForcesStrength = getDefenderForcesStrength(\n            defenderId,\n            battleId\n        );\n        GroundForcesToBattle memory newGroundForces = GroundForcesToBattle(\n            0,\n            soldiers,\n            tanks,\n            defenderForcesStrength,\n            defenderId,\n            warId\n        );\n        groundBattleIdToDefenderForces[battleId] = newGroundForces;\n    }\n\n    function returnDefenderForcesStruct(\n        uint256 battleId\n    ) public view returns (uint256, uint256, uint256, uint256, uint256) {\n        uint256 soldiersDefending = groundBattleIdToDefenderForces[battleId]\n            .soldierCount;\n        uint256 tanksDefending = groundBattleIdToDefenderForces[battleId]\n            .tankCount;\n        uint256 defendingForcesStrength = groundBattleIdToDefenderForces[\n            battleId\n        ].strength;\n        uint256 defenderId = groundBattleIdToDefenderForces[battleId].countryId;\n        uint256 warId = groundBattleIdToDefenderForces[battleId].warId;\n        return (\n            soldiersDefending,\n            tanksDefending,\n            defendingForcesStrength,\n            defenderId,\n            warId\n        );\n    }\n\n    function getAttackerForcesStrength(\n        uint256 attackerId,\n        uint256 warId\n    ) public view returns (uint256) {\n        (, uint256 tanksDeployed) = war.getDeployedGroundForces(\n            warId,\n            attackerId\n        );\n        uint256 soldierEfficiency = getAttackingSoldierEfficiency(\n            attackerId,\n            warId\n        );\n        uint256 strength = (soldierEfficiency + (15 * tanksDeployed));\n        uint256 mod = 100;\n        bool pentagon = won3.getPentagon(attackerId);\n        if (pentagon) {\n            mod += 20;\n        }\n        bool logisticalSupport = won4.getSuperiorLogisticalSupport(attackerId);\n        if (logisticalSupport) {\n            mod += 10;\n        }\n        //tanks\n        uint256 tankModifier = (tanksDeployed / 100);\n        if (tankModifier > 75) {\n            tankModifier = 75;\n        }\n        mod += tankModifier;\n        //defcon\n        uint256 defcon = mil.getDefconLevel(attackerId);\n        mod += ((5 - defcon) * 5);\n        strength = ((strength * mod) / 100);\n        return strength;\n    }\n\n    function getAttackingSoldierEfficiency(\n        uint256 attackerId,\n        uint256 _warId\n    ) public view returns (uint256) {\n        (uint256 attackingSoldiers, ) = war.getDeployedGroundForces(\n            _warId,\n            attackerId\n        );\n        uint256 attackingEfficiencyModifier = force\n            .getDeployedSoldierEfficiencyModifier(attackerId);\n        uint256 attackingSoldierEfficiency = ((attackingSoldiers *\n            attackingEfficiencyModifier) / 100);\n        return attackingSoldierEfficiency;\n    }\n\n    function getDefenderForcesStrength(\n        uint256 defenderId,\n        uint256 _warId\n    ) public view returns (uint256) {\n        uint256 soldierEfficiency = getDefendingSoldierEfficiency(defenderId);\n        uint256 tanks = force.getDefendingTankCount(defenderId);\n        uint256 strength = ((soldierEfficiency) + (17 * tanks));\n        (uint256 warOffense, uint256 warDefense) = war.getInvolvedParties(\n            _warId\n        );\n        uint256 attackerId;\n        if (defenderId == warOffense) {\n            attackerId = warDefense;\n        } else if (defenderId == warDefense) {\n            attackerId = warOffense;\n        }\n        uint256 mod = getDefenderStrengthModifier(defenderId, attackerId);\n        strength = ((strength * mod) / 100);\n        return strength;\n    }\n\n    function getDefendingSoldierEfficiency(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 defendingSoldiers = force.getDefendingSoldierCount(id);\n        uint256 defendingEfficiencyModifier = force\n            .getDefendingSoldierEfficiencyModifier(id);\n        uint256 defendingSoldierEfficiency = ((defendingSoldiers *\n            defendingEfficiencyModifier) / 100);\n        return defendingSoldierEfficiency;\n    }\n\n    function getDefenderStrengthModifier(uint256 defenderId, uint256 attackerId) public view returns (uint256) {\n        uint256 mod = 100;\n        uint256 officeOfPropagandaCount = imp4.getOfficeOfPropagandaCount(\n            attackerId\n        );\n        bool pentagon = won3.getPentagon(defenderId);\n        bool logisticalSupport = won4.getSuperiorLogisticalSupport(defenderId);\n        if (officeOfPropagandaCount > 0) {\n            mod -= (5 * officeOfPropagandaCount);\n        }\n        if (pentagon) {\n            mod += 20;\n        }\n        if (logisticalSupport) {\n            mod += 10;\n        }\n        //infrastructure\n        uint256 infrastructureLevel = inf.getInfrastructureCount(defenderId);\n        uint256 infrastructureModifier = (infrastructureLevel / 100);\n        if (infrastructureModifier > 75) {\n            infrastructureModifier = 75;\n        }\n        mod += infrastructureModifier;\n        //defcon\n        uint256 defcon = mil.getDefconLevel(defenderId);\n        mod += ((5 - defcon) * 5);\n        return mod;\n    }\n\n    bytes32 groundBattleJobId;\n    address oracleAddress;\n    uint256 fee;\n\n    function updateJobId(bytes32 _jobId) public onlyOwner {\n        groundBattleJobId = _jobId;\n    }\n\n    function updateOracleAddress(address _oracleAddress) public onlyOwner {\n        oracleAddress = _oracleAddress;\n        setChainlinkOracle(_oracleAddress);\n    }\n\n    function updateLinkAddress(address _linkToken) public onlyOwner {\n        setChainlinkToken(_linkToken);\n    }\n\n    function updateFee(uint256 _fee) public onlyOwner {\n        fee = _fee;\n    }\n\n    function fulfillRequest(uint256 battleId) internal {\n        console.log(\"at fulfillRequest()\");\n        uint256 requestId = i_vrfCoordinator.requestRandomWords(\n            i_gasLane,\n            i_subscriptionId,\n            REQUEST_CONFIRMATIONS,\n            i_callbackGasLimit,\n            NUM_WORDS\n        );\n        s_requestIdToRequestIndex[requestId] = battleId;\n        console.log(\"REQUEST ID: \", requestId);\n    }\n\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) internal override {\n        console.log(\"arrived at fulfillRandom()\");\n        uint256 requestNumber = s_requestIdToRequestIndex[requestId];\n        s_requestIndexToRandomWords[requestNumber] = randomWords;\n        uint256 attackerStrength = groundBattleIdToAttackerForces[requestNumber]\n            .strength;\n        uint256 defenderStrength = groundBattleIdToDefenderForces[requestNumber]\n            .strength;\n        uint256 attackerId = groundBattleIdToAttackerForces[requestNumber]\n            .countryId;\n        uint256 defenderId = groundBattleIdToDefenderForces[requestNumber]\n            .countryId;\n        uint256 warId = groundBattleIdToAttackerForces[requestNumber].warId;\n        Chainlink.Request memory req = buildOperatorRequest(\n            groundBattleJobId,\n            this.completeBattleSequence.selector\n        );\n        req.addUint(\"attackId\", requestNumber);\n        req.addBytes(\"randomWords\", abi.encode(randomWords));\n        req.addUint(\"attackerStrength\", attackerStrength);\n        req.addUint(\"defenderStrength\", defenderStrength);\n        req.addUint(\"attackerId\", attackerId);\n        req.addUint(\"defenderId\", defenderId);\n        req.addUint(\"warId\", warId);\n        sendOperatorRequest(req, fee);\n        console.log(\"request sent\");\n    }\n\n    event GroundBattleResultsEvent (\n        uint256 battleId,\n        uint256 warId,\n        uint256 attackerId,\n        uint256 attackSoldierLosses,\n        uint256 attackTankLosses,\n        uint256 defenderId,\n        uint256 defenderSoldierLosses,\n        uint256 defenderTankLosses\n    );\n\n    function completeBattleSequence(\n        bytes32 requestId,\n        uint256 battleId, \n        uint256 attackerId,\n        uint256 attackerSoldierLosses,\n        uint256 attackerTankLosses,\n        uint256 defenderId,\n        uint256 defenderSoldierLosses,\n        uint256 defenderTankLosses,\n        uint256 warId,\n        bool attackerVictory\n    ) external recordChainlinkFulfillment(requestId) {\n        groundBattleIdToAtackerVictory[battleId] = attackerVictory;\n        emit BattleResultsEvent (\n            battleId,\n            attackerSoldierLosses,\n            attackerTankLosses,\n            defenderSoldierLosses,\n            defenderTankLosses\n        );\n        BattleResults memory newBattleResults = BattleResults(\n            attackerId,\n            attackerSoldierLosses,\n            attackerTankLosses,\n            defenderId,\n            defenderSoldierLosses,\n            defenderTankLosses\n        );\n        groundBattleIdToBattleResults[\n            battleId\n        ] = newBattleResults;\n        force.decreaseUnits(\n            attackerSoldierLosses,\n            attackerTankLosses,\n            attackerId,\n            defenderSoldierLosses,\n            defenderTankLosses,\n            defenderId\n        );\n        war.decreaseGroundBattleLosses(\n            attackerSoldierLosses,\n            attackerTankLosses,\n            attackerId,\n            warId\n        );\n        emit GroundBattleResultsEvent (\n            battleId,\n            warId,\n            attackerId,\n            attackerSoldierLosses,\n            attackerTankLosses,\n            defenderId,\n            defenderSoldierLosses,\n            defenderTankLosses\n        );\n        (, , bool anarchyCheckDefender) = addTax.soldierToPopulationRatio(\n            defenderId\n        );\n        (, , bool anarchyCheckAttacker) = addTax.soldierToPopulationRatio(\n            attackerId\n        );\n        if (anarchyCheckDefender) {\n            param.inflictAnarchy(defenderId);\n        }\n        if (anarchyCheckAttacker) {\n            param.inflictAnarchy(attackerId);\n        }\n        // collectSpoils(battleId, attackerId);\n        console.log(\"BATTLE COMPLETE\");\n    }\n\n    function returnBattleResults(\n        uint256 battleId\n    )\n        public\n        view\n        returns (uint256, uint256, uint256, uint256, uint256, uint256)\n    {\n        uint256 attackerId = groundBattleIdToBattleResults[battleId]\n            .nationId;\n        uint256 attackerSoldierLosses = groundBattleIdToBattleResults[\n            battleId\n        ].soldierLosses;\n        uint256 attackerTankLosses = groundBattleIdToBattleResults[\n            battleId\n        ].tankLosses;\n        uint256 defenderId = groundBattleIdToBattleResults[battleId]\n            .defenderId;\n        uint256 defenderSoldierLosses = groundBattleIdToBattleResults[\n            battleId\n        ].defenderSoldierLosses;\n        uint256 defenderTankLosses = groundBattleIdToBattleResults[\n            battleId\n        ].defenderTankLosses;\n        return (\n            attackerId,\n            attackerSoldierLosses,\n            attackerTankLosses,\n            defenderId,\n            defenderSoldierLosses,\n            defenderTankLosses\n        );\n    }\n\n    function returnAttackVictorious(\n        uint256 battleId\n    ) public view returns (bool) {\n        bool attackVictorious = groundBattleIdToAtackerVictory[battleId];\n        return attackVictorious;\n    }\n\n    function getPercentageLosses(\n        uint256 battleId\n    ) public view returns (uint256, uint256, uint256, uint256) {\n        uint256[] memory randomWords = s_requestIndexToRandomWords[battleId];\n        uint256 outcomeModifierForWinnerSoldiers = randomWords[1];\n        uint256 outcomeModifierForWinnerTanks = randomWords[2];\n        uint256 winnerSoldierLossesPercentage;\n        uint256 winnerTankLossesPercentage;\n        (\n            uint256 loserSoldierLossesPercentage,\n            uint256 loserTankLossesPercentage\n        ) = getLoserPercentageLosses(battleId);\n        uint256 attackType = groundBattleIdToAttackerForces[battleId]\n            .attackType;\n        if (attackType == 1) {\n            winnerSoldierLossesPercentage = (5 +\n                (outcomeModifierForWinnerSoldiers % 11));\n            winnerTankLossesPercentage = (5 +\n                (outcomeModifierForWinnerTanks % 6));\n        } else if (attackType == 2) {\n            winnerSoldierLossesPercentage = (10 +\n                (outcomeModifierForWinnerSoldiers % 11));\n            winnerTankLossesPercentage = (10 +\n                (outcomeModifierForWinnerTanks % 6));\n        } else if (attackType == 3) {\n            winnerSoldierLossesPercentage = (15 +\n                (outcomeModifierForWinnerSoldiers % 16));\n            winnerTankLossesPercentage = (15 +\n                (outcomeModifierForWinnerTanks % 11));\n        } else {\n            winnerSoldierLossesPercentage = (25 +\n                (outcomeModifierForWinnerSoldiers % 16));\n            winnerTankLossesPercentage = (25 +\n                (outcomeModifierForWinnerTanks % 11));\n        }\n        return (\n            winnerSoldierLossesPercentage,\n            winnerTankLossesPercentage,\n            loserSoldierLossesPercentage,\n            loserTankLossesPercentage\n        );\n    }\n\n    function getLoserPercentageLosses(\n        uint256 battleId\n    ) public view returns (uint256, uint256) {\n        uint256[] memory randomWords = s_requestIndexToRandomWords[battleId];\n        uint256 outcomeModifierForLoserSoldiers = randomWords[3];\n        uint256 outcomeModifierForLoserTanks = randomWords[4];\n        uint256 loserSoldierLossesPercentage;\n        uint256 loserTankLossesPercentage;\n        uint256 attackType = groundBattleIdToAttackerForces[battleId]\n            .attackType;\n        if (attackType == 1) {\n            loserSoldierLossesPercentage = (20 +\n                (outcomeModifierForLoserSoldiers % 11));\n            loserTankLossesPercentage = (20 +\n                (outcomeModifierForLoserTanks % 6));\n        } else if (attackType == 2) {\n            loserSoldierLossesPercentage = (30 +\n                (outcomeModifierForLoserSoldiers % 16));\n            loserTankLossesPercentage = (30 +\n                (outcomeModifierForLoserTanks % 6));\n        } else if (attackType == 3) {\n            loserSoldierLossesPercentage = (35 +\n                (outcomeModifierForLoserSoldiers % 21));\n            loserTankLossesPercentage = (35 +\n                (outcomeModifierForLoserTanks % 16));\n        } else {\n            loserSoldierLossesPercentage = (45 +\n                (outcomeModifierForLoserSoldiers % 21));\n            loserTankLossesPercentage = (45 +\n                (outcomeModifierForLoserTanks % 16));\n        }\n        return (loserSoldierLossesPercentage, loserTankLossesPercentage);\n    }\n\n    function attackVictory(\n        uint256 battleId\n    ) public view returns (uint256, uint256, uint256, uint256) {\n        (\n            uint256 winnerSoldierLossesPercentage,\n            uint256 winnerTankLossesPercentage,\n            uint256 loserSoldierLossesPercentage,\n            uint256 loserTankLossesPercentage\n        ) = getPercentageLosses(battleId);\n        uint256 attackerSoldiers = groundBattleIdToAttackerForces[battleId]\n            .soldierCount;\n        uint256 attackerTanks = groundBattleIdToAttackerForces[battleId]\n            .tankCount;\n        uint256 defenderSoldiers = groundBattleIdToDefenderForces[battleId]\n            .soldierCount;\n        uint256 defenderTanks = groundBattleIdToDefenderForces[battleId]\n            .tankCount;\n        uint256 defenderSoldierLosses = ((defenderSoldiers *\n            loserSoldierLossesPercentage) / 100);\n        uint256 defenderTankLosses = ((defenderTanks *\n            loserTankLossesPercentage) / 100);\n        uint256 attackerSoldierLosses = ((attackerSoldiers *\n            winnerSoldierLossesPercentage) / 100);\n        uint256 attackerTankLosses = ((attackerTanks *\n            winnerTankLossesPercentage) / 100);\n        if (attackerSoldierLosses > (defenderSoldierLosses / 2)) {\n            attackerSoldierLosses = (defenderSoldierLosses / 2);\n        }\n        if (attackerTankLosses > (defenderTankLosses / 2)) {\n            attackerTankLosses = (defenderTankLosses / 2);\n        }\n        return (\n            attackerSoldierLosses,\n            attackerTankLosses,\n            defenderSoldierLosses,\n            defenderTankLosses\n        );\n    }\n\n    function defenseVictory(\n        uint256 battleId\n    ) public view returns (uint256, uint256, uint256, uint256) {\n        (\n            uint256 winnerSoldierLossesPercentage,\n            uint256 winnerTankLossesPercentage,\n            uint256 loserSoldierLossesPercentage,\n            uint256 loserTankLossesPercentage\n        ) = getPercentageLosses(battleId);\n        uint256 attackerSoldiers = groundBattleIdToAttackerForces[battleId]\n            .soldierCount;\n        uint256 attackerTanks = groundBattleIdToAttackerForces[battleId]\n            .tankCount;\n        uint256 defenderSoldiers = groundBattleIdToDefenderForces[battleId]\n            .soldierCount;\n        uint256 defenderTanks = groundBattleIdToDefenderForces[battleId]\n            .tankCount;\n        uint256 attackerSoldierLosses = ((attackerSoldiers *\n            loserSoldierLossesPercentage) / 100);\n        uint256 attackerTankLosses = ((attackerTanks *\n            loserTankLossesPercentage) / 100);\n        uint256 defenderSoldierLosses = ((defenderSoldiers *\n            winnerSoldierLossesPercentage) / 100);\n        uint256 defenderTankLosses = ((defenderTanks *\n            winnerTankLossesPercentage) / 100);\n        if (defenderSoldierLosses > (attackerSoldierLosses / 2)) {\n            defenderSoldierLosses = (attackerSoldierLosses / 2);\n        }\n        if (defenderTankLosses > (attackerTankLosses / 2)) {\n            defenderTankLosses = (attackerTankLosses / 2);\n        }\n        return (\n            attackerSoldierLosses,\n            attackerTankLosses,\n            defenderSoldierLosses,\n            defenderTankLosses\n        );\n    }\n\n    function collectSpoils(uint256 battleId, uint256 attackerId) internal {\n        uint256 defenderId = groundBattleIdToDefenderForces[battleId].countryId;\n        uint256[] memory randomWords = s_requestIndexToRandomWords[battleId];\n        uint256 randomLandMiles;\n        uint256 randomInfrastructure;\n        uint256 attackType = groundBattleIdToAttackerForces[battleId]\n            .attackType;\n        uint256 fobCount = imp2.getForwardOperatingBaseCount(attackerId);\n        if (attackType == 1) {\n            randomLandMiles = (1 + fobCount + (randomWords[6] % 3));\n            randomInfrastructure = (1 + fobCount + ((randomWords[7]) % 3));\n        } else if (attackType == 2) {\n            randomLandMiles = (2 + fobCount + (randomWords[6] % 3));\n            randomInfrastructure = (2 + fobCount + ((randomWords[7]) % 3));\n        } else if (attackType == 3) {\n            randomLandMiles = (3 + fobCount + (randomWords[6] % 4));\n            randomInfrastructure = (3 + fobCount + ((randomWords[7]) % 4));\n        } else if (attackType == 4) {\n            randomLandMiles = (4 + fobCount + (randomWords[6] % 5));\n            randomInfrastructure = (4 + fobCount + ((randomWords[7]) % 5));\n        }\n        uint256 attackerTech = inf.getTechnologyCount(attackerId);\n        uint256 defenderTech = inf.getTechnologyCount(defenderId);\n        uint256 multiple = (attackerTech / defenderTech);\n        if (multiple > 5) {\n            multiple = 5;\n        }\n        console.log(\"MULTIPLE\", multiple);\n        randomLandMiles = (randomLandMiles * multiple);\n        randomInfrastructure = (randomInfrastructure * multiple);\n        console.log(\"LAND MILES\", randomLandMiles);\n        console.log(\"INFRASTRUCTURE\", randomInfrastructure);\n        inf.transferLandAndInfrastructure(\n            randomLandMiles,\n            randomInfrastructure,\n            attackerId,\n            defenderId\n        );\n    }\n}\n\n\n"
    },
    "contracts/Improvements.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./Treasury.sol\";\nimport \"./Navy.sol\";\nimport \"./Forces.sol\";\nimport \"./Wonders.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Resources.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"hardhat/console.sol\";\n\n///@title ImprovementsContract1\n///@author OxSnosh\n///@notice this contract will allow a nation owner to buy certain improvements\ncontract ImprovementsContract1 is Ownable {\n    address public treasury;\n    address public improvements2;\n    address public improvements3;\n    address public improvements4;\n    address public wonders1;\n    address public navy;\n    address public additionalNavy;\n    address public countryMinter;\n    address public infrastructure;\n    uint256 public airportCost = 100000 * (10 ** 18);\n    uint256 public bankCost = 100000 * (10 ** 18);\n    uint256 public barracksCost = 50000 * (10 ** 18);\n    uint256 public borderFortificationCost = 125000 * (10 ** 18);\n    uint256 public borderWallCost = 60000 * (10 ** 18);\n    uint256 public bunkerCost = 200000 * (10 ** 18);\n    uint256 public casinoCost = 100000 * (10 ** 18);\n    uint256 public churchCost = 40000 * (10 ** 18);\n    uint256 public clinicCost = 50000 * (10 ** 18);\n    uint256 public drydockCost = 100000 * (10 ** 18);\n    uint256 public factoryCost = 150000 * (10 ** 18);\n\n    WondersContract1 won1;\n    CountryMinter mint;\n    TreasuryContract tres;\n    InfrastructureContract inf;\n\n    struct Improvements1 {\n        uint256 improvementCount;\n        //Airport\n        //$100,000\n        //DONE //reduces aircraft cost -2%\n        //DONE //reduces aircraft upkeep cost -2%\n        //Limit 3\n        uint256 airportCount;\n        //Bank\n        //$100,000\n        //DONE //population income +7%\n        uint256 bankCount;\n        //Barracks\n        //$50,000\n        //DONE //increases soldier efficiency +10%\n        //DONE //reduces soldier upkeep -10%\n        uint256 barracksCount;\n        //Border Fortifications\n        //$125,000\n        //DONE //Raises effectiveness of defending soldiers +2%\n        //DONE //reduces max deployment -2%\n        //Requires maintaining a border wall for each Border Fortification\n        //Limit 3\n        //Cannot own if forward operating base is owned\n        //Collection required to delete\n        uint256 borderFortificationCount;\n        //Border Walls\n        //$60,000\n        //DONE //Decreases citizen count by -2%\n        //DONE //increases population happiness +2,\n        //DONE //Improves environment +1\n        //DONE //Reduces the number of criminals in a nation 1% for each Border Wall.\n        //Border Walls may only be purchased one at a time.\n        uint256 borderWallCount;\n        //Bunker\n        //$200,000\n        //DONE //Reduces infrastructure damage from [[aircraft,]] cruise missiles, and nukes -3%\n        //Requires maintaining a Barracks for each Bunker.\n        //Limit 5\n        //Cannot build if Munitions Factory or Forward Operating Base is owned.\n        //Collection required to delete\n        uint256 bunkerCount;\n        //Casino\n        //$100,000\n        //DONE //Increases happiness by 1.5,\n        //DONE //decreases citizen income by 1%\n        //DONE //-25 to crime prevention score.\n        //Limit 2.\n        uint256 casinoCount;\n        //Church\n        //$40,000\n        //DONE //Increases population happiness +1.\n        uint256 churchCount;\n        //Clinic\n        //$50,000\n        //DONE //Increases population count by 2%\n        //Purchasing 2 or more clinics allows you to purchase hospitals.\n        //This improvement may not be destroyed if it is supporting a hospital until the hospital is first destroyed.\n        uint256 clinicCount;\n        //Drydock\n        //$100,000\n        //Allows nations to build and maintain navy Corvettes, Battleships, Cruisers, and Destroyers\n        //Increases the number of each of these types of ships that a nation can support +1.\n        //This improvement may not be destroyed if it is supporting navy vessels until those navy vessels are first destroyed.\n        //requires Harbor\n        uint256 drydockCount;\n        //Factory\n        //$150,000\n        //DONE //Decreases cost of cruise missiles -5%\n        //DONE //decreases tank cost -10%,\n        //DONE //reduces initial infrastructure purchase cost -8%.\n        uint256 factoryCount;\n    }\n\n    mapping(uint256 => Improvements1) public idToImprovements1;\n\n    event Improvement1Purchased(\n        uint256 indexed countryId,\n        uint256 indexed improvementId,\n        uint256 indexed amount\n    );\n\n    event Improvement1Deleted(\n        uint256 indexed countryId,\n        uint256 indexed improvementId,\n        uint256 indexed amount\n    );\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _treasury,\n        address _improvements2,\n        address _improvements3,\n        address _improvements4,\n        address _navy,\n        address _additionalNavy,\n        address _countryMinter,\n        address _wonders1,\n        address _infrastructure\n    ) public onlyOwner {\n        treasury = _treasury;\n        tres = TreasuryContract(_treasury);\n        improvements2 = _improvements2;\n        improvements3 = _improvements3;\n        improvements4 = _improvements4;\n        navy = _navy;\n        additionalNavy = _additionalNavy;\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n    }\n\n    modifier approvedAddress() {\n        require(\n            msg.sender == improvements2 ||\n                msg.sender == improvements3 ||\n                msg.sender == improvements4,\n            \"Unable to call\"\n        );\n        _;\n    }\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"function only callable by countryMinter contract\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable by the countryMinter contract\n    ///@dev this function will initialize the struct to store the info about the minted nations improvements\n    ///@notice this function will allow each minted nation to buy imoprovements\n    ///@param id this is the nation ID for the nation being minted\n    function generateImprovements(uint256 id) public onlyCountryMinter {\n        Improvements1 memory newImprovements1 = Improvements1(\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        );\n        idToImprovements1[id] = newImprovements1;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of an airport\n    function updateAirportCost(uint256 newPrice) public onlyOwner {\n        airportCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a bank\n    function updateBankCost(uint256 newPrice) public onlyOwner {\n        bankCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a barracks\n    function updateBarracksCost(uint256 newPrice) public onlyOwner {\n        barracksCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a border fortification\n    function updateBorderFortificationCost(uint256 newPrice) public onlyOwner {\n        borderFortificationCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a border wall\n    function updateBorderWallCost(uint256 newPrice) public onlyOwner {\n        borderWallCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a bunker\n    function updateBunkerCost(uint256 newPrice) public onlyOwner {\n        bunkerCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a casino\n    function updateCasinoCost(uint256 newPrice) public onlyOwner {\n        casinoCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a church\n    function updateChurchCost(uint256 newPrice) public onlyOwner {\n        churchCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a clinic\n    function updateClinicCost(uint256 newPrice) public onlyOwner {\n        clinicCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a drydock\n    function updateDrydockCost(uint256 newPrice) public onlyOwner {\n        drydockCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a factory\n    function updateFactoryCost(uint256 newPrice) public onlyOwner {\n        factoryCost = newPrice;\n    }\n\n    ///@dev this function will allow the caller to return the cost of an improvement\n    ///@return airportCost this will be the cost of an airport\n    ///@return bankCost this will be the cost of a bank...\n    function getCost1()\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            airportCost,\n            bankCost,\n            barracksCost,\n            borderFortificationCost,\n            borderWallCost,\n            bunkerCost,\n            casinoCost,\n            churchCost,\n            clinicCost,\n            drydockCost,\n            factoryCost\n        );\n    }\n\n    ///@dev this is a public view function that will return the number of improvements a nation owns\n    ///@notice this function will return the number of improvements a nation owns\n    ///@param id this is the nation ID of the nation being queried\n    ///@return count this is the number of improvements for a given nation\n    function getImprovementCount(\n        uint256 id\n    ) public view returns (uint256 count) {\n        count = idToImprovements1[id].improvementCount;\n        return count;\n    }\n\n    ///@dev this is a publiv function that is only callable from the other improvement contracts\n    ///@notice this function will incrase the number of improvements for a nation when improvements are purchased\n    ///@param id this is the ID for the nation purchasing improvements\n    ///@param newCount is the updated total of improvements for a given nation\n    function updateImprovementCount(\n        uint256 id,\n        uint256 newCount\n    ) public approvedAddress {\n        idToImprovements1[id].improvementCount = newCount;\n    }\n\n    function checkCitzenCountForImprovementPurchase(\n        uint256 id,\n        uint256 amount\n    ) public view returns (bool) {\n        bool possible = false;\n        (uint256 citizens, ) = inf.getTaxablePopulationCount(id);\n        uint256 improvementCount = idToImprovements1[id].improvementCount;\n        require(\n            ((citizens / 1000) >= (improvementCount + amount)),\n            \"population too low to purchase improvement\"\n        );\n        possible = true;\n        return (possible);\n    }\n\n    ///@dev this is a public function that allows a nation owner to purchase improvements\n    ///@dev this function is only callable by the nation owner\n    ///@notice this function will allow a nation owner to purchase certain improvements\n    ///@param amount is the number of improvements being purchased\n    ///@param countryId is the nation purchasing improvements\n    /**\n     * @param improvementId this will determine which improvement is being purchased\n     * 1 = airport\n     * 2 = bank\n     * 3 = barracks\n     * 4 = border fortification\n     * 5 = border wall\n     * 6 = bunker\n     * 7 = casino\n     * 8 = church\n     * 9 = clinic\n     * 10 = drydock\n     * 11 = factory\n     */\n    function buyImprovement1(\n        uint256 amount,\n        uint256 countryId,\n        uint256 improvementId\n    ) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(improvementId <= 11, \"Invalid improvement ID\");\n        uint256 daysSince = tres.getDaysSinceLastBillsPaid(countryId);\n        require(daysSince == 0, \"must pay bills before buying improvements\");\n        bool populationCheck = checkCitzenCountForImprovementPurchase(\n            countryId,\n            amount\n        );\n        require(\n            populationCheck == true,\n            \"population not high enough for purchase\"\n        );\n        uint256 balance = TreasuryContract(treasury).checkBalance(countryId);\n        if (improvementId == 1) {\n            uint256 purchasePrice = airportCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements1[countryId].airportCount;\n            require((existingCount + amount) <= 3, \"Cannot own more than 3\");\n            idToImprovements1[countryId].airportCount += amount;\n            idToImprovements1[countryId].improvementCount += amount;\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 2) {\n            uint256 purchasePrice = bankCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements1[countryId].bankCount;\n            uint256 maxAmount = 5;\n            bool federalReserve = won1.getFederalReserve(countryId);\n            if (federalReserve) {\n                maxAmount = 7;\n            }\n            require(\n                (existingCount + amount) <= maxAmount,\n                \"Cannot own more than 5\"\n            );\n            idToImprovements1[countryId].bankCount += amount;\n            idToImprovements1[countryId].improvementCount += amount;\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 3) {\n            uint256 purchasePrice = barracksCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements1[countryId].barracksCount;\n            require((existingCount + amount) <= 3, \"Cannot own more than 3\");\n            idToImprovements1[countryId].barracksCount += amount;\n            idToImprovements1[countryId].improvementCount += amount;\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 4) {\n            uint256 purchasePrice = borderFortificationCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements1[countryId]\n                .borderFortificationCount;\n            require((existingCount + amount) <= 3, \"Cannot own more than 3\");\n            uint256 borderWallAmount = idToImprovements1[countryId]\n                .borderWallCount;\n            require(\n                (existingCount + amount) <= borderWallAmount,\n                \"Must own a border wall for every fortification\"\n            );\n            uint256 fobCount = ImprovementsContract2(improvements2)\n                .getForwardOperatingBaseCount(countryId);\n            require(\n                fobCount == 0,\n                \"Cannot own if forward operating base is owned\"\n            );\n            idToImprovements1[countryId].borderFortificationCount += amount;\n            idToImprovements1[countryId].improvementCount += amount;\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 5) {\n            require(\n                amount == 1,\n                \"Boarder walls can only be purchased 1 at a time\"\n            );\n            uint256 purchasePrice = borderWallCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements1[countryId]\n                .borderWallCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements1[countryId].borderWallCount += amount;\n            idToImprovements1[countryId].improvementCount += amount;\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 6) {\n            uint256 purchasePrice = bunkerCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements1[countryId].bunkerCount;\n            require((existingCount + amount) <= 3, \"Cannot own more than 3\");\n            uint256 barracksAmount = idToImprovements1[countryId].barracksCount;\n            require(\n                (existingCount + amount) <= barracksAmount,\n                \"Must own a barracks for every bunker\"\n            );\n            uint256 fobCount = ImprovementsContract2(improvements2)\n                .getForwardOperatingBaseCount(countryId);\n            require(\n                fobCount == 0,\n                \"Cannot own if forward operating base is owned\"\n            );\n            uint256 munitionsFactoryCount = ImprovementsContract4(improvements4)\n                .getMunitionsFactoryCount(countryId);\n            require(\n                munitionsFactoryCount == 0,\n                \"Cannot own if munitions factory is owned\"\n            );\n            idToImprovements1[countryId].bunkerCount += amount;\n            idToImprovements1[countryId].improvementCount += amount;\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 7) {\n            uint256 purchasePrice = casinoCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements1[countryId].casinoCount;\n            require((existingCount + amount) <= 2, \"Cannot own more than 2\");\n            idToImprovements1[countryId].casinoCount += amount;\n            idToImprovements1[countryId].improvementCount += amount;\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 8) {\n            uint256 purchasePrice = churchCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements1[countryId].churchCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements1[countryId].churchCount += amount;\n            idToImprovements1[countryId].improvementCount += amount;\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 9) {\n            uint256 purchasePrice = clinicCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements1[countryId].clinicCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements1[countryId].clinicCount += amount;\n            idToImprovements1[countryId].improvementCount += amount;\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 10) {\n            uint256 purchasePrice = drydockCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements1[countryId].drydockCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            uint256 harborCount = ImprovementsContract2(improvements2)\n                .getHarborCount(countryId);\n            require(harborCount > 0, \"Must own a harbor first\");\n            idToImprovements1[countryId].drydockCount += amount;\n            idToImprovements1[countryId].improvementCount += amount;\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else {\n            uint256 purchasePrice = factoryCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements1[countryId].factoryCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements1[countryId].factoryCount += amount;\n            idToImprovements1[countryId].improvementCount += amount;\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        }\n        emit Improvement1Purchased(countryId, improvementId, amount);\n    }\n\n    ///@dev this is a public function that allows a nation owner to delete improvements\n    ///@dev this function is only callable by the nation owner\n    ///@notice this function will allow a nation owner to delete certain improvements\n    ///@param amount is the number of improvements being deleted\n    ///@param countryId is the nation deleting improvements\n    /**\n     * @param improvementId this will determine which improvement is being deleted\n     * 1 = airport\n     * 2 = bank\n     * 3 = barracks\n     * 4 = border fortification\n     * 5 = border wall\n     * 6 = bunker\n     * 7 = casino\n     * 8 = church\n     * 9 = clinic\n     * 10 = drydock\n     * 11 = factory\n     */\n    function deleteImprovement1(\n        uint256 amount,\n        uint256 countryId,\n        uint256 improvementId\n    ) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(improvementId <= 11, \"Invalid improvement ID\");\n        if (improvementId == 1) {\n            uint256 existingCount = idToImprovements1[countryId].airportCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements1[countryId].airportCount -= amount;\n            idToImprovements1[countryId].improvementCount -= amount;\n        } else if (improvementId == 2) {\n            uint256 existingCount = idToImprovements1[countryId].bankCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements1[countryId].bankCount -= amount;\n            idToImprovements1[countryId].improvementCount -= amount;\n        } else if (improvementId == 3) {\n            uint256 existingCount = idToImprovements1[countryId].barracksCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements1[countryId].barracksCount -= amount;\n            idToImprovements1[countryId].improvementCount -= amount;\n        } else if (improvementId == 4) {\n            uint256 existingCount = idToImprovements1[countryId]\n                .borderFortificationCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements1[countryId].borderFortificationCount -= amount;\n            idToImprovements1[countryId].improvementCount -= amount;\n        } else if (improvementId == 5) {\n            uint256 existingCount = idToImprovements1[countryId]\n                .borderWallCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements1[countryId].borderWallCount -= amount;\n            idToImprovements1[countryId].improvementCount -= amount;\n        } else if (improvementId == 6) {\n            uint256 existingCount = idToImprovements1[countryId].bunkerCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements1[countryId].bunkerCount -= amount;\n            idToImprovements1[countryId].improvementCount -= amount;\n        } else if (improvementId == 7) {\n            uint256 existingCount = idToImprovements1[countryId].casinoCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements1[countryId].casinoCount -= amount;\n            idToImprovements1[countryId].improvementCount -= amount;\n        } else if (improvementId == 8) {\n            uint256 existingCount = idToImprovements1[countryId].churchCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements1[countryId].churchCount -= amount;\n            idToImprovements1[countryId].improvementCount -= amount;\n        } else if (improvementId == 9) {\n            uint256 existingCount = idToImprovements1[countryId].clinicCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            uint256 hospitalCount = ImprovementsContract2(improvements2)\n                .getHospitalCount(countryId);\n            require(\n                hospitalCount == 0,\n                \"Cannot delete while nation owns a hospital\"\n            );\n            idToImprovements1[countryId].clinicCount -= amount;\n            idToImprovements1[countryId].improvementCount -= amount;\n        } else if (improvementId == 10) {\n            uint256 existingCount = idToImprovements1[countryId].drydockCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            uint256 vesselCount = AdditionalNavyContract(additionalNavy)\n                .getVesselCountForDrydock(countryId);\n            require(\n                vesselCount == 0,\n                \"Cannot delete drydock while it supports vessels\"\n            );\n            idToImprovements1[countryId].drydockCount -= amount;\n            idToImprovements1[countryId].improvementCount -= amount;\n        } else {\n            uint256 existingCount = idToImprovements1[countryId].factoryCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements1[countryId].factoryCount -= amount;\n            idToImprovements1[countryId].improvementCount -= amount;\n        }\n        emit Improvement1Deleted(countryId, improvementId, amount);\n    }\n\n    ///@dev this is a public view function that will return the number of airports for a given nation\n    ///@notice this function will return the number of airports a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of airports a given nation owns\n    function getAirportCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 airportAmount = idToImprovements1[countryId].airportCount;\n        return airportAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of barracks for a given nation\n    ///@notice this function will return the number of barracks a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of barracks a given nation owns\n    function getBarracksCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 barracksAmount = idToImprovements1[countryId].barracksCount;\n        return barracksAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of border fortifications for a given nation\n    ///@notice this function will return the number of border fortifications a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of border fortifications a given nation owns\n    function getBorderFortificationCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 borderFortificationAmount = idToImprovements1[countryId]\n            .borderFortificationCount;\n        return borderFortificationAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of border walls for a given nation\n    ///@notice this function will return the number of border walls a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of border walls a given nation owns\n    function getBorderWallCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 borderWallAmount = idToImprovements1[countryId].borderWallCount;\n        return borderWallAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of banks for a given nation\n    ///@notice this function will return the number of banks a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of banks a given nation owns\n    function getBankCount(uint256 countryId) public view returns (uint256) {\n        uint256 count = idToImprovements1[countryId].bankCount;\n        return count;\n    }\n\n    ///@dev this is a public view function that will return the number of bunkers for a given nation\n    ///@notice this function will return the number of bunkers a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of bunkers a given nation owns\n    function getBunkerCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 bunkerAmount = idToImprovements1[countryId].bunkerCount;\n        return bunkerAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of casinos for a given nation\n    ///@notice this function will return the number of casinos a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of casinos a given nation owns\n    function getCasinoCount(uint256 countryId) public view returns (uint256) {\n        uint256 count = idToImprovements1[countryId].casinoCount;\n        return count;\n    }\n\n    ///@dev this is a public view function that will return the number of churches for a given nation\n    ///@notice this function will return the number of churches a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of churches a given nation owns\n    function getChurchCount(uint256 countryId) public view returns (uint256) {\n        uint256 count = idToImprovements1[countryId].churchCount;\n        return count;\n    }\n\n    ///@dev this is a public view function that will return the number of drydocks for a given nation\n    ///@notice this function will return the number of drydocks a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of drydocks a given nation owns\n    function getDrydockCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 drydockAmount = idToImprovements1[countryId].drydockCount;\n        return drydockAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of clinics for a given nation\n    ///@notice this function will return the number of clinics a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of clinics a given nation owns\n    function getClinicCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 clinicAmount = idToImprovements1[countryId].clinicCount;\n        return clinicAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of factories for a given nation\n    ///@notice this function will return the number of factories a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of factories a given nation owns\n    function getFactoryCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 factoryAmount = idToImprovements1[countryId].factoryCount;\n        return factoryAmount;\n    }\n}\n\n///@title ImprovementsContract2\n///@author OxSnosh\n///@notice this contract will allow a nation owner to buy certain improvements\ncontract ImprovementsContract2 is Ownable {\n    address public treasury;\n    address public improvements1;\n    address public forces;\n    address public wonders1;\n    address public countryMinter;\n    address public resources;\n    address public spies;\n    uint256 public foreignMinistryCost = 120000 * (10 ** 18);\n    uint256 public forwardOperatingBaseCost = 125000 * (10 ** 18);\n    uint256 public guerillaCampCost = 20000 * (10 ** 18);\n    uint256 public harborCost = 200000 * (10 ** 18);\n    uint256 public hospitalCost = 180000 * (10 ** 18);\n    uint256 public intelligenceAgencyCost = 38500 * (10 ** 18);\n    uint256 public jailCost = 25000 * (10 ** 18);\n    uint256 public laborCampCost = 150000 * (10 ** 18);\n\n    WondersContract1 won1;\n    CountryMinter mint;\n    TreasuryContract tres;\n    ResourcesContract res;\n    SpyContract spy;\n\n    struct Improvements2 {\n        //Foreign Ministry\n        //$120,000\n        //DONE //Increases population income by 5%\n        //Opens +1 extra foreign aid slot.\n        //Limit one foreign ministry per nation\n        uint256 foreignMinistryCount;\n        //Forward Operating Base\n        //$125,000\n        //DONE //Increases spoils from ground attack damage 2% for balance\n        //DONE //Increases spoils from ground attack damage +1/fob for Land and Tech;\n        //DONE //Reduces effectiveness of one's own defending soldiers -3%.\n        //Requires maintaining a Barracks for each Forward Operating Base.\n        //Limit 2.\n        //Cannot own if Border Fortifications or Bunker is owned.\n        //Collection required to delete.\n        uint256 forwardOperatingBaseCount;\n        //Guerilla Camp\n        //$20,000\n        //DONE //Increases soldier efficiency +35%,\n        //DONE //reduces soldier upkeep cost -10%\n        //DONE //reduces citizen income -8%.\n        uint256 guerillaCampCount;\n        //Harbor\n        //$200,000\n        //DONE //Increases population income by 1%.\n        //DONE //Opens +1 extra trade slot\n        //Limit one harbor per nation.\n        //This improvement may not be destroyed if it is supporting trade agreements or navy vessels until those trade agreements and navy vessels are first removed.\n        uint256 harborCount;\n        //Hospital\n        //$180,000\n        //DONE //Increases population count by 6%.\n        //Need 2 clinics for a hospital.\n        //Limit one hospital per nation.\n        //Nations must retain at least one hospital if that nation owns a Universal Health Care wonder.\n        uint256 hospitalCount;\n        //Intelligence Agency\n        //$38,500\n        //DONE //Increases happiness for tax rates greater than 23% +1\n        //DONE //Each Intelligence Agency allows nations to purchase + 100 spies\n        //This improvement may not be destroyed if it is supporting spies until those spies are first destroyed.\n        uint256 intelligenceAgencyCount;\n        //Jail\n        //$25,000\n        //DONE //Incarcerates up to 500 criminals\n        //Limit 5\n        uint256 jailCount;\n        //Labor Camp\n        //$150,000\n        //DONE //Reduces infrastructure upkeep costs -10%\n        //DONE //reduces population happiness -1.\n        //DONE //Incarcerates up to 200 criminals per Labor Camp.\n        uint256 laborCampCount;\n    }\n\n    mapping(uint256 => Improvements2) public idToImprovements2;\n\n    event Improvement2Purchased(\n        uint256 indexed countryId,\n        uint256 indexed improvementId,\n        uint256 indexed amount\n    );\n\n    event Improvement2Deleted(\n        uint256 indexed countryId,\n        uint256 indexed improvementId,\n        uint256 indexed amount\n    );\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _treasury,\n        address _forces,\n        address _wonders1,\n        address _countryMinter,\n        address _improvements1,\n        address _resources,\n        address _spies\n    ) public onlyOwner {\n        treasury = _treasury;\n        tres = TreasuryContract(_treasury);\n        forces = _forces;\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        improvements1 = _improvements1;\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        spies = _spies;\n        spy = SpyContract(_spies);\n    }\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"function only callable by countryMinter contract\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable by the countryMinter contract\n    ///@dev this function will initialize the struct to store the info about the minted nations improvements\n    ///@notice this function will allow each minted nation to buy imoprovements\n    ///@param id this is the nation ID for the nation being minted\n    function generateImprovements(uint256 id) public onlyCountryMinter {\n        Improvements2 memory newImprovements2 = Improvements2(\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        );\n        idToImprovements2[id] = newImprovements2;\n    }\n\n    ///@dev this function will allow the caller to return the cost of an improvement\n    ///@return foreignMinistryCost this will be the cost of a foreign ministry\n    ///@return forwardOperatingBaseCost this will be the cost of a forward operating base...\n    function getCost2()\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            foreignMinistryCost,\n            forwardOperatingBaseCost,\n            guerillaCampCost,\n            harborCost,\n            hospitalCost,\n            intelligenceAgencyCost,\n            jailCost,\n            laborCampCost\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a foreign ministry\n    function updateForeignMinistryCost(uint256 newPrice) public onlyOwner {\n        foreignMinistryCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a forward operating base\n    function updateForwardOperatingBaseCost(uint256 newPrice) public onlyOwner {\n        forwardOperatingBaseCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a guerilla camp\n    function updateGuerillaCampCost(uint256 newPrice) public onlyOwner {\n        guerillaCampCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a harbor\n    function updateHarborCost(uint256 newPrice) public onlyOwner {\n        harborCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a hospital\n    function updateHospitalCost(uint256 newPrice) public onlyOwner {\n        hospitalCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of an intel agency\n    function updateIntelligenceAgencyCost(uint256 newPrice) public onlyOwner {\n        intelligenceAgencyCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a jail\n    function updateJailCost(uint256 newPrice) public onlyOwner {\n        jailCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a labor camp\n    function updateLaborCampCost(uint256 newPrice) public onlyOwner {\n        laborCampCost = newPrice;\n    }\n\n    ///@dev this is a public function that allows a nation owner to purchase improvements\n    ///@dev this function is only callable by the nation owner\n    ///@notice this function will allow a nation owner to purchase certain improvements\n    ///@param amount is the number of improvements being purchased\n    ///@param countryId is the nation purchasing improvements\n    /**\n     * @param improvementId this will determine which improvement is being purchased\n     * 1 = foreign ministry\n     * 2 = forward operating base\n     * 3 = guerilla camp\n     * 4 = harbor\n     * 5 = hospital\n     * 6 = intel agency\n     * 7 = jail\n     * 8 = labor camp\n     */\n    function buyImprovement2(\n        uint256 amount,\n        uint256 countryId,\n        uint256 improvementId\n    ) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 daysSince = tres.getDaysSinceLastBillsPaid(countryId);\n        require(daysSince == 0, \"must pay bills before buying improvements\");\n        bool populationCheck = ImprovementsContract1(improvements1)\n            .checkCitzenCountForImprovementPurchase(countryId, amount);\n        require(\n            populationCheck == true,\n            \"population not high enough for purchase\"\n        );\n        require(improvementId <= 12, \"Invalid improvement ID\");\n        uint256 balance = TreasuryContract(treasury).checkBalance(countryId);\n        if (improvementId == 1) {\n            uint256 purchasePrice = foreignMinistryCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements2[countryId]\n                .foreignMinistryCount;\n            require((existingCount + amount) <= 1, \"Cannot own more than 1\");\n            idToImprovements2[countryId].foreignMinistryCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 2) {\n            uint256 purchasePrice = forwardOperatingBaseCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements2[countryId]\n                .forwardOperatingBaseCount;\n            require((existingCount + amount) <= 2, \"Cannot own more than 2\");\n            uint256 borderFortificationAmount = ImprovementsContract1(\n                improvements1\n            ).getBorderFortificationCount(countryId);\n            require(\n                borderFortificationAmount == 0,\n                \"Cannot own if border fortification is owned\"\n            );\n            uint256 bunkerAmount = ImprovementsContract1(improvements1)\n                .getBunkerCount(countryId);\n            require(bunkerAmount == 0, \"Cannot own if bunker is owned\");\n            idToImprovements2[countryId].forwardOperatingBaseCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 3) {\n            uint256 purchasePrice = guerillaCampCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements2[countryId]\n                .guerillaCampCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements2[countryId].guerillaCampCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 4) {\n            uint256 purchasePrice = harborCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements2[countryId].harborCount;\n            require((existingCount + amount) <= 1, \"Cannot own more than 1\");\n            idToImprovements2[countryId].harborCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 5) {\n            uint256 purchasePrice = hospitalCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements2[countryId].hospitalCount;\n            require((existingCount + amount) <= 1, \"Cannot own more than 1\");\n            uint256 clinicCount = ImprovementsContract1(improvements1)\n                .getClinicCount(countryId);\n            require(clinicCount >= 2, \"Need to own at least 2 clinics\");\n            idToImprovements2[countryId].hospitalCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 6) {\n            uint256 purchasePrice = intelligenceAgencyCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements2[countryId]\n                .intelligenceAgencyCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements2[countryId].intelligenceAgencyCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 7) {\n            uint256 purchasePrice = jailCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements2[countryId].jailCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements2[countryId].jailCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 8) {\n            uint256 purchasePrice = laborCampCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements2[countryId].laborCampCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements2[countryId].laborCampCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        }\n        emit Improvement2Purchased(countryId, improvementId, amount);\n    }\n\n    ///@dev this is a public function that allows a nation owner to delete improvements\n    ///@dev this function is only callable by the nation owner\n    ///@notice this function will allow a nation owner to delete certain improvements\n    ///@param amount is the number of improvements being deleted\n    ///@param countryId is the nation deleting improvements\n    /**\n     * @param improvementId this will determine which improvement is being deleted\n     * 1 = foreign ministry\n     * 2 = forward operating base\n     * 3 = guerilla camp\n     * 4 = harbor\n     * 5 = hospital\n     * 6 = intel agency\n     * 7 = jail\n     * 8 = labor camp\n     */\n    function deleteImprovement2(\n        uint256 amount,\n        uint256 countryId,\n        uint256 improvementId\n    ) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(improvementId <= 12, \"Invalid improvement ID\");\n        if (improvementId == 1) {\n            uint256 existingCount = idToImprovements2[countryId]\n                .foreignMinistryCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements2[countryId].foreignMinistryCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 2) {\n            uint256 existingCount = idToImprovements2[countryId]\n                .forwardOperatingBaseCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements2[countryId].forwardOperatingBaseCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 3) {\n            uint256 existingCount = idToImprovements2[countryId]\n                .guerillaCampCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements2[countryId].guerillaCampCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 4) {\n            uint256 existingCount = idToImprovements2[countryId].harborCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            uint256 drydockCount = ImprovementsContract1(improvements1)\n                .getDrydockCount(countryId);\n            require(\n                drydockCount == 0,\n                \"Cannot delete a drydock if it supports a harbor\"\n            );\n            //need a requirement that it cannot be deleted if it supports a trade agreement\n            uint256[] memory partners = res.getTradingPartners(countryId);\n            require(\n                partners.length <= 4,\n                \"Cannot delete, harbor supports a trade\"\n            );\n            idToImprovements2[countryId].harborCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 5) {\n            uint256 existingCount = idToImprovements2[countryId].hospitalCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements2[countryId].hospitalCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 6) {\n            uint256 existingCount = idToImprovements2[countryId]\n                .intelligenceAgencyCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            uint256 spyCount = spy.getSpyCount(countryId);\n            uint256 newIntelAgencyCount = existingCount - amount;\n            bool centralIntelAgency = won1.getCentralIntelligenceAgency(\n                countryId\n            );\n            uint256 baseSpyCount = 50;\n            if (centralIntelAgency) {\n                baseSpyCount = 300;\n            }\n            require(\n                spyCount <= (baseSpyCount + (newIntelAgencyCount * 100)),\n                \"You have too many spies to delete, each intel agency supports 100 spies\"\n            );\n            idToImprovements2[countryId].intelligenceAgencyCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 7) {\n            uint256 existingCount = idToImprovements2[countryId].jailCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements2[countryId].jailCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 8) {\n            uint256 existingCount = idToImprovements2[countryId].laborCampCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements2[countryId].laborCampCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        }\n        emit Improvement2Deleted(countryId, improvementId, amount);\n    }\n\n    ///@dev this is a public view function that will return the number of foreign ministries for a given nation\n    ///@notice this function will return the number of foreign ministries a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of foreign ministries a given nation owns\n    function getForeignMinistryCount(\n        uint256 countryId\n    ) public view returns (uint256) {\n        uint256 count = idToImprovements2[countryId].foreignMinistryCount;\n        return count;\n    }\n\n    ///@dev this is a public view function that will return the number of forward operating bases for a given nation\n    ///@notice this function will return the number of forward operating bases a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of forward operating bases a given nation owns\n    function getForwardOperatingBaseCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 fobCount = idToImprovements2[countryId]\n            .forwardOperatingBaseCount;\n        return fobCount;\n    }\n\n    ///@dev this is a public view function that will return the number of guerilla camps for a given nation\n    ///@notice this function will return the number of guerialls camps a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of guerilla camps a given nation owns\n    function getGuerillaCampCount(\n        uint256 countryId\n    ) public view returns (uint256) {\n        uint256 count = idToImprovements2[countryId].guerillaCampCount;\n        return count;\n    }\n\n    ///@dev this is a public view function that will return the number of harbors for a given nation\n    ///@notice this function will return the number of harbors a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of harbors a given nation owns\n    function getHarborCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 harborAmount = idToImprovements2[countryId].harborCount;\n        return harborAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of hospitals for a given nation\n    ///@notice this function will return the number of hospitals a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of hospitals a given nation owns\n    function getHospitalCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 hospitalAmount = idToImprovements2[countryId].hospitalCount;\n        return hospitalAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of intel agencies for a given nation\n    ///@notice this function will return the number of intel agencies a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of intel agencies a given nation owns\n    function getIntelAgencyCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 intelAgencyAmount = idToImprovements2[countryId]\n            .intelligenceAgencyCount;\n        return intelAgencyAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of jails for a given nation\n    ///@notice this function will return the number of jails a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of jails a given nation owns\n    function getJailCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 jailAmount = idToImprovements2[countryId].jailCount;\n        return jailAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of labor camps for a given nation\n    ///@notice this function will return the number of labor camps a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of labor camps a given nation owns\n    function getLaborCampCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 laborCampAmount = idToImprovements2[countryId].laborCampCount;\n        return laborCampAmount;\n    }\n}\n\n///@title ImprovementsContract3\n///@author OxSnosh\n///@notice this contract will allow a nation owner to buy certain improvements\ncontract ImprovementsContract3 is Ownable {\n    address public treasury;\n    address public improvements1;\n    address public improvements2;\n    address public navy;\n    address public additionalNavy;\n    address public countryMinter;\n    address public bonusResources;\n    address public wonder4;\n    uint256 public prisonCost = 200000 * (10 ** 18);\n    uint256 public radiationContainmentChamberCost = 200000 * (10 ** 18);\n    uint256 public redLightDistrictCost = 50000 * (10 ** 18);\n    uint256 public rehabilitationFacilityCost = 500000 * (10 ** 18);\n    uint256 public satteliteCost = 90000 * (10 ** 18);\n    uint256 public schoolCost = 85000 * (10 ** 18);\n    uint256 public shipyardCost = 100000 * (10 ** 18);\n    uint256 public stadiumCost = 110000 * (10 ** 18);\n    uint256 public universityCost = 180000 * (10 ** 18);\n\n    CountryMinter mint;\n    TreasuryContract tres;\n    BonusResourcesContract bonus;\n    WondersContract4 won4;\n\n    struct Improvements3 {\n\n        //Prison\n        //$200,000\n        //DONE //Incarcerates up to 5,000 criminals.\n        //Limit 5\n        uint256 prisonCount;\n        //RadiationContainmentChamber\n        //$200,000\n        //Lowers global radiation level that affects your nation by 20%.\n        //Requires maintaining Radiation Cleanup bonus resource to function\n        //Requires maintaining a Bunker for each Radiation Containment Chamber.\n        //Limit 2.\n        //Collection required to delete.\n        uint256 radiationContainmentChamberCount;\n        //RedLightDistrict\n        //$50,000\n        //DONE //Increases happiness by 1,\n        //DONE //penalizes environment by 0.5,\n        //DONE //-25 to crime prevention score\n        //Limit 2\n        uint256 redLightDistrictCount;\n        //Rehabilitation Facility\n        //$500,000\n        //Sends up to 500 criminals back into the citizen count\n        //Limit 5\n        uint256 rehabilitationFacilityCount;\n        //Satellite\n        //$90,000\n        //DONE //Increases effectiveness of cruise missiles used by your nation +10%.\n        //Nations must retain at least three satellites if that nation owns a Strategic Defense Initiative wonder\n        uint256 satelliteCount;\n        //School\n        //$85,000\n        //DONE //Increases population income by 5%\n        //DONE //increases literacy rate +1%\n        //Purchasing 3 or more schools allows you to purchase universities\n        //This improvement may not be destroyed if it is supporting universities until the universities are first destroyed.\n        uint256 schoolCount;\n        //Shipyard\n        //$100,000\n        //DONE //Allows nations to build and maintain navy Landing Ships, Frigates, Submarines, and Aircraft Carriers.\n        //Increases the number of each of these types of ships that a nation can support +1.\n        //This improvement may not be destroyed if it is supporting navy vessels until those navy vessels are first destroyed.\n        //Requires Harbor\n        uint256 shipyardCount;\n        //Stadium\n        //$110,000\n        //DONE //Increases population happiness + 3.\n        uint256 stadiumCount;\n        //University\n        //$180,000\n        //DONE //Increases population income by 8%\n        //DONE //reduces technology cost -10%\n        //DONE //increases literacy rate +3%.\n        //Three schools must be purchased before any universities can be purchased.\n        //Limit 2\n        uint256 universityCount;\n    }\n\n    mapping(uint256 => Improvements3) public idToImprovements3;\n\n    event Improvement3Purchased(\n        uint256 indexed countryId,\n        uint256 indexed improvementId,\n        uint256 indexed amount\n    );\n\n    event Improvement3Deleted(\n        uint256 indexed countryId,\n        uint256 indexed improvementId,\n        uint256 indexed amount\n    );\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _treasury,\n        address _additionalNavy,\n        address _improvements1,\n        address _improvements2,\n        address _countryMinter,\n        address _bonusResources,\n        address _wonder4\n    ) public onlyOwner {\n        treasury = _treasury;\n        tres = TreasuryContract(_treasury);\n        additionalNavy = _additionalNavy;\n        improvements1 = _improvements1;\n        improvements2 = _improvements2;\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        bonusResources = _bonusResources;\n        bonus = BonusResourcesContract(_bonusResources);\n        wonder4 = _wonder4;\n        won4 = WondersContract4(_wonder4);\n    }\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"function only callable by countryMinter contract\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable by the countryMinter contract\n    ///@dev this function will initialize the struct to store the info about the minted nations improvements\n    ///@notice this function will allow each minted nation to buy imoprovements\n    ///@param id this is the nation ID for the nation being minted\n    function generateImprovements(uint256 id) public onlyCountryMinter {\n        Improvements3 memory newImprovements3 = Improvements3(\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        );\n        idToImprovements3[id] = newImprovements3;\n    }\n\n    ///@dev this function will allow the caller to return the cost of an improvement\n    ///@return officeOfPropagandaCost this will be the cost of an office of propaganda\n    ///@return policeHeadquartersCost this will be the cost of a police headquarters...\n    function getCost3()\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            prisonCost,\n            radiationContainmentChamberCost,\n            redLightDistrictCost,\n            rehabilitationFacilityCost,\n            satteliteCost,\n            schoolCost,\n            shipyardCost,\n            stadiumCost,\n            universityCost\n        );\n    }\n\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a prison\n    function updatePrisonCost(uint256 newPrice) public onlyOwner {\n        prisonCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a radiatiion containment chamber\n    function updateRadiationContainmentChamberCost(\n        uint256 newPrice\n    ) public onlyOwner {\n        radiationContainmentChamberCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a red light district\n    function updateRedLightDistrictCost(uint256 newPrice) public onlyOwner {\n        redLightDistrictCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a rehab facility\n    function updateRehabilitationFacilityCost(\n        uint256 newPrice\n    ) public onlyOwner {\n        rehabilitationFacilityCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a satellite\n    function updateSatelliteCost(uint256 newPrice) public onlyOwner {\n        satteliteCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a school\n    function updateSchoolCost(uint256 newPrice) public onlyOwner {\n        schoolCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a shipyard\n    function updateShipyardCost(uint256 newPrice) public onlyOwner {\n        shipyardCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a stadium\n    function updateStadiumCost(uint256 newPrice) public onlyOwner {\n        stadiumCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a university\n    function updateUniversityCost(uint256 newPrice) public onlyOwner {\n        universityCost = newPrice;\n    }\n\n    ///@dev this is a public function that allows a nation owner to purchase improvements\n    ///@dev this function is only callable by the nation owner\n    ///@notice this function will allow a nation owner to purchase certain improvements\n    ///@param amount is the number of improvements being purchased\n    ///@param countryId is the nation purchasing improvements\n    /**\n     * @param improvementId this will determine which improvement is being purchased\n     * 1 = prison\n     * 2 = radiaton containment chambers\n     * 3 = red light district\n     * 4 = rehab facilities\n     * 5 = satellite\n     * 6 = school\n     * 7 = shipyard\n     * 8 = stadium\n     * 9 = university\n     */\n    function buyImprovement3(\n        uint256 amount,\n        uint256 countryId,\n        uint256 improvementId\n    ) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 daysSince = tres.getDaysSinceLastBillsPaid(countryId);\n        require(daysSince == 0, \"must pay bills before buying improvements\");\n        bool populationCheck = ImprovementsContract1(improvements1)\n            .checkCitzenCountForImprovementPurchase(countryId, amount);\n        require(\n            populationCheck == true,\n            \"population not high enough for purchase\"\n        );\n        require(improvementId <= 12, \"Invalid improvement ID\");\n        uint256 balance = TreasuryContract(treasury).checkBalance(countryId);\n        if (improvementId == 1) {\n            uint256 purchasePrice = prisonCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements3[countryId].prisonCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements3[countryId].prisonCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 2) {\n            uint256 purchasePrice = radiationContainmentChamberCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements3[countryId]\n                .radiationContainmentChamberCount;\n            require((existingCount + amount) <= 2, \"Cannot own more than 2\");\n            uint256 bunkerAmount = ImprovementsContract1(improvements1)\n                .getBunkerCount(countryId);\n            require(\n                (existingCount + amount) <= bunkerAmount,\n                \"Must own a bunker for each radiation containment chamber\"\n            );\n            bool radiationCleanup = bonus.viewRadiationCleanup(countryId);\n            require(\n                radiationCleanup,\n                \"nation must possess radiation cleanup bonus resource to purchase\"\n            );\n            idToImprovements3[countryId]\n                .radiationContainmentChamberCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 3) {\n            uint256 purchasePrice = redLightDistrictCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements3[countryId]\n                .redLightDistrictCount;\n            require((existingCount + amount) <= 2, \"Cannot own more than 2\");\n            idToImprovements3[countryId].redLightDistrictCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 4) {\n            uint256 purchasePrice = rehabilitationFacilityCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements3[countryId]\n                .rehabilitationFacilityCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements3[countryId].rehabilitationFacilityCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 5) {\n            uint256 purchasePrice = satteliteCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements3[countryId].satelliteCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements3[countryId].satelliteCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 6) {\n            uint256 purchasePrice = schoolCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements3[countryId].schoolCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements3[countryId].schoolCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 7) {\n            uint256 purchasePrice = shipyardCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements3[countryId].shipyardCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements3[countryId].shipyardCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 8) {\n            uint256 purchasePrice = stadiumCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements3[countryId].stadiumCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements3[countryId].stadiumCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else {\n            uint256 purchasePrice = universityCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements3[countryId]\n                .universityCount;\n            require((existingCount + amount) <= 2, \"Cannot own more than 2\");\n            uint256 schoolAmount = idToImprovements3[countryId].schoolCount;\n            require(\n                schoolAmount >= 3,\n                \"Must own 3 schools to own a university\"\n            );\n            idToImprovements3[countryId].universityCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        }\n        emit Improvement3Purchased(countryId, improvementId, amount);\n    }\n\n    ///@dev this is a public function that allows a nation owner to delete improvements\n    ///@dev this function is only callable by the nation owner\n    ///@notice this function will allow a nation owner to delete certain improvements\n    ///@param amount is the number of improvements being delete\n    ///@param countryId is the nation deleting improvements\n    /**\n     * @param improvementId this will determine which improvement is being deleted\n     * 1 = prison\n     * 2 = radiaton containment chambers\n     * 3 = red light district\n     * 4 = rehab facilities\n     * 5 = satellite\n     * 6 = school\n     * 7 = shipyard\n     * 8 = stadium\n     * 9 = university\n     */\n    function deleteImprovement3(\n        uint256 amount,\n        uint256 countryId,\n        uint256 improvementId\n    ) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(improvementId <= 12, \"Invalid improvement ID\");\n        if (improvementId == 1) {\n            uint256 existingCount = idToImprovements3[countryId].prisonCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements3[countryId].prisonCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 2) {\n            uint256 existingCount = idToImprovements3[countryId]\n                .radiationContainmentChamberCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements3[countryId]\n                .radiationContainmentChamberCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 3) {\n            uint256 existingCount = idToImprovements3[countryId]\n                .redLightDistrictCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements3[countryId].redLightDistrictCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 4) {\n            uint256 existingCount = idToImprovements3[countryId]\n                .rehabilitationFacilityCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements3[countryId].rehabilitationFacilityCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 5) {\n            uint256 existingCount = idToImprovements3[countryId].satelliteCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            bool strategicDefense = won4.getStrategicDefenseInitiative(\n                countryId\n            );\n            if (strategicDefense) {\n                require(\n                    (existingCount - amount) >= 3,\n                    \"must maintain 3 satellites with strategic defense initiative\"\n                );\n            }\n            idToImprovements3[countryId].satelliteCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 6) {\n            uint256 existingCount = idToImprovements3[countryId].schoolCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            uint256 universityAmount = idToImprovements3[countryId]\n                .universityCount;\n            uint256 newCount = existingCount - amount;\n            require(\n                newCount >= universityAmount,\n                \"Must own one school for each university\"\n            );\n            idToImprovements3[countryId].schoolCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 7) {\n            uint256 existingCount = idToImprovements3[countryId].shipyardCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            uint256 shipyardVesselCount = AdditionalNavyContract(additionalNavy)\n                .getVesselCountForShipyard(countryId);\n            require(\n                shipyardVesselCount == 0,\n                \"Cannot delete shipyard while it supports vessels\"\n            );\n            idToImprovements3[countryId].shipyardCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 8) {\n            uint256 existingCount = idToImprovements3[countryId].stadiumCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements3[countryId].stadiumCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else {\n            uint256 existingCount = idToImprovements3[countryId]\n                .universityCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements3[countryId].universityCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        }\n        emit Improvement3Deleted(countryId, improvementId, amount);\n    }\n\n    ///@dev this is a public view function that will return the number of prisons for a given nation\n    ///@notice this function will return the number of prisons a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of prisons a given nation owns\n    function getPrisonCount(uint256 countryId) public view returns (uint256) {\n        uint256 count = idToImprovements3[countryId].prisonCount;\n        return count;\n    }\n\n    ///@dev this is a public view function that will return the number of radiation containment chambers for a given nation\n    ///@notice this function will return the number of radiation containment chambers a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return uint256 is the number of radiation containment chambers a given nation owns\n    function getRadiationContainmentChamberCount(\n        uint256 countryId\n    ) public view returns (uint256) {\n        uint256 count = idToImprovements3[countryId]\n            .radiationContainmentChamberCount;\n        return count;\n    }\n\n    ///@dev this is a public view function that will return the number of red light districts for a given nation\n    ///@notice this function will return the number of red light districts a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return uint256 is the number of red light districts a given nation owns\n    function getRedLightDistrictCount(\n        uint256 countryId\n    ) public view returns (uint256) {\n        uint256 count = idToImprovements3[countryId].redLightDistrictCount;\n        return count;\n    }\n\n    ///@dev this is a public view function that will return the number of rehab facilities for a given nation\n    ///@notice this function will return the number of rehab facilities a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return uint256 is the number of rehab facilities a given nation owns\n    function getRehabilitationFacilityCount(\n        uint256 countryId\n    ) public view returns (uint256) {\n        uint256 count = idToImprovements3[countryId]\n            .rehabilitationFacilityCount;\n        return count;\n    }\n\n    ///@dev this is a public view function that will return the number of satellites for a given nation\n    ///@notice this function will return the number of satellites a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of satellites a given nation owns\n    function getSatelliteCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 satelliteAmount = idToImprovements3[countryId].satelliteCount;\n        return satelliteAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of schools for a given nation\n    ///@notice this function will return the number of schools a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return uint256 is the number of schools a given nation owns\n    function getSchoolCount(uint256 countryId) public view returns (uint256) {\n        uint256 count = idToImprovements3[countryId].schoolCount;\n        return count;\n    }\n\n    ///@dev this is a public view function that will return the number of shipyards for a given nation\n    ///@notice this function will return the number of shipyards a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of shipyards a given nation owns\n    function getShipyardCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 shipyardAmount = idToImprovements3[countryId].shipyardCount;\n        return shipyardAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of stadiums for a given nation\n    ///@notice this function will return the number of stadiums a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of stadiums a given nation owns\n    function getStadiumCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 stadiumAmount = idToImprovements3[countryId].stadiumCount;\n        return stadiumAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of universities for a given nation\n    ///@notice this function will return the number of universities a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of universities a given nation owns\n    function getUniversityCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 universityAmount = idToImprovements3[countryId].universityCount;\n        return universityAmount;\n    }\n}\n\n\n///@title ImprovementsContract4\n///@author OxSnosh\n///@notice this contract will allow a nation owner to buy certain improvements\ncontract ImprovementsContract4 is Ownable {\n    address public treasury;\n    address public improvements1;\n    address public improvements2;\n    address public forces;\n    address public countryMinter;\n    address public wonders4;\n    uint256 public missileDefenseCost = 90000 * (10 ** 18);\n    uint256 public munitionsFactoryCost = 200000 * (10 ** 18);\n    uint256 public navalAcademyCost = 300000 * (10 ** 18);\n    uint256 public navalConstructionYardCost = 300000 * (10 ** 18);\n    uint256 public officeOfPropagandaCost = 200000 * (10 ** 18);\n    uint256 public policeHeadquartersCost = 75000 * (10 ** 18);\n\n    WondersContract1 won1;\n    ImprovementsContract2 imp2;\n    CountryMinter mint;\n    TreasuryContract tres;\n    WondersContract4 won4;\n\n    struct Improvements4 {\n        //Missile Defense\n        //$90,000\n        //DONE //Reduces effectiveness of incoming cruise missiles used against your nation -10%.\n        //Nations must retain at least three missile defenses if that nation owns a Strategic Defense Initiative wonder.\n        uint256 missileDefenseCount;\n        //MunitionsFactory\n        //$200,000\n        //DONE //Increases enemy infrastructure damage from your [[aircraft,]] cruise missiles, and nukes +3%\n        //DONE //+0.3 penalty to environment per Munitions Factory.\n        //Requires maintaining 3 or more Factories.\n        //Requires having Lead as a resource to purchase.\n        //Limit 5.\n        //Cannot build if Bunkers owned.\n        //Collection required to delete.\n        uint256 munitionsFactoryCount;\n        //Naval Academy\n        //$300,000\n        //DONE //Increases both attacking and defending navy vessel strength +1.\n        //Limit 2 per nation.\n        //Requires Harbor.\n        uint256 navalAcademyCount;\n        //Naval Construction Yard\n        //$300,000\n        //DONE //Increases the daily purchase limit for navy vessels +1.\n        //Your nation must have pre-existing navy support capabilities (via Drydocks and Shipyards) to actually purchase navy vessels.\n        //Limit 3 per nation.\n        //requires Harbor\n        uint256 navalConstructionYardCount;\n        //Office of Propoganda\n        //$200,000\n        //DONE //Decreases the effectiveness of enemy defending soldiers 3%.\n        //Requires maintaining a Forward Operating Base for each Office of Propaganda\n        //Limit 2\n        //Collection required to delete.\n        uint256 officeOfPropagandaCount;\n        //Police Headquarters\n        //$75,000\n        //DONE //Increases population happiness +2.\n        uint256 policeHeadquartersCount;\n    }\n\n    mapping(uint256 => Improvements4) public idToImprovements4;\n\n    event Improvement4Purchased(\n        uint256 indexed countryId,\n        uint256 indexed improvementId,\n        uint256 indexed amount\n    );\n\n    event Improvement4Deleted(\n        uint256 indexed countryId,\n        uint256 indexed improvementId,\n        uint256 indexed amount\n    );\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _treasury,\n        address _forces,\n        address _improvements1,\n        address _improvements2,\n        address _countryMinter,\n        address _wonders4\n    ) public onlyOwner {\n        treasury = _treasury;\n        tres = TreasuryContract(_treasury);\n        forces = _forces;\n        improvements1 = _improvements1;\n        improvements2 = _improvements2;\n        imp2 = ImprovementsContract2(_improvements2);\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        wonders4 = _wonders4;\n        won4 = WondersContract4(_wonders4);\n    }\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"function only callable by countryMinter contract\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable by the countryMinter contract\n    ///@dev this function will initialize the struct to store the info about the minted nations improvements\n    ///@notice this function will allow each minted nation to buy imoprovements\n    ///@param id this is the nation ID for the nation being minted\n    function generateImprovements(uint256 id) public onlyCountryMinter {\n        Improvements4 memory newImprovements4 = Improvements4(0, 0, 0, 0, 0, 0);\n        idToImprovements4[id] = newImprovements4;\n    }\n\n    ///@dev this function will allow the caller to return the cost of an improvement\n    ///@return missileDefenseCost this will be the cost of a foreign ministry\n    ///@return munitionsFactoryCost this will be the cost of a forward operating base...\n    function getCost4()\n        public\n        view\n        returns (uint256, uint256, uint256, uint256, uint256, uint256)\n    {\n        return (\n            missileDefenseCost,\n            munitionsFactoryCost,\n            navalAcademyCost,\n            navalConstructionYardCost,\n            officeOfPropagandaCost,\n            policeHeadquartersCost\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a missile defense\n    function updateMissileDefenseCost(uint256 newPrice) public onlyOwner {\n        missileDefenseCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a munitions factory\n    function updateMunitionsFactoryCost(uint256 newPrice) public onlyOwner {\n        munitionsFactoryCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of naval academy\n    function updateNavalAcademyCost(uint256 newPrice) public onlyOwner {\n        navalAcademyCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of naval construction yard\n    function updateNavalConstructionYardCost(\n        uint256 newPrice\n    ) public onlyOwner {\n        navalConstructionYardCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of an office of propaganda\n    function updateOfficeOfPropagandaCost(uint256 newPrice) public onlyOwner {\n        officeOfPropagandaCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will allow the owner of the contract to update the cost of a police headquarters\n    function updatePoliceHeadquartersCost(uint256 newPrice) public onlyOwner {\n        policeHeadquartersCost = newPrice;\n    }\n\n    ///@dev this is a public function that allows a nation owner to purchase improvements\n    ///@dev this function is only callable by the nation owner\n    ///@notice this function will allow a nation owner to purchase certain improvements\n    ///@param amount is the number of improvements being purchased\n    ///@param countryId is the nation purchasing improvements\n    /**\n     * @param improvementId this will determine which improvement is being purchased\n     * 1 = missile defense\n     * 2 = munitions factory\n     * 3 = naval academy\n     * 4 = naval construction yard\n     * 5 = office of propaganda\n     * 6 = police headquarters\n     */\n    function buyImprovement4(\n        uint256 amount,\n        uint256 countryId,\n        uint256 improvementId\n    ) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 daysSince = tres.getDaysSinceLastBillsPaid(countryId);\n        require(daysSince == 0, \"must pay bills before buying improvements\");\n        bool populationCheck = ImprovementsContract1(improvements1)\n            .checkCitzenCountForImprovementPurchase(countryId, amount);\n        require(\n            populationCheck == true,\n            \"population not high enough for purchase\"\n        );\n        require(improvementId <= 12, \"Invalid improvement ID\");\n        uint256 balance = TreasuryContract(treasury).checkBalance(countryId);\n        if (improvementId == 1) {\n            uint256 purchasePrice = missileDefenseCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements4[countryId]\n                .missileDefenseCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements4[countryId].missileDefenseCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 2) {\n            uint256 purchasePrice = munitionsFactoryCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements4[countryId]\n                .munitionsFactoryCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            uint256 bunkerAmount = ImprovementsContract1(improvements1)\n                .getBunkerCount(countryId);\n            require(bunkerAmount == 0, \"Cannot own if bunker is owned\");\n            //require owning lead as a resource\n            idToImprovements4[countryId].munitionsFactoryCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 3) {\n            uint256 purchasePrice = navalAcademyCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements4[countryId]\n                .navalAcademyCount;\n            require((existingCount + amount) <= 2, \"Cannot own more than 2\");\n            uint256 harborAmount = imp2.getHarborCount(countryId);\n            require(harborAmount > 0, \"must own a harbor to purchase\");\n            idToImprovements4[countryId].navalAcademyCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 4) {\n            uint256 purchasePrice = navalConstructionYardCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements4[countryId]\n                .navalConstructionYardCount;\n            require((existingCount + amount) <= 3, \"Cannot own more than 3\");\n            uint256 harborAmount = imp2.getHarborCount(countryId);\n            require(harborAmount > 0, \"must own a harbor to purchase\");\n            idToImprovements4[countryId].navalConstructionYardCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 5) {\n            uint256 purchasePrice = officeOfPropagandaCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements4[countryId]\n                .officeOfPropagandaCount;\n            require((existingCount + amount) <= 2, \"Cannot own more than 2\");\n            uint256 forwardOperatingBaseAmount = ImprovementsContract2(\n                improvements2\n            ).getForwardOperatingBaseCount(countryId);\n            require(\n                (existingCount + amount) <= forwardOperatingBaseAmount,\n                \"Must own 1 forward operating base for each office of propaganda\"\n            );\n            idToImprovements4[countryId].officeOfPropagandaCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        } else if (improvementId == 6) {\n            uint256 purchasePrice = policeHeadquartersCost * amount;\n            require(balance >= purchasePrice, \"Insufficient balance\");\n            uint256 existingCount = idToImprovements4[countryId]\n                .policeHeadquartersCount;\n            require((existingCount + amount) <= 5, \"Cannot own more than 5\");\n            idToImprovements4[countryId].policeHeadquartersCount += amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal + amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n            TreasuryContract(treasury).spendBalance(countryId, purchasePrice);\n        }\n        emit Improvement4Purchased(countryId, improvementId, amount);\n    }\n\n    ///@dev this is a public function that allows a nation owner to delete improvements\n    ///@dev this function is only callable by the nation owner\n    ///@notice this function will allow a nation owner to delete certain improvements\n    ///@param amount is the number of improvements being delete\n    ///@param countryId is the nation deleting improvements\n    /**\n     * @param improvementId this will determine which improvement is being deleted\n     * 1 = missile defense\n     * 2 = munitions factory\n     * 3 = naval academy\n     * 4 = naval construction yard\n     * 5 = office of propaganda\n     * 6 = police headquarters\n     */\n    function deleteImprovement4(\n        uint256 amount,\n        uint256 countryId,\n        uint256 improvementId\n    ) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(improvementId <= 12, \"Invalid improvement ID\");\n        if (improvementId == 1) {\n            uint256 existingCount = idToImprovements4[countryId]\n                .missileDefenseCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            //cannot delete below 3 if strategic defense init\n            bool strategicDefenseInitiative = won4\n                .getStrategicDefenseInitiative(countryId);\n            if (strategicDefenseInitiative) {\n                require(\n                    (existingCount - amount) >= 3,\n                    \"Cannot delete if Strategic Defense Initiative owned\"\n                );\n            }\n            idToImprovements4[countryId].missileDefenseCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 2) {\n            uint256 existingCount = idToImprovements4[countryId]\n                .munitionsFactoryCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements4[countryId].munitionsFactoryCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 3) {\n            uint256 existingCount = idToImprovements4[countryId]\n                .navalAcademyCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements4[countryId].navalAcademyCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 4) {\n            uint256 existingCount = idToImprovements4[countryId]\n                .navalConstructionYardCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements4[countryId].navalConstructionYardCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 5) {\n            uint256 existingCount = idToImprovements4[countryId]\n                .officeOfPropagandaCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements4[countryId].officeOfPropagandaCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        } else if (improvementId == 6) {\n            uint256 existingCount = idToImprovements4[countryId]\n                .policeHeadquartersCount;\n            require((existingCount - amount) >= 0, \"Cannot delete that many\");\n            idToImprovements4[countryId].policeHeadquartersCount -= amount;\n            uint256 existingImprovementTotal = ImprovementsContract1(\n                improvements1\n            ).getImprovementCount(countryId);\n            uint256 newImprovementTotal = existingImprovementTotal -= amount;\n            ImprovementsContract1(improvements1).updateImprovementCount(\n                countryId,\n                newImprovementTotal\n            );\n        }\n        emit Improvement4Deleted(countryId, improvementId, amount);\n    }\n\n    ///@dev this is a public view function that will return the number of missile defenses for a given nation\n    ///@notice this function will return the number of missile defenses a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of missile defenses a given nation owns\n    function getMissileDefenseCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 missileDefenseAmount = idToImprovements4[countryId]\n            .missileDefenseCount;\n        return missileDefenseAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of munitions factories for a given nation\n    ///@notice this function will return the number of munitions factories a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of munitions factories a given nation owns\n    function getMunitionsFactoryCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 munitionsFactoryAmount = idToImprovements4[countryId]\n            .munitionsFactoryCount;\n        return munitionsFactoryAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of naval academies for a given nation\n    ///@notice this function will return the number of naval academies a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of naval academies a given nation owns\n    function getNavalAcademyCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 navalAcademyAmount = idToImprovements4[countryId]\n            .navalAcademyCount;\n        return navalAcademyAmount;\n    }\n\n    ///@dev this is a public view function that will return the number of naval construction yards for a given nation\n    ///@notice this function will return the number of naval construction yards a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of naval construction yards a given nation owns\n    function getNavalConstructionYardCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 navalConstructionYardAmount = idToImprovements4[countryId]\n            .navalConstructionYardCount;\n        return navalConstructionYardAmount;\n    }\n    \n\n    ///@dev this is a public view function that will return the number of offices of propaganda for a given nation\n    ///@notice this function will return the number of roffices of propaganda a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of offices of propaganda a given nation owns\n    function getOfficeOfPropagandaCount(\n        uint256 countryId\n    ) public view returns (uint256) {\n        uint256 count = idToImprovements4[countryId].officeOfPropagandaCount;\n        return count;\n    }\n\n    ///@dev this is a public view function that will return the number of police headquarters for a given nation\n    ///@notice this function will return the number of police headquuarters a nation owns\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the number of police headquarters a given nation owns\n    function getPoliceHeadquartersCount(\n        uint256 countryId\n    ) public view returns (uint256) {\n        uint256 count = idToImprovements4[countryId].policeHeadquartersCount;\n        return count;\n    }\n}\n"
    },
    "contracts/Infrastructure.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./CountryMinter.sol\";\nimport \"./Resources.sol\";\nimport \"./Improvements.sol\";\nimport \"./Wonders.sol\";\nimport \"./Treasury.sol\";\nimport \"./Forces.sol\";\nimport \"./Wonders.sol\";\nimport \"./CountryParameters.sol\";\nimport \"./Crime.sol\";\nimport \"./Forces.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"hardhat/console.sol\";\n\n///@title InfrastructureContract\n///@author OxSnosh\n///@notice this contract will store a nations land, technology, infrastructure and tax rate\ncontract InfrastructureContract is Ownable {\n    address public countryMinter;\n    address public resources;\n    address public infrastructureMarket;\n    address public techMarket;\n    address public landMarket;\n    address public improvements1;\n    address public improvements2;\n    address public improvements3;\n    address public improvements4;\n    address public wonders1;\n    address public wonders2;\n    address public wonders3;\n    address public wonders4;\n    address public forces;\n    address public treasury;\n    address public aid;\n    address public parameters;\n    address public spyAddress;\n    address public taxes;\n    address public cruiseMissile;\n    address public nukeAddress;\n    address public airBattle;\n    address public groundBattle;\n    address public crime;\n    address public bonusResources;\n\n    CountryMinter mint;\n    ResourcesContract res;\n    ImprovementsContract1 imp1;\n    ImprovementsContract2 imp2;\n    ImprovementsContract3 imp3;\n    ImprovementsContract4 imp4;\n    WondersContract1 won1;\n    WondersContract3 won3;\n    WondersContract4 won4;\n    CrimeContract crim;\n    ForcesContract forc;\n    BonusResourcesContract bonus;\n    CountryParametersContract param;\n\n    struct Infrastructure {\n        uint256 landArea;\n        uint256 technologyCount;\n        uint256 infrastructureCount;\n        uint256 taxRate;\n        bool collectionNeededToChangeRate;\n    }\n\n    event InfrastructureDamageFromAirAssault(\n        uint256 indexed countryId,\n        uint256 indexed amount\n    );\n\n    event TechDestroyedFromCruiseMissile(\n        uint256 indexed countryId,\n        uint256 indexed amount  \n    );\n\n    event InfrastructureDestroyedFromCruiseMissile(\n        uint256 indexed countryId,\n        uint256 indexed amount\n    );\n\n    event LandDestroyedFromNukeAttack(\n        uint256 indexed countryId,\n        uint256 indexed amount\n    );\n\n    event InfrastructureDestroyedFromNukeAttack(\n        uint256 indexed countryId,\n        uint256 indexed amount\n    );\n\n    event TechDestroyedFromNukeAttack(\n        uint256 indexed countryId,\n        uint256 indexed amount\n    );\n\n    event LandSold(\n        uint256 indexed countryId,\n        uint256 indexed amount,\n        uint256 indexed cost\n    );\n\n    mapping(uint256 => Infrastructure) public idToInfrastructure;\n    mapping(uint256 => address) public idToOwnerInfrastructure;\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings1(\n        address _resources,\n        address _improvements1,\n        address _improvements2,\n        address _improvements3,\n        address _improvements4,\n        address _infrastructureMarket,\n        address _techMarket,\n        address _landMarket,\n        address _bonusResources\n    ) public onlyOwner {\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        improvements1 = _improvements1;\n        imp1 = ImprovementsContract1(_improvements1);\n        improvements2 = _improvements2;\n        imp2 = ImprovementsContract2(_improvements2);\n        improvements3 = _improvements3;\n        imp3 = ImprovementsContract3(_improvements3);\n        improvements4 = _improvements4;\n        imp4 = ImprovementsContract4(_improvements4);\n        infrastructureMarket = _infrastructureMarket;\n        techMarket = _techMarket;\n        landMarket = _landMarket;\n        bonusResources = _bonusResources;\n        bonus = BonusResourcesContract(_bonusResources);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings2(\n        address _wonders1,\n        address _wonders2,\n        address _wonders3,\n        address _wonders4,\n        address _treasury,\n        address _parameters,\n        address _forces,\n        address _aid\n    ) public onlyOwner {\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        wonders2 = _wonders2;\n        wonders3 = _wonders3;\n        won3 = WondersContract3(_wonders3);\n        wonders4 = _wonders4;\n        won4 = WondersContract4(_wonders4);\n        treasury = _treasury;\n        parameters = _parameters;\n        forces = _forces;\n        forc = ForcesContract(_forces);\n        aid = _aid;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings3(\n        address _spyAddress,\n        address _tax,\n        address _cruiseMissile,\n        address _nukeAddress,\n        address _airBattle,\n        address _groundBattle,\n        address _countryMinter,\n        address _crime,\n        address _parameters\n    ) public onlyOwner {\n        spyAddress = _spyAddress;\n        taxes = _tax;\n        cruiseMissile = _cruiseMissile;\n        nukeAddress = _nukeAddress;\n        airBattle = _airBattle;\n        groundBattle = _groundBattle;\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        crime = _crime;\n        crim = CrimeContract(_crime);\n        parameters = _parameters;\n        param = CountryParametersContract(_parameters);\n    }\n\n    modifier onlySpyContract() {\n        require(\n            msg.sender == spyAddress,\n            \"only spy contract can call this function\"\n        );\n        _;\n    }\n\n    modifier onlyTaxesContract() {\n        require(\n            msg.sender == taxes,\n            \"only tax contract can call this function\"\n        );\n        _;\n    }\n\n    modifier onlyCruiseMissileContract() {\n        require(\n            msg.sender == cruiseMissile,\n            \"only callable from cruise missile contract\"\n        );\n        _;\n    }\n\n    modifier onlyNukeContract() {\n        require(\n            msg.sender == nukeAddress,\n            \"only callable from cruise missile contract\"\n        );\n        _;\n    }\n\n    modifier onlyAirBattle() {\n        require(\n            msg.sender == airBattle,\n            \"function only callable from Air Battle contract\"\n        );\n        _;\n    }\n\n    modifier onlyGroundBattle() {\n        require(\n            msg.sender == groundBattle,\n            \"function only callable from Ground Battle contract\"\n        );\n        _;\n    }\n\n    modifier onlyInfrastructureMarket() {\n        require(\n            msg.sender == infrastructureMarket,\n            \"function only callable from infrastructure marketplace\"\n        );\n        _;\n    }\n\n    modifier onlyTechMarket() {\n        require(\n            msg.sender == techMarket,\n            \"function only callable from infrastructure marketplace\"\n        );\n        _;\n    }\n\n    modifier onlyLandMarket() {\n        require(\n            msg.sender == landMarket,\n            \"function only callable from infrastructure marketplace\"\n        );\n        _;\n    }\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"function only callable from countryMinter contract\"\n        );\n        _;\n    }\n\n    modifier onlyAidContract() {\n        require(msg.sender == aid);\n        _;\n    }\n\n    ///@dev this function is only callable by the countryMinter contract\n    ///@dev this function will initialize the struct to store the info about the minted nations infrastructure\n    ///@notice this function allows this contract to store info about a nations infrastructure\n    ///@param id this is the nation ID for the nation being minted\n    function generateInfrastructure(uint256 id) public onlyCountryMinter {\n        Infrastructure memory newInfrastrusture = Infrastructure(\n            20,\n            0,\n            20,\n            16,\n            false\n        );\n        idToInfrastructure[id] = newInfrastrusture;\n    }\n\n    ///@dev this function is only callable from the infrastructure market contract\n    ///@dev this function will increase a nations infrastructure when purchased in the market contract\n    ///@notice this function will increase a nations infrastructure when purchased in the market contract\n    ///@param id is the nation purchasing infrastructure\n    ///@param amount is the amount of infrastructure being purchased\n    function increaseInfrastructureFromMarket(\n        uint256 id,\n        uint256 amount\n    ) public onlyInfrastructureMarket {\n        idToInfrastructure[id].infrastructureCount += amount;\n    }\n\n    ///@dev this is a public function only callable from the infrastructure market contract\n    ///@dev this function will allow a nation owner to sell infrastructure\n    ///@notice this function will allow a nation owner to sell infrastructure\n    ///@param id this is the nation id of the nation selling infrastructure\n    ///@param amount this is the amount of infrastructure being sold\n    function decreaseInfrastructureFromMarket(\n        uint256 id,\n        uint256 amount\n    ) public onlyInfrastructureMarket {\n        idToInfrastructure[id].infrastructureCount -= amount;\n    }\n\n    ///@dev this is a public function only callable from the technology market contract\n    ///@dev this function will increase the technology count when technology is purchased\n    ///@notice this function will increase technology when technology is purchased\n    ///@param id this is the nation id of the nation purchasing technology\n    ///@param amount this is the amount of technology being purchased\n    function increaseTechnologyFromMarket(\n        uint256 id,\n        uint256 amount\n    ) public onlyTechMarket {\n        idToInfrastructure[id].technologyCount += amount;\n    }\n\n    ///@dev this is a public function only callable from the technology market contract\n    ///@dev this function will allow a nation owner to sell technology\n    ///@notice this function will allow a nation owner to sell technology\n    ///@param id this is the nation id of the nation selling technology\n    ///@param amount this is the amount of technology being sold\n    function decreaseTechnologyFromMarket(\n        uint256 id,\n        uint256 amount\n    ) public onlyTechMarket {\n        idToInfrastructure[id].technologyCount -= amount;\n    }\n\n    ///@dev this is a public function only callable from the land market contract\n    ///@dev this function will increase the land area count when land is purchased\n    ///@notice this function will increase land area when land is purchased\n    ///@param id this is the nation id of the nation purchasing land\n    ///@param amount this is the amount of land being purchased\n    function increaseLandCountFromMarket(\n        uint256 id,\n        uint256 amount\n    ) public onlyLandMarket {\n        idToInfrastructure[id].landArea += amount;\n    }\n\n    ///@dev this is a public function only callable from the land market contract\n    ///@dev this function will allow a nation owner to sell land\n    ///@notice this function will allow a nation owner to sell land\n    ///@param id this is the nation id of the nation selling land\n    ///@param amount this is the amount of land being sold\n    function decreaseLandCountFromMarket(\n        uint256 id,\n        uint256 amount\n    ) public onlyLandMarket {\n        idToInfrastructure[id].landArea -= amount;\n    }\n\n    ///@dev this is a public view function that will return the amount of land a nation has\n    ///@notice this function will return the amount of land a nation has\n    ///@param countryId this is the nation ID of the country being queried\n    ///@return count is the amount of land area for a given country\n    function getLandCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        return idToInfrastructure[countryId].landArea;\n    }\n\n    ///@dev this is a public view function that will return a nations area of influence from a given land area\n    ///@notice this function will return a given nations area of influence as a multiple of their land area\n    ///@notice coal will increase area of influence 15%\n    ///@notice rubber will increase area of influence 20%\n    ///@notice spices will increase area of influence 8%\n    ///@notice an agriculture development program will increase area of influence 15%\n    ///@param id is the nation id of the nation being queried\n    ///@return uint256 is the given nations area of influence\n    function getAreaOfInfluence(uint256 id) public view returns (uint256) {\n        uint256 currentLand = idToInfrastructure[id].landArea;\n        uint256 landModifier = 100;\n        bool coal = res.viewCoal(id);\n        if (coal) {\n            landModifier += 15;\n        }\n        bool rubber = res.viewRubber(id);\n        if (rubber) {\n            landModifier += 20;\n        }\n        bool spices = res.viewSpices(id);\n        if (spices) {\n            landModifier += 8;\n        }\n        bool agriculturalDevelopmentProgram = won1\n            .getAgriculturalDevelopmentProgram(id);\n        if (agriculturalDevelopmentProgram) {\n            landModifier += 15;\n        }\n        uint256 governmentType = param.getGovernmentType(id);\n        if (\n            governmentType == 1 ||\n            governmentType == 2 ||\n            governmentType == 6 ||\n            governmentType == 7 ||\n            governmentType == 9 ||\n            governmentType == 10\n        ) {\n            landModifier += 5;\n        }\n        uint256 areaOfInfluence = ((currentLand * landModifier) / 100);\n        return areaOfInfluence;\n    }\n\n    ///@dev this is a public function only callable from a nation owner\n    ///@dev this function will allow a nation owner to sell land\n    ///@notice this function will allow a nation owner to sell land\n    ///@notice land can be sold for 100/mile (300 with rubber)\n    ///@param id is the nation id of the nation selling land\n    ///@param amount is the amount of land being sold\n    function sellLand(uint256 id, uint256 amount) public {\n        bool owner = mint.checkOwnership(id, msg.sender);\n        require(owner, \"!nation owner\");\n        uint256 currentLand = idToInfrastructure[id].landArea;\n        require(amount < (currentLand - 20), \"cannot sell land below 20 miles\");\n        idToInfrastructure[id].landArea -= amount;\n        uint256 costPerMile = 100 * (10**18);\n        bool rubber = res.viewRubber(id);\n        if (rubber) {\n            costPerMile = 300 * (10**18);\n        }\n        uint256 totalCost = (amount * costPerMile);\n        TreasuryContract(treasury).returnBalance(id, totalCost);\n        emit LandSold(id, amount, totalCost);\n    }\n\n    ///@dev this is a public function that is only callable from the spy contract\n    ///@dev this function will decrease land area after a successful spy attack\n    ///@notice this function will deacrease land area after a succesfuls spy attack\n    ///@param countryId is the country if of the nation losing land in the attack\n    ///@param amount is the amount of land being lost in the attack\n    function decreaseLandCountFromSpyContract(\n        uint256 countryId,\n        uint256 amount\n    ) public onlySpyContract {\n        idToInfrastructure[countryId].landArea -= amount;\n    }\n\n    ///@dev this is a public function that will decrease a nations land when attacked by a nuke\n    ///@dev this function is only callable by the nuke contract\n    ///@notice this function will decrease the amount of a nations land when attacked by a nuke\n    ///@notice the maximum amount of land that can be lost is 150 miles\n    ///@param countryId this is the nation ID of the nation being attacked\n    ///@param percentage this is the percentage of a nations land being lost\n    ///@param attackType is the type of attack being used in the nuke strike (1 = standard, 2 = infrastructure, 3 = land, 4 = technology)\n    ///@notice attack type can only be 2, 3 or 4 if the attacking nation has EMP weaponization\n    function decreaseLandCountFromNukeContract(\n        uint256 countryId,\n        uint256 percentage,\n        uint256 attackType\n    ) public onlyNukeContract {\n        uint256 landAmount = idToInfrastructure[countryId].landArea;\n        uint256 landAmountToDecrease = ((landAmount * percentage) / 100);\n        uint256 maxLandToDecrease = 150;\n        if (attackType == 3) {\n            maxLandToDecrease = 200;\n        }\n        if (attackType == 2 || attackType == 4) {\n            maxLandToDecrease = 100;\n        }\n        if (landAmountToDecrease > maxLandToDecrease) {\n            idToInfrastructure[countryId].landArea -= maxLandToDecrease;\n            landAmountToDecrease = maxLandToDecrease;\n        } else {\n            idToInfrastructure[countryId].landArea -= landAmountToDecrease;\n        }\n        emit LandDestroyedFromNukeAttack(countryId, landAmountToDecrease);\n    }\n\n    ///@dev this is a public view function that will retrun the amount of technology a nation has\n    ///@notice this function will return the amount of technology a nation has\n    ///@param countryId this is the nation ID of the nation being queried\n    ///@return count is the tech amount for a given nation\n    function getTechnologyCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 technologyAmount = idToInfrastructure[countryId]\n            .technologyCount;\n        return technologyAmount;\n    }\n\n    ///@dev this is a public function only callable from the aid contract\n    ///@dev this function will send the technology when an aid proposal is accepted\n    ///@notice this function will send the technology when an aid proposal is accepted\n    ///@param idSender is the nation id of the sender of the technology aid\n    ///@param idReciever is the nation id of the recipient of technology aid\n    ///@param amount is the amount of technology being sent\n    function sendTech(\n        uint256 idSender,\n        uint256 idReciever,\n        uint256 amount\n    ) public onlyAidContract {\n        idToInfrastructure[idSender].technologyCount -= amount;\n        idToInfrastructure[idReciever].technologyCount += amount;\n    }\n\n    ///@dev this is a public function only callable from the spy contract\n    ///@dev this function will decrease the amount of tech for a nation after a succesful spy attack\n    ///@notice this function will decrease a nations tech after a succesful spy attack\n    ///@param countryId this is the nation ID of the nation being attacked\n    ///@param amount is the amount of technology a nation is losing in the attack\n    function decreaseTechCountFromSpyContract(\n        uint256 countryId,\n        uint256 amount\n    ) public onlySpyContract {\n        idToInfrastructure[countryId].technologyCount -= amount;\n    }\n\n    ///@dev this is a public function only callable from the cruise missile contract\n    ///@dev this function will decrease the amount of tech for a nation after a succesful cruise missile attack\n    ///@notice this function will decrease a nations tech after a succesful cruise missile attack\n    ///@param countryId this is the nation ID of the nation being attacked\n    ///@param amount is the amount of technology a nation is losing in the attack\n    function decreaseTechCountFromCruiseMissileContract(\n        uint256 countryId,\n        uint256 amount\n    ) public onlyCruiseMissileContract {\n        idToInfrastructure[countryId].technologyCount -= amount;\n        emit TechDestroyedFromCruiseMissile(countryId, amount);\n    }\n\n    ///@dev this is a public function only callable from the nuke contract\n    ///@dev this function will decrease the amount of tech for a nation after a succesful nuke attack\n    ///@notice this function will decrease a nations tech after a succesful nuke attack\n    ///@notice the maximum amount of tech a nation can lose in an attack is 50\n    ///@param countryId this is the nation ID of the nation being attacked\n    ///@param percentage is the percentage of a nations technology a nation is losing in the attack\n    ///@param attackType is the type of attack being used in the nuke strike (1 = standard, 2 = infrastructure, 3 = land, 4 = technology)\n    ///@notice attack type can only be 2, 3 or 4 if the attacking nation has EMP weaponization\n    function decreaseTechCountFromNukeContract(\n        uint256 countryId,\n        uint256 percentage,\n        uint256 attackType\n    ) public onlyNukeContract {\n        uint256 techAmount = idToInfrastructure[countryId].technologyCount;\n        uint256 techAmountToDecrease = ((techAmount * percentage) / 100);\n        uint256 maxTechToDecrease = 50;\n        if (attackType == 4) {\n            maxTechToDecrease = 70;\n        }\n        if (attackType == 2 || attackType == 3) {\n            maxTechToDecrease = 30;\n        }\n        if (techAmountToDecrease > maxTechToDecrease) {\n            idToInfrastructure[countryId].technologyCount -= maxTechToDecrease;\n            techAmountToDecrease = maxTechToDecrease;\n        } else {\n            idToInfrastructure[countryId]\n                .technologyCount -= techAmountToDecrease;\n        }\n        emit TechDestroyedFromNukeAttack(countryId, techAmountToDecrease);\n    }\n\n    ///@dev this is a public view function that will return the amount of infrastructure for a nation\n    ///@notice this function will return a nations infrastructure count\n    ///@param countryId is the nation ID of the country being queried\n    ///@return count is the amount of technology for a given nation\n    function getInfrastructureCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 infrastructureAmount = idToInfrastructure[countryId]\n            .infrastructureCount;\n        return infrastructureAmount;\n    }\n\n    ///@dev this is a public function only callable from the spy contract\n    ///@dev this function will decrease a nations infrastructure amount after a succesful spy attack\n    ///@notice this function will decrease a nations infrastrucure after a succesful spy attack\n    ///@param countryId this is the nationId of the nation losing infrastructure\n    ///@param amount this is the amount of infrastructure being lost\n    function decreaseInfrastructureCountFromSpyContract(\n        uint256 countryId,\n        uint256 amount\n    ) public onlySpyContract {\n        idToInfrastructure[countryId].infrastructureCount -= amount;\n    }\n\n    ///@dev this is a public view function that is only callable from the cruise missile contract\n    ///@dev this function will decrease the amount of technology lost in a cruise missile attack\n    ///@notice this function will decrease the amount of technology lost in a cruise missile attack\n    ///@param countryId this is the nation id of the country being queried\n    ///@param amountToDecrease this is the amount of infrastructure being decreased\n    function decreaseInfrastructureCountFromCruiseMissileContract(\n        uint256 countryId,\n        uint256 amountToDecrease\n    ) public onlyCruiseMissileContract {\n        uint256 infrastructureAmount = idToInfrastructure[countryId]\n            .infrastructureCount;\n        if (amountToDecrease >= infrastructureAmount) {\n            idToInfrastructure[countryId].infrastructureCount = 0;\n            amountToDecrease = infrastructureAmount;\n        } else {\n            idToInfrastructure[countryId]\n                .infrastructureCount -= amountToDecrease;\n        }\n        emit InfrastructureDestroyedFromCruiseMissile(countryId, amountToDecrease);\n    }\n\n    ///@dev this is a public function only callable from the nuke contract\n    ///@dev this function will decrease the amount of a nations infrastructure after a nuke attack\n    ///@notice this function will decrease the amount of a nations infrastructure after a nuke attack\n    ///@notice the maximum amount of infrastructure a nation can lose in a nuke strike is 150\n    ///@notice defender bunkers will decrease the amount of damage in a succesful nuke attack\n    ///@notice attacker munitions factories will increase the amount of damage of a succesful nuke attack\n    ///@param defenderId is the defending nation in a nuke strike\n    ///@param attackerId is an attacking nation in a nuke strike\n    ///@param percentage is the percentage of infrastructure being lost before modifiers (defender bunkers and attacker munitions factories)\n    ///@param attackType is the type of attack being used in the nuke strike (1 = standard, 2 = infrastructure, 3 = land, 4 = technology)\n    ///@notice attack type can only be 2, 3 or 4 if the attacking nation has EMP weaponization\n    function decreaseInfrastructureCountFromNukeContract(\n        uint256 defenderId,\n        uint256 attackerId,\n        uint256 percentage,\n        uint256 attackType\n    ) public onlyNukeContract {\n        uint256 infrastructureAmount = idToInfrastructure[defenderId]\n            .infrastructureCount;\n        uint256 damagePercentage = percentage;\n        uint256 bunkerCount = imp1.getBunkerCount(defenderId);\n        if (bunkerCount > 0) {\n            damagePercentage -= (bunkerCount * 3);\n        }\n        uint256 attackerMunitionsFactory = imp4.getMunitionsFactoryCount(\n            attackerId\n        );\n        if (attackerMunitionsFactory > 0) {\n            damagePercentage += (attackerMunitionsFactory * 3);\n        }\n        uint256 infrastructureAmountToDecrease = ((infrastructureAmount *\n            damagePercentage) / 100);\n        uint256 maxInfrastructureToDecrease = (150 - (bunkerCount * 5) + (attackerMunitionsFactory * 5));\n        if (attackType == 2) {\n            maxInfrastructureToDecrease = (200 - (bunkerCount * 5) + (attackerMunitionsFactory * 5));\n        }\n        if (attackType == 3 || attackType == 4) {\n            maxInfrastructureToDecrease = (100 - (bunkerCount * 5) + (attackerMunitionsFactory * 5));\n        }\n        if (infrastructureAmountToDecrease > maxInfrastructureToDecrease) {\n            idToInfrastructure[defenderId]\n                .infrastructureCount -= maxInfrastructureToDecrease;\n            infrastructureAmountToDecrease = maxInfrastructureToDecrease;\n        } else {\n            idToInfrastructure[defenderId]\n                .infrastructureCount -= infrastructureAmountToDecrease;\n        }\n        emit InfrastructureDestroyedFromNukeAttack(\n            defenderId,\n            infrastructureAmountToDecrease\n        );\n    }\n\n    ///@dev this is a public function only callable from the air battle contract\n    ///@dev this function will decrease a nations infrastructure lost in a bombing attack\n    ///@notice this function will decrease a nations infrastructure lost in a bombing attack (max 20 levels)\n    ///@param countryId is the nation id of the country losing infrastructure\n    ///@param amountToDecrease is the amount of infrastructure being lost\n    function decreaseInfrastructureCountFromAirBattleContract(\n        uint256 countryId,\n        uint256 amountToDecrease\n    ) public onlyAirBattle {\n        uint256 infrastructureDamageModifier = 100;\n        uint256 bunkerCount = imp1.getBunkerCount(countryId);\n        if (bunkerCount > 0) {\n            infrastructureDamageModifier -= (5 * bunkerCount);\n        }\n        uint256 damage = ((amountToDecrease * infrastructureDamageModifier) /\n            100);\n        uint256 infrastructureAmount = idToInfrastructure[countryId]\n            .infrastructureCount;\n        if (damage >= 20) {\n            damage = 20;\n        }\n        if (damage >= infrastructureAmount) {\n            idToInfrastructure[countryId].infrastructureCount = 0;\n            damage = infrastructureAmount;\n        } else {\n            idToInfrastructure[countryId].infrastructureCount -= damage;\n        }\n        emit InfrastructureDamageFromAirAssault(countryId, damage);\n    }\n\n    ///@dev this is a public function only callable from the ground battle contract\n    ///@notice this function will transfer land and infrastructure lost during a ground battle\n    ///@param landMiles is the amount of land being won\n    ///@param infrastructureLevels is the amount of infrastructure being won\n    ///@param attackerId is the ID of the attack nation\n    ///@param defenderId is the ID of the defending nation\n    function transferLandAndInfrastructure(\n        uint256 landMiles,\n        uint256 infrastructureLevels,\n        uint256 attackerId,\n        uint256 defenderId\n    ) public onlyGroundBattle {\n        uint256 defenderLand = idToInfrastructure[defenderId].landArea;\n        uint256 defenderInfrastructure = idToInfrastructure[defenderId]\n            .infrastructureCount;\n        console.log(\"defender land\", defenderLand);\n        console.log(\"defender infrastructure\", defenderInfrastructure);\n        console.log(\"land miles\", landMiles);\n        console.log(\"infrastructure levels\", infrastructureLevels);\n        if (defenderLand <= landMiles) {\n            idToInfrastructure[attackerId].landArea += defenderLand;\n            landMiles = defenderLand;\n            idToInfrastructure[defenderId].landArea = 0;\n        } else {\n            idToInfrastructure[attackerId].landArea += landMiles;\n            idToInfrastructure[defenderId].landArea -= landMiles;\n            console.log(\"this land exchange happened\");\n        }\n        if (defenderInfrastructure <= infrastructureLevels) {\n            idToInfrastructure[attackerId]\n                .infrastructureCount += defenderInfrastructure;\n            infrastructureLevels = defenderInfrastructure;\n            idToInfrastructure[defenderId].infrastructureCount = 0;\n        } else {\n            idToInfrastructure[attackerId]\n                .infrastructureCount += infrastructureLevels;\n            idToInfrastructure[defenderId]\n                .infrastructureCount -= infrastructureLevels;\n            console.log(\"this infrastructure exchange happened\");\n        }\n    }\n\n    ///@dev this is public view function that will return a nations total population count\n    ///@notice this function will return a nation population count\n    ///@notice a nations base populaton is a nation infrastructure count * 8\n    ///@notice a nations population is increased by cattle, fish, pigs, sugar, wheat, affluent population and decreased by border walls\n    ///@return uint256 is a nations total population\n    function getTotalPopulationCount(uint256 id) public view returns (uint256) {\n        uint256 infra = getInfrastructureCount(id);\n        uint256 populationBaseCount = (infra * 8);\n        bool agricultureDevelopment = won1.getAgriculturalDevelopmentProgram(\n            id\n        );\n        if (agricultureDevelopment) {\n            populationBaseCount = (infra * 9);\n        }\n        uint256 populationModifier = 100;\n        bool cattle = res.viewCattle(id);\n        if (cattle) {\n            populationModifier += 5;\n        }\n        bool fish = res.viewFish(id);\n        if (fish) {\n            populationModifier += 8;\n        }\n        bool pigs = res.viewPigs(id);\n        if (pigs) {\n            populationModifier += 4;\n        }\n        bool sugar = res.viewSugar(id);\n        if (sugar) {\n            populationModifier += 3;\n        }\n        bool wheat = res.viewWheat(id);\n        if (wheat) {\n            populationModifier += 8;\n        }\n        bool affluentPopulation = bonus.viewAffluentPopulation(id);\n        if (affluentPopulation) {\n            populationModifier += 5;\n        }\n        uint256 borderWalls = imp1.getBorderWallCount(id);\n        if (borderWalls > 0) {\n            populationModifier -= (2 * borderWalls);\n        }\n        uint256 additionalModifierPoints = getAdditionalPopulationModifierPoints(\n                id\n            );\n        populationModifier += additionalModifierPoints;\n        uint256 population = ((populationBaseCount * populationModifier) / 100);\n        return population;\n    }\n\n    ///@dev this is an internal view function that will be called by the above function\n    ///@dev this function will return additonal population percentage modifiers for the above function\n    ///@notice this function will return additonal population percentage modifiers for the above function\n    ///@notice a nations population is increased by clinics, hospitals, disaster relief agencies, national environmental office, national research lab and universal healthcare\n    ///@return uint256 is the additional percentage modifiers for the above function\n    function getAdditionalPopulationModifierPoints(\n        uint256 id\n    ) internal view returns (uint256) {\n        uint256 additionalPoints;\n        uint256 clinicCount = imp1.getClinicCount(id);\n        if (clinicCount > 0) {\n            additionalPoints += (2 * clinicCount);\n        }\n        uint256 hospitals = imp2.getHospitalCount(id);\n        if (hospitals > 0) {\n            additionalPoints += 6;\n        }\n        bool disasterReliefAgency = won1.getDisasterReliefAgency(id);\n        if (disasterReliefAgency) {\n            additionalPoints += 3;\n        }\n        bool nationalEnvironmentOffice = won3.getNationalEnvironmentOffice(id);\n        if (nationalEnvironmentOffice) {\n            additionalPoints += 5;\n        }\n        bool nationalResearchLab = won3.getNationalResearchLab(id);\n        if (nationalResearchLab) {\n            additionalPoints += 5;\n        }\n        bool universalHealthcare = won4.getUniversalHealthcare(id);\n        if (universalHealthcare) {\n            additionalPoints += 3;\n        }\n        return additionalPoints;\n    }\n\n    ///@dev this is public view function that will return a nations taxable population\n    ///@notice this function will return a nations taxable population\n    ///@notice a nations total population consists of citizens, soldiers and criminals\n    ///@notice only citizens pay taxes\n    ///@param id is the nation id of the nation being queried\n    ///@return uint256 this is the given nations total taxable population\n    function getTaxablePopulationCount(\n        uint256 id\n    ) public view returns (uint256, uint256) {\n        uint256 totalPop = getTotalPopulationCount(id);\n        (uint256 criminals, , ) = crim\n            .getCriminalCount(id);\n        uint256 soldiers = forc.getSoldierCount(id);\n        uint256 citizens;\n        uint256 citizenDefecit;\n        if ((totalPop) <= (criminals + soldiers)) {\n            citizens = 0;\n            citizenDefecit = ((criminals + soldiers) - (totalPop));\n        } else {\n            citizens = ((totalPop) - (criminals + soldiers));\n            citizenDefecit = 0;\n        }\n        return (citizens, citizenDefecit);\n    }\n\n    ///@dev this is a public view function that will return a nations tax rate at which they tax their citizens\n    ///@notice this function will return the tax rate which a nation taxes their citizens at\n    ///@param id is the nation ID of the nation being queried\n    ///@return taxPercentage is the tax rate for a given nation\n    function getTaxRate(\n        uint256 id\n    ) public view returns (uint256 taxPercentage) {\n        uint256 taxRate = idToInfrastructure[id].taxRate;\n        return taxRate;\n    }\n\n    ///@dev this is a public function only vallable by a nation owner\n    ///@dev this function will allow a nation owner to set their nations tax rate\n    ///@notice this function will allow a nation owner to set their nations tax rate\n    ///@notice a tax rate can be between 15% and 28%\n    ///@notice a tax rate can be 30% with a social security wonder\n    ///@param id is the nation id of the nation changing its tax rate\n    ///@param newTaxRate is the new tax rate for a nation\n    function setTaxRate(uint256 id, uint256 newTaxRate) public {\n        bool owner = mint.checkOwnership(id, msg.sender);\n        require(owner, \"!nation owner\");\n        require(\n            idToInfrastructure[id].collectionNeededToChangeRate == false,\n            \"need to collect taxes before changing tax rate\"\n        );\n        uint256 maximumTaxRate = 28;\n        bool socialSecurity = won4.getSocialSecuritySystem(id);\n        if (socialSecurity) {\n            maximumTaxRate = 30;\n        }\n        require(newTaxRate <= maximumTaxRate, \"cannot tax above maximum rate\");\n        require(newTaxRate >= 15, \"cannot tax below 15%\");\n        idToInfrastructure[id].taxRate = newTaxRate;\n    }\n\n    ///@dev this is a public function only callable from the spy contract\n    ///@dev this function will reset a nations tax rate after a succesful spy attack\n    ///@notice this function will reset a nations tax rate after a succesful spy attack\n    ///@param id this is the nation ID for the nation being attacked and getting its tax rate changed\n    ///@param newTaxRate is the new tax rate for the nation\n    function setTaxRateFromSpyContract(\n        uint256 id,\n        uint256 newTaxRate\n    ) public onlySpyContract {\n        idToInfrastructure[id].taxRate = newTaxRate;\n        idToInfrastructure[id].collectionNeededToChangeRate = true;\n    }\n\n    ///@dev this is a public function only callable from the taxes contract\n    ///@dev this function will toggle the collection needed to change tax rate to true\n    ///@notice this function will toggle the collection needed to change tax rate to true\n    ///@notice when a nation is blockaded it will need to either break the blockade or collect taxes at a reduced rate to be able to change tax rate\n    ///@param id is the nation ID of the nation toggleing the collection needed parameter\n    function toggleCollectionNeededToChangeRate(\n        uint256 id\n    ) public onlyTaxesContract {\n        idToInfrastructure[id].collectionNeededToChangeRate = false;\n    }\n\n    ///@dev this is a public view function that will return true if a nation needs to collect taxes in order to change its tax rate\n    ///@notice this function will retrun true if a nation needs to collect taxes in order to change its tax rate\n    ///@param id is the nation ID of the nation being queried\n    ///@return bool is the boolean value whether a nation needs to collect taxes in order to change its tax rate\n    function checkIfCollectionNeededToChangeRate(\n        uint256 id\n    ) public view returns (bool) {\n        bool collectionNeeded = idToInfrastructure[id]\n            .collectionNeededToChangeRate;\n        return collectionNeeded;\n    }\n}\n"
    },
    "contracts/InfrastructureMarket.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./CountryMinter.sol\";\nimport \"./Resources.sol\";\nimport \"./Improvements.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Wonders.sol\";\nimport \"./Treasury.sol\";\nimport \"./CountryParameters.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"hardhat/console.sol\";\n\n///@title InfrastructureMarketContract\n///@author OxSnosh\n///@notice this contract will allow a nation owner to buy Infrastructure\ncontract InfrastructureMarketContract is Ownable {\n    address public countryMinter;\n    address public resources;\n    address public infrastructure;\n    address public improvements1;\n    address public wonders2;\n    address public wonders3;\n    address public treasury;\n    address public parameters;\n    address public bonusResources;\n\n    CountryMinter mint;\n    ResourcesContract res;\n    ImprovementsContract1 imp1;\n    WondersContract2 won2;\n    WondersContract3 won3;\n    CountryParametersContract param;\n    InfrastructureContract inf;\n    TreasuryContract tsy;\n    BonusResourcesContract bonus;\n\n    event InfrastructurePurchased(\n        uint256 indexed countryId,\n        uint256 indexed amount,\n        uint256 indexed cost\n    );\n\n    event InfrastructureDestroyed(\n        uint256 indexed countryId,\n        uint256 indexed amount\n    );\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _resources,\n        address _parameters,\n        address _improvements1,\n        address _countryMinter,\n        address _wonders2,\n        address _wonders3,\n        address _treasury,\n        address _infrastructure,\n        address _bonusResources\n    ) public onlyOwner {\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        parameters = _parameters;\n        param = CountryParametersContract(_parameters);\n        improvements1 = _improvements1;\n        imp1 = ImprovementsContract1(_improvements1);\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        wonders2 = _wonders2;\n        won2 = WondersContract2(_wonders2);\n        wonders3 = _wonders3;\n        won3 = WondersContract3(_wonders3);\n        treasury = _treasury;\n        tsy = TreasuryContract(_treasury);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        bonusResources = _bonusResources;\n        bonus = BonusResourcesContract(_bonusResources);\n    }\n\n    ///@dev this is a public view function that will allow a nation owner to buy infrastructure\n    ///@dev this function is only callable by the nation owner\n    ///@notice this function will allow a nation owner to purchase infrastructure\n    ///@param id is the nation id of the nation purchasing infrastructure\n    ///@param buyAmount is the amount of infrastructure being purchased\n    function buyInfrastructure(uint256 id, uint256 buyAmount) public {\n        bool owner = mint.checkOwnership(id, msg.sender);\n        require(owner, \"!nation owner\");\n        uint256 cost = getInfrastructureCost(id, buyAmount);\n        inf.increaseInfrastructureFromMarket(id, buyAmount);\n        tsy.spendBalance(id, cost);\n        emit InfrastructurePurchased(id, buyAmount, cost);\n    }\n\n    ///@dev this is a public view function that will return the cost of an infrastructure purchase\n    ///@dev this function multiplies the cost per level by the purchases amount\n    ///@notice this function will return the cost of an infrastructure purchase\n    ///@param id is the nation id of the nation buying infrastructure\n    ///@param buyAmount this is the amount of infrastructure being purchased\n    ///@return uint256 this is the cost of the purchase\n    function getInfrastructureCost(\n        uint256 id,\n        uint256 buyAmount\n    ) public view returns (uint256) {\n        uint256 costPerLevel = getInfrastructureCostPerLevel(id);\n        uint256 cost = buyAmount * costPerLevel;\n        return cost;\n    }\n\n    ///@dev this is a public view functon that will return the infrastructure cost per level\n    ///@notice this function will return the cost of an infrastructure purchase per level\n    ///@notice cartain modifiers in the following functions will reduce the cost of infrastructure\n    ///@param id this is the nation id making the purchase\n    ///@return uint256 this is the cost per level of an infrastructure purchase\n    function getInfrastructureCostPerLevel(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 grossCost;\n        uint256 currentInfrastructureAmount = inf.getInfrastructureCount(id);\n        if (currentInfrastructureAmount < 20) {\n            grossCost = 500;\n        } else if (\n            currentInfrastructureAmount >= 20 &&\n            currentInfrastructureAmount < 100\n        ) {\n            grossCost = ((currentInfrastructureAmount * 12) + 500);\n        } else if (\n            currentInfrastructureAmount >= 100 &&\n            currentInfrastructureAmount < 200\n        ) {\n            grossCost = ((currentInfrastructureAmount * 15) + 500);\n        } else if (\n            currentInfrastructureAmount >= 200 &&\n            currentInfrastructureAmount < 1000\n        ) {\n            grossCost = ((currentInfrastructureAmount * 20) + 500);\n        } else if (\n            currentInfrastructureAmount >= 1000 &&\n            currentInfrastructureAmount < 2000\n        ) {\n            grossCost = ((currentInfrastructureAmount * 25) + 500);\n        } else if (\n            currentInfrastructureAmount >= 2000 &&\n            currentInfrastructureAmount < 4000\n        ) {\n            grossCost = ((currentInfrastructureAmount * 30) + 500);\n        } else if (\n            currentInfrastructureAmount >= 4000 &&\n            currentInfrastructureAmount < 5000\n        ) {\n            grossCost = ((currentInfrastructureAmount * 40) + 500);\n        } else if (\n            currentInfrastructureAmount >= 5000 &&\n            currentInfrastructureAmount < 8000\n        ) {\n            grossCost = ((currentInfrastructureAmount * 50) + 500);\n        } else if (\n            currentInfrastructureAmount >= 8000 &&\n            currentInfrastructureAmount < 15000\n        ) {\n            grossCost = ((currentInfrastructureAmount * 60) + 500);\n        } else {\n            grossCost = ((currentInfrastructureAmount * 80) + 500);\n        }\n        uint256 costAdjustments1 = getInfrastructureCostMultiplier1(id);\n        uint256 costAdjustments2 = getInfrastructureCostMultiplier2(id);\n        uint256 costAdjustments3 = getInfrastructureCostMultiplier3(id);\n        uint256 adjustments = (costAdjustments1 +\n            costAdjustments2 +\n            costAdjustments3);\n        uint256 multiplier = (100 - adjustments);\n        uint256 adjustedCostPerLevel = ((grossCost * multiplier) / 100);\n        return adjustedCostPerLevel * (10 ** 18);\n    }\n\n    ///@dev this function is one of three functions that will adjust the cost of infrastructure lower\n    ///@dev this function is a public view function that will get called when infrasturcture is quoted or purchased\n    ///@notice this function is one of three functions that will adjust the cost of infrastructure lower based on a nations resources, improvements and wonders\n    ///@notice lumber will reduce the cost of infrastructure by 6%\n    ///@notice iron will reduce the cost of infrastructure by 5%\n    ///@notice marble will reduce the cost of infrastructure by 10%\n    ///@return uint256 this will be the multiplier reductions from this formula\n    function getInfrastructureCostMultiplier1(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 lumberMultiplier = 0;\n        uint256 ironMultiplier = 0;\n        uint256 marbleMultiplier = 0;\n        bool isLumber = res.viewLumber(id);\n        bool isIron = res.viewIron(id);\n        bool isMarble = res.viewMarble(id);\n        if (isLumber) {\n            lumberMultiplier = 6;\n        }\n        if (isIron) {\n            ironMultiplier = 5;\n        }\n        if (isMarble) {\n            marbleMultiplier = 10;\n        }\n        uint256 sumOfAdjustments = lumberMultiplier +\n            ironMultiplier +\n            marbleMultiplier;\n        return sumOfAdjustments;\n    }\n\n    ///@dev this function is the second of three functions that will adjust the cost of infrastructure lower\n    ///@dev this function is a public view function that will get called when infrasturcture is quoted or purchased\n    ///@notice this function is the second of three functions that will adjust the cost of infrastructure lower based on a nations resources, improvements and wonders\n    ///@notice rubber will reduce the cost of infrastructure by 3%\n    ///@notice construction will reduce the cost of infrastructure by 5%\n    ///@notice an interstate system will reduce the cost of infrastructure by 8%\n    ///@notice certain accomodative governements will reduce the cost of infrastructure by 5%\n    ///@notice factories without a scientific development center will reduce the cost of infrastructure by 8% and 10% with a scientific development center\n    ///@return uint256 this will be the multiplier reductions from this formula\n    function getInfrastructureCostMultiplier2(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 rubberMultiplier = 0;\n        uint256 constructionMultiplier = 0;\n        uint256 insterstateSystemMultiplier = 0;\n        uint256 accomodativeGovernmentMultiplier = 0;\n        uint256 factoryMultiplier = 0;\n        bool isRubber = res.viewRubber(id);\n        bool isConstruction = bonus.viewConstruction(id);\n        bool isInterstateSystem = won2.getInterstateSystem(id);\n        bool isAccomodativeGovernment = checkAccomodativeGovernment(id);\n        uint256 factoryCount = imp1.getFactoryCount(id);\n        bool scientificDevelopmentCenter = won3.getScientificDevelopmentCenter(\n            id\n        );\n        if (isRubber) {\n            rubberMultiplier = 3;\n        }\n        if (isConstruction) {\n            constructionMultiplier = 5;\n        }\n        if (isInterstateSystem) {\n            insterstateSystemMultiplier = 8;\n        }\n        if (isAccomodativeGovernment) {\n            accomodativeGovernmentMultiplier = 5;\n        }\n        if (factoryCount > 0) {\n            if (!scientificDevelopmentCenter) {\n                factoryMultiplier = (factoryCount * 8);\n            } else if (scientificDevelopmentCenter) {\n                factoryMultiplier = (factoryCount * 10);\n            }\n        }\n        uint256 sumOfAdjustments = rubberMultiplier +\n            constructionMultiplier +\n            insterstateSystemMultiplier +\n            accomodativeGovernmentMultiplier +\n            factoryMultiplier;\n        return sumOfAdjustments;\n    }\n\n    ///@dev this function is the third of three functions that will adjust the cost of infrastructure lower\n    ///@dev this function is a public view function that will get called when infrasturcture is quoted or purchased\n    ///@notice this function is the third of three functions that will adjust the cost of infrastructure lower based on a nations resources, improvements and wonders\n    ///@notice aluminium will reduce the cost of infrastructure by 7%\n    ///@notice coal will reduce the cost of infrastructure by 4%\n    ///@notice steel will reduce the cost of infrastructure by 2%\n    ///@notice asphalt will reduce the cost of infrastructure by 5%\n    ///@return uint256 this will be the multiplier reductions from this formula\n    function getInfrastructureCostMultiplier3(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 multiplier = 0;\n        bool isAluminium = res.viewAluminium(id);\n        bool isCoal = res.viewCoal(id);\n        bool isSteel = bonus.viewSteel(id);\n        bool isAsphalt = bonus.viewAsphalt(id);\n        if (isAluminium) {\n            multiplier += 7;\n        }\n        if (isCoal) {\n            multiplier += 4;\n        }\n        if (isSteel) {\n            multiplier += 2;\n        }\n        if (isAsphalt) {\n            multiplier += 5;\n        }\n        return multiplier;\n    }\n\n    ///@dev this is a public view function that will return a boolean value if a nations government type accomodates a reduced infrastructure cost\n    ///@notice this function will check if the given nation has a governemnt type that accomodate a lower cost of infrastructure\n    ///@param countryId is the nation ID of the country being queried\n    ///@return bool will be true if the nation's government type accomodates a lower infrastructure cost\n    function checkAccomodativeGovernment(\n        uint256 countryId\n    ) public view returns (bool) {\n        uint256 governmentType = param.getGovernmentType(countryId);\n        if (\n            governmentType == 1 ||\n            governmentType == 4 ||\n            governmentType == 5 ||\n            governmentType == 6 ||\n            governmentType == 7 ||\n            governmentType == 8\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    ///@dev this is a public function callable by the nation owner\n    ///@dev this function will allow a nation owner to destroy infrastructure\n    ///@notice this function will allow a nation owner to destroy infrastructure\n    ///@param id this is the nation id of the nation destroying infrastructure\n    ///@param amount this is the amount of infrastructure being destroyed\n    function destroyInfrastructure(uint256 id, uint256 amount) public {\n        bool owner = mint.checkOwnership(id, msg.sender);\n        require(owner, \"!nation owner\");\n        uint256 currentInfrastructureAmount = inf.getInfrastructureCount(id);\n        require(\n            (currentInfrastructureAmount - amount) >= 0,\n            \"not enough infrastructure\"\n        );\n        inf.decreaseInfrastructureFromMarket(id, amount);\n        emit InfrastructureDestroyed(id, amount);\n    }\n}\n"
    },
    "contracts/IWarBucks.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWarBucks is IERC20 {\n    function mintFromTreasury(address account, uint256 amount) external;\n\n    function burnFromTreasury(address account, uint256 amount) external;\n\n    function burnFromMint(address account, uint256 amount) external;\n}\n"
    },
    "contracts/KeeperFile.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\n// import \"./Nuke.sol\";\n// import \"./Aid.sol\";\n// import \"./War.sol\";\n// import \"./Treasury.sol\";\n// import \"./Forces.sol\";\n// import \"./Navy.sol\";\n// import \"./CountryParameters.sol\";\n// import \"./Military.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\";\n\n///@title KeeperContract\n///@author OxSnosh\n///@dev this contract will allow the chainlink keeper to maintain the game clock that increments daily\ncontract KeeperContract is Ownable, KeeperCompatibleInterface {\n    uint256 public gameDay;\n    uint public interval;\n    uint public lastTimeStamp;\n    address public keeperRegistry;\n\n    event GameDayIncremented(uint256 indexed gameDay);\n\n    constructor(uint updateInterval) {\n        interval = updateInterval;\n        lastTimeStamp = block.timestamp;\n        gameDay = 0;\n    }\n\n    function checkUpkeep(\n        bytes calldata /* checkData */\n    )\n        external\n        view\n        override\n        returns (bool upkeepNeeded, bytes memory /* performData */)\n    {\n        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;\n        return (upkeepNeeded, \"\");\n    }\n\n    function performUpkeep(bytes calldata /* performData */) external override {\n        if ((block.timestamp - lastTimeStamp) > interval) {\n            lastTimeStamp = lastTimeStamp + interval;\n            gameDay++;\n            emit GameDayIncremented(gameDay);\n        } else {\n            revert(\"Not enough time has passed for upkeep\");\n        }\n    }\n\n    function incrementGameDay() public onlyOwner {\n        gameDay++;\n        lastTimeStamp = block.timestamp;\n        emit GameDayIncremented(gameDay);\n    }\n\n    function updateKeeperRegistry(address _keeperRegistry) public onlyOwner {\n        keeperRegistry = _keeperRegistry;\n    }\n\n    function ipdateInterval(uint _interval) public onlyOwner {\n        interval = _interval;\n    }\n\n    function getGameDay() public view returns (uint256) {\n        return gameDay;\n    }\n}\n"
    },
    "contracts/LandMarket.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./CountryMinter.sol\";\nimport \"./Resources.sol\";\nimport \"./Treasury.sol\";\nimport \"./Infrastructure.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n///@title LandMarketContract\n///@author OxSnosh\n///@notice this contract will allow a nation owner to purchase land\n///@dev this contract inherits from openzeppelin's ownable contract\ncontract LandMarketContract is Ownable {\n    address public countryMinter;\n    address public resources;\n    address public infrastructure;\n    address public treasury;\n\n    CountryMinter mint;\n    ResourcesContract res;\n    InfrastructureContract inf;\n    TreasuryContract tsy;\n\n    event LandPurchased(uint256 indexed id, uint256 indexed amount, uint256 indexed cost);\n\n    event LandDestroyed(uint256 indexed id, uint256 indexed amount);\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _resources,\n        address _countryMinter,\n        address _infrastructure,\n        address _treasury\n    ) public onlyOwner {\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        treasury = _treasury;\n        tsy = TreasuryContract(_treasury);\n    }\n\n    ///@dev this is a public view function that will allow a nation owner to buy land\n    ///@dev this function is only callable by the nation owner\n    ///@notice this function will allow a nation owner to purchase land\n    ///@param id is the nation id of the nation purchasing land\n    ///@param amount is the amount of land being purchased\n    function buyLand(uint256 id, uint256 amount) public {\n        bool owner = mint.checkOwnership(id, msg.sender);\n        require(owner, \"!nation owner\");\n        uint256 cost = getLandCost(id, amount);\n        inf.increaseLandCountFromMarket(id, amount);\n        tsy.spendBalance(id, cost);\n        emit LandPurchased(id, amount, cost);\n    }\n\n    ///@dev this is a public view function that will return the cost of a land purchase\n    ///@dev this function multiplies the cost per level by the purchases amount\n    ///@notice this function will return the cost of a land purchase\n    ///@param id is the nation id of the nation buying land\n    ///@param amount this is the amount of land being purchased\n    ///@return uint256 this is the cost of the purchase\n    function getLandCost(uint256 id, uint256 amount) public view returns (uint256) {\n        uint256 costPerMile = getLandCostPerMile(id);\n        uint256 cost = (costPerMile * amount);\n        return cost;\n    }\n\n    ///@dev this is a public view functon that will return the land cost per mile\n    ///@notice this function will return the cost of land per mile for a nation\n    ///@notice cartain modifiers in the following functions will reduce the cost of land\n    ///@param id this is the nation id making the purchase\n    ///@return uint256 this is the cost per level of a land purchase\n    function getLandCostPerMile(uint256 id) public view returns (uint256) {\n        uint256 currentLand = inf.getLandCount(id);\n        uint256 costPerLevel = 400;\n        if (currentLand < 30) {\n            costPerLevel = (400 + (currentLand * 2));\n        } else if (currentLand < 100) {\n            costPerLevel = (400 + (currentLand * 3));\n        } else if (currentLand < 200) {\n            costPerLevel = (400 + (currentLand * 5));\n        } else if (currentLand < 250) {\n            costPerLevel = (400 + (currentLand * 10));\n        } else if (currentLand < 300) {\n            costPerLevel = (400 + (currentLand * 15));\n        } else if (currentLand < 400) {\n            costPerLevel = (400 + (currentLand * 20));\n        } else if (currentLand < 500) {\n            costPerLevel = (400 + (currentLand * 25));\n        } else if (currentLand < 800) {\n            costPerLevel = (400 + (currentLand * 30));\n        } else if (currentLand < 1200) {\n            costPerLevel = (400 + (currentLand * 35));\n        } else if (currentLand < 2000) {\n            costPerLevel = (400 + (currentLand * 40));\n        } else if (currentLand < 3000) {\n            costPerLevel = (400 + (currentLand * 45));\n        } else if (currentLand < 4000) {\n            costPerLevel = (400 + (currentLand * 55));\n        } else {\n            costPerLevel = (400 + (currentLand * 75));\n        }\n        uint256 purchasePriceMultiplier = getLandPriceMultiplier(id);\n        uint256 adjustedCostPerMile = ((costPerLevel * purchasePriceMultiplier) /\n            100);\n        return adjustedCostPerMile * (10**18);\n    }\n\n    ///@dev this function  will adjust the cost of land lower\n    ///@dev this function is a public view function that will get called when land is quoted or purchased\n    ///@notice this function will adjust the cost of land lower based on a nations resources, improvements and wonders\n    ///@notice cattle will reduce the cost of land by 10%\n    ///@notice fish will reduce the cost of land by 5%\n    ///@notice rubber will reduce the cost of land by 10%\n    ///@return uint256 this will be the multiplier reductions from this formula\n    function getLandPriceMultiplier(uint256 id) public view returns (uint256) {\n        uint256 multiplier = 100;\n        bool cattle = res.viewCattle(id);\n        if (cattle) {\n            multiplier -= 10;\n        }\n        bool fish = res.viewFish(id);\n        if (fish) {\n            multiplier -= 5;\n        }\n        bool rubber = res.viewRubber(id);\n        if (rubber) {\n            multiplier -= 10;\n        }\n        return multiplier;\n    }\n\n    \n    ///@dev this is a public function callable by the nation owner \n    ///@dev this function will allow a nation owner to destroy land\n    ///@notice this function will allow a nation owner to destroy land\n    ///@param id this is the nation id of the nation destroying land\n    ///@param amount this is the amount of land being destroyed\n    function destroyLand(uint256 id, uint256 amount) public {\n        bool owner = mint.checkOwnership(id, msg.sender);\n        require(owner, \"!nation owner\");\n        uint256 currentLandAmount = inf.getLandCount(id);\n        require((currentLandAmount - amount) >= 0, \"not enough land\");\n        inf.decreaseLandCountFromMarket(id, amount);\n        emit LandDestroyed(id, amount);\n    }\n}\n"
    },
    "contracts/Messenger.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\n///@title Messenger\n///@author OxSnosh\n///@notice this contract will allow a user to send a message to another user or post updated\n///@dev this contract inherits from openzeppelin's ownable contract\n\ncontract Messenger {\n\n    mapping(address => string) public messages;\n\n    event MessageSent(address indexed sender, address indexed receiver, string message);\n\n    ///@dev this function will allow a user to send a message to another user\n    ///@param _receiver is the address of the user receiving the message\n    ///@param _message is the message being sent\n    function sendMessage(address _receiver, string memory _message) public {\n        messages[_receiver] = _message;\n        emit MessageSent(msg.sender, _receiver, _message);\n    }\n\n\n    mapping(address => string) public posts;\n\n    event PostSent(address indexed sender, string post);\n\n    ///@dev this function will allow a user to post a message\n    ///@param _post is the message being posted\n    function postMessage(string memory _post) public {\n        posts[msg.sender] = _post;\n        emit PostSent(msg.sender, _post);\n    }\n\n}\n\n"
    },
    "contracts/MetaNationsGovToken.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title MetaNationsGovToken This is the token used to purchase nation NFTs\n/// @author OxSnosh\n/// @notice This token is spent at the amount equivalent cost in USDC to the seed money of the nation\ncontract MetaNationsGovToken is ERC20, Ownable {\n\n    /// @param initialSupply is the initial supply minted of MetaNationsGovToekn\n    /// @dev the initialSupply is minted to the deployer of the contract\n    constructor(uint256 initialSupply) ERC20(\"MetaNations Governance Token\", \"MNGT\") {\n        _mint(msg.sender, initialSupply);\n    }\n}\n"
    },
    "contracts/Military.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./SpyOperations.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./KeeperFile.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n///@title MilitaryContract\n///@author OxSnosh\n///@dev this contract inherits from openzeppelin's ownable contract\n///@notice this contract will allow a nation owner to control their defcon level, threat level and war/peace preference\ncontract MilitaryContract is Ownable {\n    address public spyAddress;\n    address public countryMinter;\n    address public keeper;\n\n    SpyOperationsContract spy;\n    CountryMinter mint;\n    KeeperContract keep;\n\n    struct Military {\n        uint256 defconLevel;\n        uint256 threatLevel;\n        bool warPeacePreference;\n        uint256 dayPeaceToggled;\n    }\n\n    event DefconLevelUpdated(uint256 indexed id, uint256 indexed newLevel);\n\n    event ThreatLevelUpdated(uint256 indexed id, uint256 indexed newLevel);\n\n    event WarPeacePreferenceToggled(\n        uint256 indexed id,\n        bool indexed warPeacePreference\n    );\n\n    mapping(uint256 => Military) public idToMilitary;\n\n    modifier onlySpyContract() {\n        require(msg.sender == spyAddress, \"only callable from spy contract\");\n        _;\n    }\n\n    modifier onlyCountryMinter() {\n        require(msg.sender == countryMinter, \"only callable from country minter contract\");\n        _;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings (address _spyAddress, address _countryMinter, address _keeper) public onlyOwner {\n        spyAddress = _spyAddress;\n        spy = SpyOperationsContract(_spyAddress);\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        keeper = _keeper;\n        keep = KeeperContract(_keeper);\n    }\n\n    ///@dev this function is a public function only callable from the country minter contract\n    ///@notice this function will allow allow a nation owner to reset their defcon and threat level and toggle their war peace preference\n    function generateMilitary(uint256 id) public onlyCountryMinter {\n        Military memory newMilitary = Military(5, 1, false, 0);\n        idToMilitary[id] = newMilitary;\n    }\n\n    ///@dev this is a public function only callable by the nation owner\n    ///@dev this function will allow a nation owner to update their defcon level\n    ///@notice this function will allow a nation owner to update their defcon level\n    ///@param newDefcon is the new defcon which must be an integer between 1 and 5\n    ///@param id is the nation id of the nation updating their defcon\n    function updateDefconLevel(uint256 newDefcon, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require (isOwner, \"!nation owner\");\n        require(\n            newDefcon == 1 ||\n                newDefcon == 2 ||\n                newDefcon == 3 ||\n                newDefcon == 4 ||\n                newDefcon == 5,\n            \"New DEFCON level is not an integer between 1 and 5\"\n        );\n        idToMilitary[id].defconLevel = newDefcon;\n        emit DefconLevelUpdated(id, newDefcon);\n    }\n\n    ///@dev this function will only be callable from the Spy contract\n    ///@dev this function will allow a successful spy operation to update the defcon level\n    ///@notice this function will allow a succesful spy attack to update the defcon level\n    ///@param id is the nation id that was attacked and getting their defcon reset\n    ///@param newLevel is the new defcon level being set during the attack\n    function setDefconLevelFromSpyContract(uint256 id, uint256 newLevel) public onlySpyContract {\n        idToMilitary[id].defconLevel = newLevel;\n    }\n\n    ///@dev this is a public function only callable by the nation owner\n    ///@dev this function allows a nation owner to update the threat level of a nation\n    ///@notice this function allows a nation owner to update the threat level of a nation\n    ///@param newThreatLevel is the new threat level being updated\n    ///@param id is the nation id of the nation updating the threat level\n    function updateThreatLevel(uint256 newThreatLevel, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require (isOwner, \"!nation owner\");\n        require(\n            newThreatLevel == 1 ||\n                newThreatLevel == 2 ||\n                newThreatLevel == 3 ||\n                newThreatLevel == 4 ||\n                newThreatLevel == 5,\n            \"Not a valid threat level\"\n        );\n        idToMilitary[id].threatLevel = newThreatLevel;\n        emit ThreatLevelUpdated(id, newThreatLevel);\n    }\n\n    ///@dev this function will only be callable from the Spy contract\n    ///@dev this function will allow a successful spy operation to update the threat level\n    ///@notice this function will allow a succesful spy attack to update the threat level\n    ///@param id is the nation id that was attacked and getting their threat level reset\n    ///@param newLevel is the new threat level being set during the attack\n    function setThreatLevelFromSpyContract(uint256 id, uint256 newLevel)\n        public\n        onlySpyContract\n    {\n        idToMilitary[id].threatLevel = newLevel;\n    }\n\n    ///@dev this function is a public function only callable from the nation owner\n    ///@dev this function will allow a nation to toggle their prefernece for peace or war\n    ///@notice this function will allow a nation to toggle their prefernece for peace or war\n    ///@param id is the nation id of the nation toggling their preference\n    function toggleWarPeacePreference(uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require (isOwner, \"!nation owner\");\n        uint256 gameDay = keep.getGameDay();\n        if (idToMilitary[id].warPeacePreference == true) {\n            require(\n                (gameDay - idToMilitary[id].dayPeaceToggled) >= 7,\n                \"Must wait 7 days to switch to peace mode\"\n            );\n            idToMilitary[id].warPeacePreference = false;\n            idToMilitary[id].dayPeaceToggled = gameDay;\n        } else {\n            idToMilitary[id].warPeacePreference = true;\n            idToMilitary[id].dayPeaceToggled = gameDay;\n        }\n        emit WarPeacePreferenceToggled(id, idToMilitary[id].warPeacePreference);\n    }\n\n    ///@dev this is a public view function that will return a nations defcon level\n    ///@param id is the nation id of the nation being queried\n    ///@return uint256 is the defcon level for a given nation\n    function getDefconLevel(uint256 id) public view returns (uint256) {\n        uint256 defcon = idToMilitary[id].defconLevel;\n        return defcon;\n    }\n\n    ///@dev this is a public view function that will return a nations threat level\n    ///@param id is the nation id of the nation being queried\n    ///@return uint256 is the threat level for a given nation\n    function getThreatLevel(uint256 id) public view returns (uint256) {\n        uint256 threatLevel = idToMilitary[id].threatLevel;\n        return threatLevel;\n    }\n\n    ///@dev this is a public view function that will return a nations preference for war\n    ///@param id is the nation id of the nation being queried\n    ///@return bool is true if war is possible\n    function getWarPeacePreference(uint256 id) public view returns (bool, uint256) {\n        bool war = idToMilitary[id].warPeacePreference;\n        uint256 daysPeaceToggled = idToMilitary[id].dayPeaceToggled;\n        uint256 gameDay = keep.getGameDay();\n        uint256 daysReamaining;\n        if (war == true) {\n            daysReamaining = 7 - (gameDay - daysPeaceToggled);\n        } else {\n            daysReamaining = 0;\n        }\n        return (war, daysReamaining);\n    }\n\n    function getDaysInPeaceMode(uint256 id) public view returns (uint256) {\n        uint256 daysPeaceToggled = idToMilitary[id].dayPeaceToggled;\n        uint256 gameDay = keep.getGameDay();\n        uint256 daysInPeaceMode = (gameDay - daysPeaceToggled);\n        return daysInPeaceMode;\n    }\n}\n"
    },
    "contracts/Missiles.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./Treasury.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Resources.sol\";\nimport \"./Wonders.sol\";\nimport \"./Improvements.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./War.sol\";\nimport \"./NationStrength.sol\";\nimport \"./GroundBattle.sol\";\nimport \"./KeeperFile.sol\";\nimport \"./CountryParameters.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"hardhat/console.sol\";\n\n///@title MissilesContract\n///@author OxSnosh\n///@dev this contract will allow a nation to purchase cruise missiles and nukes\n///@dev this contract inherits from the openzeppelin ownable contract\ncontract MissilesContract is Ownable {\n    uint256 public cruiseMissileCost = 20000 * (10 ** 18);\n    uint256 public defaultNukeCost = 500000 * (10 ** 18);\n    uint256 public nukeCost;\n    address public countryMinter;\n    address public treasury;\n    address public spyAddress;\n    address public resources;\n    address public improvements1;\n    address public wonders1;\n    address public wonders2;\n    address public wonders4;\n    address public nukeAddress;\n    address public airBattle;\n    address public countryinter;\n    address public strength;\n    address public keeper;\n    address public infrastructure;\n\n    CountryMinter mint;\n    InfrastructureContract inf;\n    ResourcesContract res;\n    WondersContract1 won1;\n    WondersContract2 won2;\n    WondersContract4 won4;\n    ImprovementsContract1 imp1;\n    ImprovementsContract2 imp2;\n    WarContract war;\n    TreasuryContract tsy;\n    NationStrengthContract stren;\n    KeeperContract keep;\n\n    struct Missiles {\n        uint256 cruiseMissiles;\n        uint256 nuclearWeapons;\n    }\n\n    mapping(uint256 => mapping(uint256 => uint256))\n        public idToNukesPurchasedToday;\n\n    event CruiseMissilesPurchased(\n        uint256 indexed id,\n        uint256 indexed amountPurchased\n    );\n\n    event NukePurchased(uint256 indexed id);\n\n    event CruiseMissilesDestroyedByAirAssault(\n        uint256 indexed id,\n        uint256 amountDestroyed\n    );\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _treasury,\n        address _spyAddress,\n        address _nukeAddress,\n        address _airBattle,\n        address _wonders2,\n        address _strength,\n        address _infrastructure\n    ) public onlyOwner {\n        treasury = _treasury;\n        tsy = TreasuryContract(_treasury);\n        spyAddress = _spyAddress;\n        nukeAddress = _nukeAddress;\n        airBattle = _airBattle;\n        wonders2 = _wonders2;\n        won2 = WondersContract2(_wonders2);\n        strength = _strength;\n        stren = NationStrengthContract(_strength);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings2(\n        address _resources,\n        address _improvements1,\n        address _wonders1,\n        address _wonders4,\n        address _countryMinter,\n        address _keeper\n    ) public onlyOwner {\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        wonders4 = _wonders4;\n        won4 = WondersContract4(_wonders4);\n        improvements1 = _improvements1;\n        imp1 = ImprovementsContract1(_improvements1);\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        keeper = _keeper;\n        keep = KeeperContract(_keeper);\n    }\n\n    mapping(uint256 => Missiles) public idToMissiles;\n\n    function generateMissiles(uint256 id) public {\n        Missiles memory newMissiles = Missiles(0, 0);\n        idToMissiles[id] = newMissiles;\n    }\n\n    modifier onlySpyContract() {\n        require(msg.sender == spyAddress, \"only callable from spy contract\");\n        _;\n    }\n\n    modifier onlyNukeContract() {\n        require(msg.sender == nukeAddress, \"only callable from nuke contract\");\n        _;\n    }\n\n    modifier onlyAirBattle() {\n        require(\n            msg.sender == airBattle,\n            \"only callable from air battle contract\"\n        );\n        _;\n    }\n\n    ///@dev this function is a public function that will allow a nation owner to purchase cruise missiles\n    ///@notice this function allows a nation owner to purchase cruise missiles\n    ///@param amount is the amount of cruise missiles being purchased\n    ///@param id is the nation id of the nation buying cruise missiles\n    function buyCruiseMissiles(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 techAmount = inf.getTechnologyCount(id);\n        require(techAmount >= 15, \"requires 15 tech\");\n        uint256 costPerMissile = getCruiseMissileCost(id);\n        uint256 cost = (costPerMissile * amount);\n        tsy.spendBalance(id, cost);\n        idToMissiles[id].cruiseMissiles += amount;\n        emit CruiseMissilesPurchased(id, amount);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateCruiseMissileCost(uint256 newPrice) public onlyOwner {\n        cruiseMissileCost = newPrice;\n    }\n\n    ///@dev this is a public view function that will return the cost per missiile of cruise missiles for a nation\n    ///@notice this function will return the cost per cruise missile for a given nation\n    ///@param id is the nation id of the nation purchasing missiles\n    ///@return cost is the cost per missile of cruise missiles for that nation\n    function getCruiseMissileCost(\n        uint256 id\n    ) public view returns (uint256 cost) {\n        uint256 basePurchasePrice = cruiseMissileCost;\n        uint256 factoryCount = imp1.getFactoryCount(id);\n        uint256 costModifier = 100;\n        if (factoryCount > 0) {\n            costModifier -= (factoryCount * 5);\n        }\n        bool lead = res.viewLead(id);\n        if (lead) {\n            costModifier -= 20;\n        }\n        uint256 costPerMissile = ((basePurchasePrice * costModifier) / 100);\n        return costPerMissile;\n    }\n\n    ///@dev this is a public view function that will return the number of cruise missile a nation owns\n    ///@notice this function will return the number of cruise missiles a given nation owns\n    ///@param id is the nation ID of the nation being queried\n    ///@return uint256 is the number of cruise missiles a given nation owns\n    function getCruiseMissileCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToMissiles[id].cruiseMissiles;\n        return count;\n    }\n\n    ///@dev this is a public function that will decrease the number of cruise missiles only callable from the spy contract\n    ///@notice this function will decrease the number of cruise missiles lost during a spy attack\n    ///@param amount this is the number of missiles being destroyed\n    ///@param id this is the nation id of the nation being attacked\n    function decreaseCruiseMissileCount(\n        uint256 amount,\n        uint256 id\n    ) public onlySpyContract {\n        uint256 missiles = idToMissiles[id].cruiseMissiles;\n        if (amount >= missiles) {\n            idToMissiles[id].cruiseMissiles = 0;\n        } else {\n            idToMissiles[id].cruiseMissiles -= amount;\n        }\n    }\n\n    ///@dev this is a public function that will decrease the number of cruise missiles only callable from the nuke contract\n    ///@notice this function will decrease the number of cruise missiles lost during a nuke attack\n    ///@notice a succesful nuke attack will destroy 35% of your nations cruise missiles\n    ///@notice a fallout shelter system will reduce the number of missiles lost during a nuke attack to 25%\n    ///@param id this is the nation id of the nation being attacked\n    function decreaseCruiseMissileCountFromNukeContract(\n        uint256 id\n    ) public onlyNukeContract {\n        console.log(\"decreasing cruise missiles\");\n        console.log(\"id\", id);\n        uint256 cruiseMissiles = idToMissiles[id].cruiseMissiles;\n        uint256 percentage = 35;\n        bool falloutShelter = won1.getFalloutShelterSystem(id);\n        if (falloutShelter) {\n            percentage = 25;\n        }\n        uint256 cruiseMissilesToDecrease = ((cruiseMissiles * percentage) /\n            100);\n        idToMissiles[id].cruiseMissiles -= cruiseMissilesToDecrease;\n    }\n\n    ///@dev this is a public function only callable from the air battle contact\n    ///@notice this function will decrease the number of cruise missiles lost during a bombing mission\n    ///@param id this is the nation id of the nation losing missiles from being attacked by bombers\n    ///@param amountToDecrease this is the number of cruise missiles beind destroyed by the bombing mission\n    function decreaseCruiseMissileCountFromAirBattleContract(\n        uint256 id,\n        uint256 amountToDecrease\n    ) public onlyAirBattle {\n        uint256 cruiseMissiles = idToMissiles[id].cruiseMissiles;\n        if (amountToDecrease >= cruiseMissiles) {\n            idToMissiles[id].cruiseMissiles = 0;\n            amountToDecrease = cruiseMissiles;\n        } else {\n            idToMissiles[id].cruiseMissiles -= amountToDecrease;\n        }\n        emit CruiseMissilesDestroyedByAirAssault(id, amountToDecrease);\n    }\n\n    ///@dev this is a public function that will allow a nation owner to purchase nukes\n    ///@notice this function allows a nation owner to purchase nukes\n    ///@notice requirements to purchase nukes are 75 technology, 1000 infrastructure and access to uranium\n    ///@notice a nation must also have a nation strength of 150,000 or a manhattan project to purchase nukes\n    ///@notice a nation owner can only purchase one nuke per day (2 with a weapons research center)\n    ///@param id is the nation id of the nation purchasing nukes\n    function buyNukes(uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 techAmount = inf.getTechnologyCount(id);\n        require(techAmount >= 75, \"requires 75 tech\");\n        uint256 infrastructureAmount = inf.getInfrastructureCount(id);\n        require(infrastructureAmount >= 1000, \"insufficient infrastructure\");\n        bool isUranium = res.viewUranium(id);\n        require(isUranium, \"no uranium\");\n        uint256 nationStrength = stren.getNationStrength(id);\n        bool manhattanProject = won2.getManhattanProject(id);\n        require(\n            nationStrength > 150000 || manhattanProject,\n            \"nation strength too low\"\n        );\n        uint256 day = keep.getGameDay();\n        uint256 nukesPurchasedToday = idToNukesPurchasedToday[id][day];\n        uint256 maxNukesPerDay = 1;\n        bool weaponsResearchCenter = won4.getWeaponsResearchCenter(id);\n        if (weaponsResearchCenter) {\n            maxNukesPerDay = 2;\n        }\n        require(\n            nukesPurchasedToday < maxNukesPerDay,\n            \"already purchased nuke today\"\n        );\n        idToNukesPurchasedToday[id][day] += 1;\n        idToMissiles[id].nuclearWeapons += 1;\n        uint256 cost = getNukeCost(id);\n        tsy.spendBalance(id, cost);\n        emit NukePurchased(id);\n    }\n\n    ///@dev this is a public function that will return the cost per nuke for a nation\n    ///@notice this function will return the cost per nuke for a nation\n    ///@notice nukes cost 500,000 + (50,000 * current nuke count)\n    ///@param id is the nation ID of the nation being queried\n    ///@return uint256 is the cost per nuke for a given nation\n    function getNukeCost(uint256 id) public view returns (uint256) {\n        uint256 nukeCount = idToMissiles[id].nuclearWeapons;\n        uint256 cost = (defaultNukeCost + (nukeCount * 50000));\n        uint256 mod = 100;\n        bool lead = res.viewLead(id);\n        if (lead) {\n            mod = 80;\n        }\n        cost = ((cost * mod) / 100);\n        return cost;\n    }\n\n    function updateDefaultNukeCost(uint256 newCost) public onlyOwner {\n        defaultNukeCost = newCost;\n    }\n\n    function getDefaultNukeCost() public view returns (uint256) {\n        return defaultNukeCost;\n    }\n\n    function getNukesPurchasedToday(uint256 id) public view returns (uint256) {\n        uint256 day = keep.getGameDay();\n        return idToNukesPurchasedToday[id][day];\n    }\n\n    ///@dev this is a public view function that will retrun a nations current nuke count\n    ///@notice this function retrurns a nations current nuke count\n    ///@param id this is the nation ID for the nation being queried\n    ///@return uint256 this is the current nuke count for a given nation\n    function getNukeCount(uint256 id) public view returns (uint256) {\n        uint256 count = idToMissiles[id].nuclearWeapons;\n        return count;\n    }\n\n    ///@dev this is a public function that will decrease the nuke count for a nation by 1 when a nuke is launched from the nuke contract\n    ///@dev this function is only callable from the nuke contract\n    ///@notice this function will decrease a nations nuke count by 1 when a nuke is launched\n    ///@param id is the nation id of the nation launching the nuke that will have its nuke count decreased by 1\n    function decreaseNukeCountFromNukeContract(\n        uint256 id\n    ) public onlyNukeContract {\n        idToMissiles[id].nuclearWeapons -= 1;\n    }\n\n    ///@dev this is a public function that will decrease the nuke count for a nation when a successful spy attack is executed\n    ///@dev this function is only callable from the spy contract\n    ///@notice this function will decrease a nations nuke count if they are successfully attacked by a spy\n    ///@param id is the nation id of the nation that was attacked and is losing a nuke\n    function decreaseNukeCountFromSpyContract(\n        uint256 id\n    ) public onlySpyContract {\n        bool silo = won2.getHiddenNuclearMissileSilo(id);\n        uint256 nukeCount = getNukeCount(id);\n        uint256 requiredNukeAmount = 1;\n        if (silo) {\n            requiredNukeAmount = 6;\n        }\n        require(nukeCount >= requiredNukeAmount, \"no nukes to destroy\");\n        idToMissiles[id].nuclearWeapons -= 1;\n    }\n}"
    },
    "contracts/NationStrength.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./Infrastructure.sol\";\nimport \"./Forces.sol\";\nimport \"./Fighters.sol\";\nimport \"./Bombers.sol\";\nimport \"./Navy.sol\";\nimport \"./Missiles.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"hardhat/console.sol\";\n\n///@title NationStrengthContract\n///@author OxSnosh\n///@dev this contract inherits from openzeppelin's ownable contract\n///@notice this contract will calculate a given nation's strength\ncontract NationStrengthContract is Ownable {\n    address public infrastructure;\n    address public forces;\n    address public fighters;\n    address public bombers;\n    address public navy;\n    address public missiles;\n    address public navy2;\n\n    InfrastructureContract inf;\n    ForcesContract frc;\n    FightersContract fight;\n    BombersContract bomb;\n    NavyContract nav;\n    MissilesContract mis;\n    NavyContract2 nav2;\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings (\n        address _infrastructure,\n        address _forces,\n        address _fighters,\n        address _bombers,\n        address _navy,\n        address _missiles,\n        address _navy2\n    ) public onlyOwner {\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        forces = _forces;\n        frc = ForcesContract(_forces);\n        fighters = _fighters;\n        fight = FightersContract(_fighters);\n        bombers = _bombers;\n        bomb = BombersContract(_bombers);\n        navy = _navy;\n        nav = NavyContract(_navy);\n        missiles = _missiles;\n        mis = MissilesContract(_missiles);\n        navy2 = _navy2;\n        nav2 = NavyContract2(_navy2);\n    }\n\n    \n    ///@dev this function is only callable by the contract owner\n    function updateInfrastructureContract(address newAddress) public onlyOwner {\n        infrastructure = newAddress;\n        inf = InfrastructureContract(newAddress);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateForcesContract(address newAddress) public onlyOwner {\n        forces = newAddress;\n        frc = ForcesContract(newAddress);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateFightersContract(address newAddress) public onlyOwner {\n        fighters = newAddress;\n        fight = FightersContract(newAddress);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateBombersContract(address newAddress) public onlyOwner {\n        bombers = newAddress;\n        bomb = BombersContract(newAddress);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateNavyContract(address newAddress) public onlyOwner {\n        navy = newAddress;\n        nav = NavyContract(newAddress);\n    }\n\n    ///@dev this is a public view function that will return a nation's strength\n    ///@notice this function will return a given nations strength\n    ///@notice strength is calculated in the following way\n    /**\n     * land purchased * 1.5 +\n     * infra * 3 +\n     * tech * 5 +\n     * soldiers * .02 +\n     * tanks deployed * .15 +\n     * tanks defending * .20 +\n     * aircraft rankings * 5 +\n     * navy rankings * 10\n     * cruise missiles * 10 +\n     * nukes ** 2 * 10 +\n    */\n    ///@param id is the nation id of the nation being queried\n    ///@return uint256 is the nations strength\n    function getNationStrength(uint256 id) public view returns (uint256) {\n        uint256 nationStrengthFromCommodities = getNationStrengthFromCommodities(\n                id\n            );\n        uint256 nationStrengthFromMilitary = getNationStrengthFromMilitary(id);\n        uint256 nationStrength = nationStrengthFromCommodities +\n            nationStrengthFromMilitary;\n        return nationStrength;\n    }\n\n    function getNationStrengthFromCommodities(uint256 id)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 landCount = inf.getLandCount(id);\n        uint256 techCount = inf.getTechnologyCount(id);\n        uint256 infrastructureCount = inf.getInfrastructureCount(id);\n        uint256 strengthFromCommodities = (((landCount * 150) +\n            (techCount * 500) +\n            (infrastructureCount * 300)) / 100);\n        return strengthFromCommodities;\n    }\n\n    function getNationStrengthFromMilitary(uint256 id)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 soldierCount = frc.getSoldierCount(id);\n        uint256 soldierStrength = ((soldierCount * 2) / 100);\n        uint256 deployedTankCount = frc.getDeployedTankCount(id);\n        uint256 defendingTankCount = frc.getDefendingTankCount(id);\n        uint256 tankStrength = (((deployedTankCount * 15) +\n            (defendingTankCount * 20)) / 100);\n        uint256 additionalStrength = getAdditionalStrengthFromMiliary(id);\n        uint256 strengthFromMilitary = (soldierStrength +\n            tankStrength +\n            additionalStrength);\n        return strengthFromMilitary;\n    }\n\n    function getAdditionalStrengthFromMiliary(uint256 id) public view returns (uint256) {\n        uint256 cruiseMissileCount = mis.getCruiseMissileCount(id);\n        uint256 cruiseMissileStrength = ((cruiseMissileCount * 10));\n        uint256 nukeCount = mis.getNukeCount(id);\n        uint256 nukeStrengthBase = (nukeCount**2);\n        uint256 nukeStrength = (nukeStrengthBase * 10);\n        uint256 aircraftStrength = getStrengthFromAirForce(id);\n        uint256 navyStrength = getStrengthFromNavy(id);\n        uint256 additionalStrengthFromMilitary = (cruiseMissileStrength +\n            nukeStrength +\n            aircraftStrength +\n            navyStrength);\n        return additionalStrengthFromMilitary;\n    }\n\n    function getStrengthFromAirForce(uint256 id)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 defendingFighterStrength = getStrengthFromFighters(id);\n        uint256 defendingBomberStrength = getStrengthFromBombers(id);\n        uint256 strengthFromAirForce = (defendingFighterStrength +\n            defendingBomberStrength);\n        return strengthFromAirForce;\n    }\n\n    function getStrengthFromFighters(uint256 id)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 yak9Count = fight.getYak9Count(id);\n        uint256 p51MustangCount = fight.getP51MustangCount(id);\n        uint256 f86SabreCount = fight.getF86SabreCount(id);\n        uint256 mig15Count = fight.getMig15Count(id);\n        uint256 f100SuperSabreCount = fight.getF100SuperSabreCount(id);\n        uint256 additionalFighterStrength = getAdditionalStrengthFromFighters(\n                id\n            );\n        uint256 strengthFromFighters = (((yak9Count * 1) +\n            (p51MustangCount * 2) +\n            (f86SabreCount * 3) +\n            (mig15Count * 4) +\n            (f100SuperSabreCount * 5) +\n            additionalFighterStrength) * 5);\n        return strengthFromFighters;\n    }\n\n    function getAdditionalStrengthFromFighters(uint256 id)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 f35LightningCount = fight.getF35LightningCount(id);\n        uint256 f15EagleCount = fight.getF15EagleCount(id);\n        uint256 su30MkiCount = fight.getSu30MkiCount(id);\n        uint256 f22RaptorCount = fight.getF22RaptorCount(id);\n        uint256 additionalFighterStrength = ((f35LightningCount * 6) +\n            (f15EagleCount * 7) +\n            (su30MkiCount * 8) +\n            (f22RaptorCount * 9));\n        return additionalFighterStrength;\n    }\n\n    function getStrengthFromBombers(uint256 id)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 ah1CobraCount = bomb.getAh1CobraCount(id);\n        uint256 ah64ApacheCount = bomb.getAh64ApacheCount(id);\n        uint256 bristolBlenheimCount = bomb.getBristolBlenheimCount(\n            id\n        );\n        uint256 b52MitchellCount = bomb.getB52MitchellCount(id);\n        uint256 b17gFlyingFortressCount = bomb\n            .getB17gFlyingFortressCount(id);\n        uint256 additionalStrengthFromBombers = getAdditionalStrengthFromBombers(\n                id\n            );\n        uint256 strengthFromBombers = (((ah1CobraCount * 1) +\n            (ah64ApacheCount * 2) +\n            (bristolBlenheimCount * 3) +\n            (b52MitchellCount * 4) +\n            (b17gFlyingFortressCount * 5) +\n            additionalStrengthFromBombers) * 5);\n        return strengthFromBombers;\n    }\n\n    function getAdditionalStrengthFromBombers(uint256 id)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 b52StratofortressCount = bomb\n            .getB52StratofortressCount(id);\n        uint256 b2SpiritCount = bomb.getB2SpiritCount(id);\n        uint256 b1bLancerCount = bomb.getB1bLancerCount(id);\n        uint256 tupolevTu160Count = bomb.getTupolevTu160Count(id);\n        uint256 additionalStrengthFromBombers = ((b52StratofortressCount * 6) +\n            (b2SpiritCount * 7) +\n            (b1bLancerCount * 8) +\n            (tupolevTu160Count * 9));\n        return additionalStrengthFromBombers;\n    }\n\n    function getStrengthFromNavy(uint256 id) internal view returns (uint256) {\n        uint256 corvetteCount = nav.getCorvetteCount(id);\n        uint256 landingShipCount = nav.getLandingShipCount(id);\n        uint256 battleshipCount = nav.getBattleshipCount(id);\n        uint256 cruiserCount = nav.getCruiserCount(id);\n        uint256 additionalNavyStrength = getAdditionalNavyStrength(id);\n        uint256 strengthFromNavy = (((corvetteCount * 1) +\n            (landingShipCount * 3) +\n            (battleshipCount * 5) +\n            (cruiserCount * 6) +\n            additionalNavyStrength) * 10);\n        return strengthFromNavy;\n    }\n\n    function getAdditionalNavyStrength(uint256 id)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 frigateCount = nav2.getFrigateCount(id);\n        uint256 destroyerCount = nav2.getDestroyerCount(id);\n        uint256 submarineCount = nav2.getSubmarineCount(id);\n        uint256 aircraftCarrierCount = nav2.getAircraftCarrierCount(id);\n        uint256 additionalNavyStrength = ((frigateCount * 8) +\n            (destroyerCount * 11) +\n            (submarineCount * 12) +\n            (aircraftCarrierCount * 15));\n        return additionalNavyStrength;\n    }\n}\n"
    },
    "contracts/Navy.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./Treasury.sol\";\nimport \"./Improvements.sol\";\nimport \"./War.sol\";\nimport \"./Resources.sol\";\nimport \"./Military.sol\";\nimport \"./Nuke.sol\";\nimport \"./Wonders.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./KeeperFile.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"hardhat/console.sol\";\n\n///@title NavalActionsContract\n///@author OxSnosh\n///@dev this contract inherits from openzeppelin's ownable contract\n///@notice this contract will keep track of naval actions (daily blockades, purchases and action slots)\ncontract NavalActionsContract is Ownable {\n    address public keeper;\n    address public navy;\n    address public navy2;\n    address public navalBlockade;\n    address public breakBlockade;\n    address public navalAttack;\n    address public countryMinter;\n\n    CountryMinter mint;\n    KeeperContract keep;\n\n    struct NavalActions {\n        mapping(uint256 => bool) blockadedToday;\n        mapping(uint256 => uint256) purchasesToday;\n        mapping(uint256 => uint256) actionSlotsUsedToday;\n    }\n\n    mapping(uint256 => NavalActions) idToNavalActions;\n    mapping(uint256 => mapping(uint256 => uint256)) public idToDayToPurchases;\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _navalBlockade,\n        address _breakBlockade,\n        address _navalAttack,\n        address _keeper,\n        address _navy,\n        address _navy2,\n        address _countryMinter\n    ) public onlyOwner {\n        navalBlockade = _navalBlockade;\n        breakBlockade = _breakBlockade;\n        navalAttack = _navalAttack;\n        navy = _navy;\n        navy2 = _navy2;\n        keeper = _keeper;\n        keep = KeeperContract(_keeper);\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n    }\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"function only callable from countryMinter\"\n        );\n        _;\n    }\n\n    modifier onlyNavalAction() {\n        require(\n            msg.sender == navalBlockade ||\n                msg.sender == breakBlockade ||\n                msg.sender == navalAttack,\n            \"function only callable from navy contracts\"\n        );\n        _;\n    }\n\n    ///@dev this is a public function that is only callable from the country minter contract\n    ///@dev this function is called when a nation is minted\n    ///@dev this function will initialize the struct that will keep track of action slots, daily blockades and purchases\n    ///@notice this function will allow the contract to keep track of each nations action slots, blockades and purchases\n    ///@param id is the nation ID of the country being minted\n    function generateNavalActions(uint256 id) public onlyCountryMinter {\n        uint256 gameDay = keep.getGameDay();\n        NavalActions storage newNavalActions = idToNavalActions[id];\n        newNavalActions.blockadedToday[gameDay] = false;\n        newNavalActions.purchasesToday[gameDay] = 0;\n        newNavalActions.actionSlotsUsedToday[gameDay] = 0;\n    }\n\n    ///@dev this is a public view function that is only callable from the navy battle contracts\n    ///@dev a nation is only allows to make 3 naval actions per day\n    ///@notice a nation is only allowed to make 3 naval actions per day\n    ///@notice this function will increase naval actions when they occur\n    function increaseAction(uint256 id) public onlyNavalAction {\n        uint256 gameDay = keep.getGameDay();\n        idToNavalActions[id].actionSlotsUsedToday[gameDay] += 1;\n    }\n\n    modifier onlyNavy() {\n        require(\n            msg.sender == navy || msg.sender == navy2,\n            \"function only callable from navy contract\"\n        );\n        _;\n    }\n\n    ///@dev this is a public function that is only callable from the navy contract where purchases occur\n    ///@dev this function will increment a nations daily purchases as purchases occur\n    ///@notice a nation at war can purchase 5 naval ships per day (7 with a foreign naval base)\n    ///@notice during peacetime a nation can purchase 2 naval ships per day (4 with a foreign navla base)\n    ///@param id is the nation id of the nation purchasin vessels\n    ///@param amount is the amount of navy vessels being purchased\n    function increasePurchases(uint256 id, uint256 amount) public onlyNavy {\n        uint256 gameDay = keep.getGameDay();\n        idToNavalActions[id].purchasesToday[gameDay] += amount;\n    }\n\n    modifier onlyBlockade() {\n        require(\n            msg.sender == navalBlockade,\n            \"function only callable from blockade contract\"\n        );\n        _;\n    }\n\n    ///@dev this function is a public function that can only be called by the naval battle contracts\n    ///@dev a nation can only be blockaded once per day\n    ///@notice a nation can only be blockaded once per day\n    ///@notice this function will be called when a nation is blockaded and set the blockadedToday to true\n    ///@param id is the nation id of the nation being blockaded\n    function toggleBlockaded(uint256 id) public onlyNavalAction {\n        uint256 day = keep.getGameDay();\n        idToNavalActions[id].blockadedToday[day] = true;\n    }\n\n    ///@dev this is a public view function that will return a nations daily purchases\n    ///@notice this function will return the amount of vessels a nation purchases today\n    ///@param id is the nation id of the nation being queried\n    ///@return uint256 is the number of ships purchased today\n    function getPurchasesToday(uint256 id) public view returns (uint256) {\n        uint256 gameDay = keep.getGameDay();\n        uint256 purchasesToday = idToNavalActions[id].purchasesToday[gameDay];\n        return purchasesToday;\n    }\n\n    ///@dev this is a public view function that will return a nations daily action slots used\n    ///@notice this function will return the number of action slots a naton has used today\n    ///@param id is the nation id of the nation being queried\n    ///@return uint256 is the number of action slots used today\n    function getActionSlotsUsed(uint256 id) public view returns (uint256) {\n        uint256 gameDay = keep.getGameDay();\n        uint256 actionSlotsUsed = idToNavalActions[id].actionSlotsUsedToday[\n            gameDay\n        ];\n        return actionSlotsUsed;\n    }\n\n    ///@dev this is a public view function that will return a boolean whether a nation has been blockaded today\n    ///@notice this function will return true if a nation has been blockaded today\n    ///@param id is the nation id of the nation being queried\n    ///@return bool will be true if a nation has been blockaded today\n    function getBlockadedToday(uint256 id) public view returns (bool) {\n        uint256 gameDay = keep.getGameDay();\n        bool blockadedToday = idToNavalActions[id].blockadedToday[gameDay];\n        return blockadedToday;\n    }\n}\n\n///@title NavyContract\n///@author OxSnosh\n///@dev this contract inherits from openzeppelin's ownable contract\n///@notice this contract will allow a user to purchase navy vessels\ncontract NavyContract is Ownable {\n    address public treasuryAddress;\n    address public improvementsContract1Address;\n    address public improvementsContract3Address;\n    address public improvements4;\n    address public resources;\n    address public navyBattleAddress;\n    address public military;\n    address public nukes;\n    address public wonders1;\n    address public countryMinter;\n    address public navalActions;\n    address public additionalNavy;\n    address public navy2Contract;\n    address public bonusResources;\n    address public infrastructure;\n    uint256 public corvetteCost = 300000 * (10 ** 18);\n    uint256 public corvetteRequiredInfrastructure = 2000;\n    uint256 public corvetteRequiredTechnology = 200;\n    uint256 public landingShipCost = 300000 * (10 ** 18);\n    uint256 public landingShipRequiredInfrastructure = 2500;\n    uint256 public landingShipRequiredTechnology = 200;\n    uint256 public battleshipCost = 300000 * (10 ** 18);\n    uint256 public battleshipRequiredInfrastructure = 2500;\n    uint256 public battleshipRequiredTechnology = 300;\n    uint256 public cruiserCost = 500000 * (10 ** 18);\n    uint256 public cruiserRequiredInfrastructure = 3000;\n    uint256 public cruiserRequiredTechnology = 350;\n\n    struct Navy {\n        uint256 corvetteCount;\n        uint256 landingShipCount;\n        uint256 battleshipCount;\n        uint256 cruiserCount;\n    }\n\n    mapping(uint256 => Navy) public idToNavy;\n\n    event CorvettePurchased(\n        uint256 indexed id,\n        uint256 indexed amount,\n        uint256 indexed purchasePrice\n    );\n    event LandingShipPurchased(\n        uint256 indexed id,\n        uint256 indexed amount,\n        uint256 indexed purchasePrice\n    );\n    event BattleshipPurchased(\n        uint256 indexed id,\n        uint256 indexed amount,\n        uint256 indexed purchasePrice\n    );\n    event CruiserPurchased(\n        uint256 indexed id,\n        uint256 indexed amount,\n        uint256 indexed purchasePrice\n    );\n\n    event CorvetteDecommissioned(uint256 indexed id, uint256 indexed amount);\n\n    event LandingShipDecommissioned(uint256 indexed id, uint256 indexed amount);\n\n    event BattleshipDecommissioned(uint256 indexed id, uint256 indexed amount);\n\n    event CruiserDecommissioned(uint256 indexed id, uint256 indexed amount);\n\n    event NukeDamageToNavy(\n        uint256 indexed defenderId,\n        uint256 corvetteCount,\n        uint256 landingShip,\n        uint256 cruiserCount,\n        uint256 frigateCount\n    );\n\n    ResourcesContract res;\n    MilitaryContract mil;\n    ImprovementsContract4 imp4;\n    NukeContract nuke;\n    WondersContract1 won1;\n    NavalActionsContract navAct;\n    CountryMinter mint;\n    AdditionalNavyContract addNav;\n    BonusResourcesContract bonus;\n    NavyContract2 navy2;\n    InfrastructureContract inf;\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"function only callable from countryMinter\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _treasuryAddress,\n        address _improvementsContract1Address,\n        address _improvementsContract3Address,\n        address _improvements4,\n        address _resources,\n        address _military,\n        address _nukes,\n        address _wonders1,\n        address _navalActions,\n        address _additionalNavy\n    ) public onlyOwner {\n        treasuryAddress = _treasuryAddress;\n        improvementsContract1Address = _improvementsContract1Address;\n        improvementsContract3Address = _improvementsContract3Address;\n        improvements4 = _improvements4;\n        imp4 = ImprovementsContract4(_improvements4);\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        military = _military;\n        mil = MilitaryContract(_military);\n        nukes = _nukes;\n        nuke = NukeContract(_nukes);\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        navalActions = _navalActions;\n        navAct = NavalActionsContract(_navalActions);\n        additionalNavy = _additionalNavy;\n        addNav = AdditionalNavyContract(_additionalNavy);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings2(\n        address _countryMinter,\n        address _bonusResources,\n        address _navy2,\n        address _infrastructure\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        bonusResources = _bonusResources;\n        bonus = BonusResourcesContract(_bonusResources);\n        navy2Contract = _navy2;\n        navy2 = NavyContract2(_navy2);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n    }\n\n    ///@dev this is a public function only callable from the countryMinter contract\n    ///@dev this function will allow a nation owner to buy navy vessels\n    ///@notice this function will allow a nation owner to buy navy vessels\n    ///@param id this is the nation id of the nation being minted\n    function generateNavy(uint256 id) public onlyCountryMinter {\n        Navy memory newNavy = Navy(0, 0, 0, 0);\n        idToNavy[id] = newNavy;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateCorvetteSpecs(\n        uint256 newPrice,\n        uint256 newRequiredInf,\n        uint256 newRequiredTech\n    ) public onlyOwner {\n        corvetteCost = newPrice;\n        corvetteRequiredInfrastructure = newRequiredInf;\n        corvetteRequiredTechnology = newRequiredTech;\n    }\n\n    function getCorvetteSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            corvetteCost,\n            corvetteRequiredInfrastructure,\n            corvetteRequiredTechnology\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateLandingShipSpecs(\n        uint256 newPrice,\n        uint256 newRequiredInf,\n        uint256 newRequiredTech\n    ) public onlyOwner {\n        landingShipCost = newPrice;\n        landingShipRequiredInfrastructure = newRequiredInf;\n        landingShipRequiredTechnology = newRequiredTech;\n    }\n\n    function getLandingShipSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            landingShipCost,\n            landingShipRequiredInfrastructure,\n            landingShipRequiredTechnology\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateBattleshipSpecs(\n        uint256 newPrice,\n        uint256 newRequiredInf,\n        uint256 newRequiredTech\n    ) public onlyOwner {\n        battleshipCost = newPrice;\n        battleshipRequiredInfrastructure = newRequiredInf;\n        battleshipRequiredTechnology = newRequiredTech;\n    }\n\n    function getBattleshipSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            battleshipCost,\n            battleshipRequiredInfrastructure,\n            battleshipRequiredTechnology\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateCruiserSpecs(\n        uint256 newPrice,\n        uint256 newRequiredInf,\n        uint256 newRequiredTech\n    ) public onlyOwner {\n        cruiserCost = newPrice;\n        cruiserRequiredInfrastructure = newRequiredInf;\n        cruiserRequiredTechnology = newRequiredTech;\n    }\n\n    function getCruiserSpecs() public view returns (uint256, uint256, uint256) {\n        return (\n            cruiserCost,\n            cruiserRequiredInfrastructure,\n            cruiserRequiredTechnology\n        );\n    }\n\n    modifier onlyBattle() {\n        require(msg.sender == navyBattleAddress, \"only callable from battle\");\n        _;\n    }\n\n    ///@dev this is a public function that is only callable from the Navt Battle contract\n    ///@dev this funtion will take the results of a battle and decrease the number of vessels\n    ///@notice this function will take the results of a battle and decrease number of vessels\n    ///@param defenderLosses is an array containing the defenders losses from the battle, each member of the array represents a different vessel\n    ///@param defenderId this is the nation id of the defending nation in the battle\n    ///@param attackerLosses is an array containing the attacker losses from the battle, each memeber of the array represents a different vessel\n    ///@param attackerId this is the nation id of the attacking nation in the battle\n    function decrementLosses(\n        uint256[] memory defenderLosses,\n        uint256 defenderId,\n        uint256[] memory attackerLosses,\n        uint256 attackerId\n    ) public onlyBattle {\n        for (uint256 i; i < defenderLosses.length; i++) {\n            if (defenderLosses[i] == 1) {\n                idToNavy[defenderId].corvetteCount -= 1;\n            } else if (defenderLosses[i] == 2) {\n                idToNavy[defenderId].landingShipCount -= 1;\n            } else if (defenderLosses[i] == 3) {\n                idToNavy[defenderId].battleshipCount -= 1;\n            } else if (defenderLosses[i] == 4) {\n                idToNavy[defenderId].cruiserCount -= 1;\n            } else if (defenderLosses[i] == 5) {\n                navy2.decreaseFrigateCount(defenderId, 1);\n            } else if (defenderLosses[i] == 6) {\n                navy2.decreaseDestroyerCount(defenderId, 1);\n            } else if (defenderLosses[i] == 7) {\n                navy2.decreaseSubmarineCount(defenderId, 1);\n            } else if (defenderLosses[i] == 8) {\n                navy2.decreaseAircraftCarrierCount(defenderId, 1);\n            }\n        }\n        for (uint256 i; i < attackerLosses.length; i++) {\n            if (attackerLosses[i] == 1) {\n                idToNavy[attackerId].corvetteCount -= 1;\n            } else if (defenderLosses[i] == 2) {\n                idToNavy[attackerId].landingShipCount -= 1;\n            } else if (defenderLosses[i] == 3) {\n                idToNavy[attackerId].battleshipCount -= 1;\n            } else if (defenderLosses[i] == 4) {\n                idToNavy[attackerId].cruiserCount -= 1;\n            } else if (defenderLosses[i] == 5) {\n                navy2.decreaseFrigateCount(attackerId, 1);\n            } else if (defenderLosses[i] == 6) {\n                navy2.decreaseDestroyerCount(attackerId, 1);\n            } else if (defenderLosses[i] == 7) {\n                navy2.decreaseSubmarineCount(attackerId, 1);\n            } else if (defenderLosses[i] == 8) {\n                navy2.decreaseAircraftCarrierCount(attackerId, 1);\n            }\n        }\n    }\n\n    function getNavyVesselCount(uint256 id) public view returns (uint256) {\n        uint256 corvetteCount = idToNavy[id].corvetteCount;\n        uint256 landingShipCount = idToNavy[id].landingShipCount;\n        uint256 battleshipCount = idToNavy[id].battleshipCount;\n        uint256 cruiserCount = idToNavy[id].cruiserCount;\n        uint256 frigateCount = navy2.getFrigateCount(id);\n        uint256 destroyerCount = navy2.getDestroyerCount(id);\n        uint256 submarineCount = navy2.getSubmarineCount(id);\n        uint256 aircraftCarrierCount = navy2.getAircraftCarrierCount(id);\n        uint256 navyVessels = (corvetteCount +\n            landingShipCount +\n            battleshipCount +\n            cruiserCount +\n            frigateCount +\n            destroyerCount +\n            submarineCount +\n            aircraftCarrierCount);\n        return navyVessels;\n    }\n\n    ///@dev this is a public function callable only by the nation owner\n    ///@dev this function will allow a nation owner to purchase a corvette vessel\n    ///@notice this function will allow a nation owner to purchase a corvette vessel\n    ///@param amount this is the number of corvettes being purchased\n    ///@param id this is the naton id of the nation purchasing vessels\n    function buyCorvette(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        (uint256 availablePurchases, ) = addNav.getAvailablePurchases(id);\n        require(\n            amount <= availablePurchases,\n            \"purchase exceeds daily purchase limit\"\n        );\n        uint256 drydockAmount = ImprovementsContract1(\n            improvementsContract1Address\n        ).getDrydockCount(id);\n        uint256 currentShips = getCorvetteCount(id);\n        uint256 nationInfrastructure = inf.getInfrastructureCount(id);\n        uint256 additionalPurchases = (nationInfrastructure /\n            corvetteRequiredInfrastructure);\n        require(\n            (currentShips + amount) <= (drydockAmount + additionalPurchases),\n            \"need more drydocks or infrastructure\"\n        );\n        require(\n            inf.getTechnologyCount(id) >= corvetteRequiredTechnology,\n            \"need more technology\"\n        );\n        uint256 purchasePrice = (corvetteCost * amount);\n        bool steel = bonus.viewSteel(id);\n        if (steel) {\n            purchasePrice = ((purchasePrice * 85) / 100);\n        }\n        uint256 balance = TreasuryContract(treasuryAddress).checkBalance(id);\n        require(balance >= purchasePrice);\n        idToNavy[id].corvetteCount += amount;\n        navAct.increasePurchases(id, amount);\n        TreasuryContract(treasuryAddress).spendBalance(id, purchasePrice);\n        emit CorvettePurchased(id, amount, purchasePrice);\n    }\n\n    function decommissionCorvette(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(amount <= idToNavy[id].corvetteCount, \"not enough corvettes\");\n        idToNavy[id].corvetteCount -= amount;\n        emit CorvetteDecommissioned(id, amount);\n    }\n\n    ///@dev this is a public view function that will return the number of corvettes a nation owns\n    ///@dev this function wll return the number of corvettes a nation owns\n    ///@notice this functon will return the number of corvettes a nation owns\n    ///@param id this is the nation id of the nation being queried\n    ///@return uint256 this is the number of corvettes for a given nation\n    function getCorvetteCount(uint256 id) public view returns (uint256) {\n        uint256 corvetteAmount = idToNavy[id].corvetteCount;\n        return corvetteAmount;\n    }\n\n    ///@dev this is a public function callable only by the nation owner\n    ///@dev this function will allow a nation owner to purchase a landing ships vessel\n    ///@notice this function will allow a nation owner to purchase a landing ships vessel\n    ///@param amount this is the number of landing ships being purchased\n    ///@param id this is the naton id of the nation purchasing vessels\n    function buyLandingShip(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        (uint256 availablePurchases, ) = addNav.getAvailablePurchases(id);\n        require(\n            amount <= availablePurchases,\n            \"purchase exceeds daily purchase limit\"\n        );\n        uint256 shipyardAmount = ImprovementsContract3(\n            improvementsContract3Address\n        ).getShipyardCount(id);\n        uint256 currentShips = getLandingShipCount(id);\n        uint256 nationInfrastructure = inf.getInfrastructureCount(id);\n        uint256 additionalPurchases = (nationInfrastructure /\n            landingShipRequiredInfrastructure);\n        require(\n            (currentShips + amount) <= (shipyardAmount + additionalPurchases),\n            \"need more shipyards or infrastructure\"\n        );\n        require(\n            inf.getTechnologyCount(id) >= landingShipRequiredTechnology,\n            \"need more technology\"\n        );\n        uint256 purchasePrice = landingShipCost * amount;\n        bool steel = bonus.viewSteel(id);\n        if (steel) {\n            purchasePrice = ((purchasePrice * 85) / 100);\n        }\n        uint256 balance = TreasuryContract(treasuryAddress).checkBalance(id);\n        require(balance >= purchasePrice);\n        idToNavy[id].landingShipCount += amount;\n        navAct.increasePurchases(id, amount);\n        TreasuryContract(treasuryAddress).spendBalance(id, purchasePrice);\n        emit LandingShipPurchased(id, amount, purchasePrice);\n    }\n\n    function decomissionLandingShip(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(\n            amount <= idToNavy[id].landingShipCount,\n            \"not enough landing ships\"\n        );\n        idToNavy[id].landingShipCount -= amount;\n        emit LandingShipDecommissioned(id, amount);\n    }\n\n    ///@dev this is a public view function that will return the number of landing ships a nation owns\n    ///@dev this function wll return the number of landing ships a nation owns\n    ///@notice this functon will return the number of landing ships a nation owns\n    ///@param id this is the nation id of the nation being queried\n    ///@return uint256 this is the number of landing ships for a given nation\n    function getLandingShipCount(uint256 id) public view returns (uint256) {\n        uint256 landingShipAmount = idToNavy[id].landingShipCount;\n        return landingShipAmount;\n    }\n\n    ///@dev this is a public function callable only by the nation owner\n    ///@dev this function will allow a nation owner to purchase a battleship vessel\n    ///@notice this function will allow a nation owner to purchase a battleship vessel\n    ///@param amount this is the number of battleship being purchased\n    ///@param id this is the naton id of the nation purchasing vessels\n    function buyBattleship(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        (uint256 availablePurchases, ) = addNav.getAvailablePurchases(id);\n        require(\n            amount <= availablePurchases,\n            \"purchase exceeds daily purchase limit\"\n        );\n        uint256 drydockAmount = ImprovementsContract1(\n            improvementsContract1Address\n        ).getDrydockCount(id);\n        uint256 currentShips = getBattleshipCount(id);\n        uint256 nationInfrastructure = inf.getInfrastructureCount(id);\n        uint256 additionalPurchases = (nationInfrastructure /\n            battleshipRequiredInfrastructure);\n        require(\n            (currentShips + amount) <= (drydockAmount + additionalPurchases),\n            \"need more drydocks or infrastructure\"\n        );\n        require(\n            inf.getTechnologyCount(id) >= battleshipRequiredTechnology,\n            \"need more technology\"\n        );\n        uint256 purchasePrice = battleshipCost * amount;\n        bool steel = bonus.viewSteel(id);\n        if (steel) {\n            purchasePrice = ((purchasePrice * 85) / 100);\n        }\n        uint256 balance = TreasuryContract(treasuryAddress).checkBalance(id);\n        require(balance >= purchasePrice);\n        idToNavy[id].battleshipCount += amount;\n        navAct.increasePurchases(id, amount);\n        TreasuryContract(treasuryAddress).spendBalance(id, purchasePrice);\n        emit BattleshipPurchased(id, amount, purchasePrice);\n    }\n\n    function decommissionBattleship(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(\n            amount <= idToNavy[id].battleshipCount,\n            \"not enough battleships\"\n        );\n        idToNavy[id].battleshipCount -= amount;\n        emit BattleshipDecommissioned(id, amount);\n    }\n\n    ///@dev this is a public view function that will return the number of battleships a nation owns\n    ///@dev this function wll return the number of battleships a nation owns\n    ///@notice this functon will return the number of battleships a nation owns\n    ///@param id this is the nation id of the nation being queried\n    ///@return uint256 this is the number of battleships for a given nation\n    function getBattleshipCount(uint256 id) public view returns (uint256) {\n        uint256 battleshipAmount = idToNavy[id].battleshipCount;\n        return battleshipAmount;\n    }\n\n    ///@dev this is a public function callable only by the nation owner\n    ///@dev this function will allow a nation owner to purchase a cruiser vessel\n    ///@notice this function will allow a nation owner to purchase a cruiser vessel\n    ///@param amount this is the number of cruisers being purchased\n    ///@param id this is the naton id of the nation purchasing vessels\n    function buyCruiser(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        (uint256 availablePurchases, ) = addNav.getAvailablePurchases(id);\n        require(\n            amount <= availablePurchases,\n            \"purchase exceeds daily purchase limit\"\n        );\n        uint256 drydockAmount = ImprovementsContract1(\n            improvementsContract1Address\n        ).getDrydockCount(id);\n        uint256 currentShips = getCruiserCount(id);\n        uint256 nationInfrastructure = inf.getInfrastructureCount(id);\n        uint256 additionalPurchases = (nationInfrastructure /\n            cruiserRequiredInfrastructure);\n        require(\n            (currentShips + amount) <= (drydockAmount + additionalPurchases),\n            \"need more drydocks or infrastructure\"\n        );\n        require(\n            inf.getTechnologyCount(id) >= cruiserRequiredTechnology,\n            \"need more technology\"\n        );\n        uint256 purchasePrice = cruiserCost * amount;\n        bool steel = bonus.viewSteel(id);\n        if (steel) {\n            purchasePrice = ((purchasePrice * 85) / 100);\n        }\n        uint256 balance = TreasuryContract(treasuryAddress).checkBalance(id);\n        require(balance >= purchasePrice);\n        idToNavy[id].cruiserCount += amount;\n        navAct.increasePurchases(id, amount);\n        TreasuryContract(treasuryAddress).spendBalance(id, purchasePrice);\n        emit CruiserPurchased(id, amount, purchasePrice);\n    }\n\n    function decommissionCruiser(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(amount <= idToNavy[id].cruiserCount, \"not enough cruisers\");\n        idToNavy[id].cruiserCount -= amount;\n        emit CruiserDecommissioned(id, amount);\n    }\n\n    ///@dev this is a public view function that will return the number of cruisers a nation owns\n    ///@dev this function wll return the number of cruisers a nation owns\n    ///@notice this functon will return the number of cruisers a nation owns\n    ///@param id this is the nation id of the nation being queried\n    ///@return uint256 this is the number of cruisers for a given nation\n    function getCruiserCount(uint256 id) public view returns (uint256) {\n        uint256 cruiserAmount = idToNavy[id].cruiserCount;\n        return cruiserAmount;\n    }\n\n    modifier onlyNukeContract() {\n        require(msg.sender == nukes, \"only callable from nuke contract\");\n        _;\n    }\n\n    ///@dev this is a public function only callable from the nuke contract\n    ///@dev this function will decrease the amount of ships that are vulnerable to nuclear attacks when a nation is attacked by a nuke strike\n    ///@notice this function will decrease the amount of ships that are vulnerable to nuclear attacks when a nation is attacked by a nuke strike\n    ///@notice vessels available to nuke strikes are corvettes, landing ships, cruisers and frigates\n    ///@notice a nuke strike will reduce the number of these ships by 25% (12% with a fallout shelter system)\n    ///@param defenderId this is the nation id of the nation being attacked\n    function decreaseNavyFromNukeContract(\n        uint256 defenderId\n    ) public onlyNukeContract {\n        uint256 percentage = 40;\n        bool falloutShelter = won1.getFalloutShelterSystem(defenderId);\n        if (falloutShelter) {\n            percentage = 20;\n        }\n        uint256 corvetteCountToReduce = (idToNavy[defenderId].corvetteCount *\n            percentage) / 100;\n        uint256 landingShipCountToReduce = (idToNavy[defenderId]\n            .landingShipCount * percentage) / 100;\n        uint256 cruiserCountToReduce = (idToNavy[defenderId].cruiserCount *\n            percentage) / 100;\n        uint256 frigateCountToReduce = (navy2.getFrigateCount(defenderId) *\n            percentage) / 100;\n        idToNavy[defenderId].corvetteCount -= corvetteCountToReduce;\n        idToNavy[defenderId].landingShipCount -= landingShipCountToReduce;\n        idToNavy[defenderId].cruiserCount -= cruiserCountToReduce;\n        navy2.decreaseFrigateCount(defenderId, frigateCountToReduce);\n        emit NukeDamageToNavy(\n            defenderId,\n            corvetteCountToReduce,\n            landingShipCountToReduce,\n            cruiserCountToReduce,\n            frigateCountToReduce\n        );\n    }\n}\n\n///@title NavyContract\n///@author OxSnosh\n///@dev this contract inherits from openzeppelin's ownable contract\n///@notice this contract will allow a user to purchase navy vessels\ncontract NavyContract2 is Ownable {\n    address public treasuryAddress;\n    address public improvementsContract1Address;\n    address public improvementsContract3Address;\n    address public improvements4;\n    address public resources;\n    address public navyBattleAddress;\n    address public military;\n    address public nukes;\n    address public wonders1;\n    address public countryMinter;\n    address public navalActions;\n    address public additionalNavy;\n    address public bonusResources;\n    address public navy1Address;\n    address public infrastructure;\n    uint256 public frigateCost = 750000 * (10 ** 18);\n    uint256 public frigateRequiredInfrastructure = 3500;\n    uint256 public frigateRequiredTechnology = 400;\n    uint256 public destroyerCost = 1000000 * (10 ** 18);\n    uint256 public destroyerRequiredInfrastructure = 4000;\n    uint256 public destroyerRequiredTechnology = 600;\n    uint256 public submarineCost = 1500000 * (10 ** 18);\n    uint256 public submarineRequiredInfrastructure = 4500;\n    uint256 public submarineRequiredTechnology = 750;\n    uint256 public aircraftCarrierCost = 2000000 * (10 ** 18);\n    uint256 public aircraftCarrierRequiredInfrastructure = 5000;\n    uint256 public aircraftCarrierRequiredTechnology = 1000;\n\n    struct Navy {\n        uint256 frigateCount;\n        uint256 destroyerCount;\n        uint256 submarineCount;\n        uint256 aircraftCarrierCount;\n    }\n\n    mapping(uint256 => Navy) public idToNavy;\n\n    event FrigatePurchased(\n        uint256 indexed id,\n        uint256 indexed amount,\n        uint256 indexed purchasePrice\n    );\n\n    event DestroyerPurchased(\n        uint256 indexed id,\n        uint256 indexed amount,\n        uint256 indexed purchasePrice\n    );\n\n    event SubmarinePurchased(\n        uint256 indexed id,\n        uint256 indexed amount,\n        uint256 indexed purchasePrice\n    );\n\n    event AircraftCarrierPurchased(\n        uint256 indexed id,\n        uint256 indexed amount,\n        uint256 indexed purchasePrice\n    );\n\n    event FrigateDecommissioned(uint256 indexed id, uint256 indexed amount);\n\n    event DestroyerDecommissioned(uint256 indexed id, uint256 indexed amount);\n\n    event SubmarineDecommissioned(uint256 indexed id, uint256 indexed amount);\n\n    event AircraftCarrierDecommissioned(\n        uint256 indexed id,\n        uint256 indexed amount\n    );\n\n    ResourcesContract res;\n    MilitaryContract mil;\n    ImprovementsContract4 imp4;\n    NukeContract nuke;\n    WondersContract1 won1;\n    NavalActionsContract navAct;\n    CountryMinter mint;\n    AdditionalNavyContract addNav;\n    BonusResourcesContract bonus;\n    NavyContract navy1;\n    InfrastructureContract inf;\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"function only callable from countryMinter\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _treasuryAddress,\n        address _improvementsContract1Address,\n        address _improvementsContract3Address,\n        address _improvements4,\n        address _resources,\n        address _military,\n        address _nukes,\n        address _wonders1,\n        address _navalActions,\n        address _additionalNavy\n    ) public onlyOwner {\n        treasuryAddress = _treasuryAddress;\n        improvementsContract1Address = _improvementsContract1Address;\n        improvementsContract3Address = _improvementsContract3Address;\n        improvements4 = _improvements4;\n        imp4 = ImprovementsContract4(_improvements4);\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        military = _military;\n        mil = MilitaryContract(_military);\n        nukes = _nukes;\n        nuke = NukeContract(_nukes);\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        navalActions = _navalActions;\n        navAct = NavalActionsContract(_navalActions);\n        additionalNavy = _additionalNavy;\n        addNav = AdditionalNavyContract(_additionalNavy);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings2(\n        address _countryMinter,\n        address _bonusResources,\n        address _navy1,\n        address _infrastructure\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        bonusResources = _bonusResources;\n        bonus = BonusResourcesContract(_bonusResources);\n        navy1Address = _navy1;\n        navy1 = NavyContract(_navy1);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n    }\n\n    ///@dev this is a public function only callable from the countryMinter contract\n    ///@dev this function will allow a nation owner to buy navy vessels\n    ///@notice this function will allow a nation owner to buy navy vessels\n    ///@param id this is the nation id of the nation being minted\n    function generateNavy2(uint256 id) public onlyCountryMinter {\n        Navy memory newNavy = Navy(0, 0, 0, 0);\n        idToNavy[id] = newNavy;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateFrigateSpecs(\n        uint256 newPrice,\n        uint256 newRequiredInf,\n        uint256 newRequiredTech\n    ) public onlyOwner {\n        frigateCost = newPrice;\n        frigateRequiredInfrastructure = newRequiredInf;\n        frigateRequiredTechnology = newRequiredTech;\n    }\n\n    function getFrigateSpecs() public view returns (uint256, uint256, uint256) {\n        return (\n            frigateCost,\n            frigateRequiredInfrastructure,\n            frigateRequiredTechnology\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateDestroyerSpecs(\n        uint256 newPrice,\n        uint256 newRequiredInf,\n        uint256 newRequiredTech\n    ) public onlyOwner {\n        destroyerCost = newPrice;\n        destroyerRequiredInfrastructure = newRequiredInf;\n        destroyerRequiredTechnology = newRequiredTech;\n    }\n\n    function getDestroyerSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            destroyerCost,\n            destroyerRequiredInfrastructure,\n            destroyerRequiredTechnology\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateSubmarineSpecs(\n        uint256 newPrice,\n        uint256 newRequiredInf,\n        uint256 newRequiredTech\n    ) public onlyOwner {\n        submarineCost = newPrice;\n        submarineRequiredInfrastructure = newRequiredInf;\n        submarineRequiredTechnology = newRequiredTech;\n    }\n\n    function getSubmarineSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            submarineCost,\n            submarineRequiredInfrastructure,\n            submarineRequiredTechnology\n        );\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateAircraftCarrierSpecs(\n        uint256 newPrice,\n        uint256 newRequiredInf,\n        uint256 newRequiredTech\n    ) public onlyOwner {\n        aircraftCarrierCost = newPrice;\n        aircraftCarrierRequiredInfrastructure = newRequiredInf;\n        aircraftCarrierRequiredTechnology = newRequiredTech;\n    }\n\n    function getAircraftCarrierSpecs()\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return (\n            aircraftCarrierCost,\n            aircraftCarrierRequiredInfrastructure,\n            aircraftCarrierRequiredTechnology\n        );\n    }\n\n    ///@dev this is a public function callable only by the nation owner\n    ///@dev this function will allow a nation owner to purchase a frigates vessel\n    ///@notice this function will allow a nation owner to purchase a frigates vessel\n    ///@param amount this is the number of frigates being purchased\n    ///@param id this is the naton id of the nation purchasing vessels\n    function buyFrigate(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        (uint256 availablePurchases, ) = addNav.getAvailablePurchases(id);\n        require(\n            amount <= availablePurchases,\n            \"purchase exceeds daily purchase limit\"\n        );\n        uint256 shipyardAmount = ImprovementsContract3(\n            improvementsContract3Address\n        ).getShipyardCount(id);\n        uint256 currentShips = getFrigateCount(id);\n        uint256 nationInfrastructure = inf.getInfrastructureCount(id);\n        uint256 additionalPurchases = (nationInfrastructure /\n            frigateRequiredInfrastructure);\n        require(\n            (currentShips + amount) <= (shipyardAmount + additionalPurchases),\n            \"need more shipyards or infrastructure\"\n        );\n        require(\n            inf.getTechnologyCount(id) >= frigateRequiredTechnology,\n            \"need more technology\"\n        );\n        uint256 purchasePrice = frigateCost * amount;\n        bool steel = bonus.viewSteel(id);\n        if (steel) {\n            purchasePrice = ((purchasePrice * 85) / 100);\n        }\n        bool microchips = bonus.viewMicrochips(id);\n        if (microchips) {\n            purchasePrice = ((purchasePrice * 90) / 100);\n        }\n        uint256 balance = TreasuryContract(treasuryAddress).checkBalance(id);\n        require(balance >= purchasePrice);\n        idToNavy[id].frigateCount += amount;\n        navAct.increasePurchases(id, amount);\n        TreasuryContract(treasuryAddress).spendBalance(id, purchasePrice);\n        emit FrigatePurchased(id, amount, purchasePrice);\n    }\n\n    function decommissionFrigate(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(amount <= idToNavy[id].frigateCount, \"not enough frigates\");\n        idToNavy[id].frigateCount -= amount;\n        emit FrigateDecommissioned(id, amount);\n    }\n\n    ///@dev this is a public view function that will return the number of frigates a nation owns\n    ///@dev this function wll return the number of frigates a nation owns\n    ///@notice this functon will return the number of frigates a nation owns\n    ///@param id this is the nation id of the nation being queried\n    ///@return uint256 this is the number of frigates for a given nation\n    function getFrigateCount(uint256 id) public view returns (uint256) {\n        uint256 frigateAmount = idToNavy[id].frigateCount;\n        return frigateAmount;\n    }\n\n    modifier onlyNavy1Contract () {\n        require(msg.sender == navy1Address, \"function only callable from the navy1 contract\");\n        _;\n    }\n\n    function decreaseFrigateCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyNavy1Contract {\n        idToNavy[id].frigateCount -= amount;\n    }\n\n    ///@dev this is a public function callable only by the nation owner\n    ///@dev this function will allow a nation owner to purchase a destroyer vessel\n    ///@notice this function will allow a nation owner to purchase a destroyer vessel\n    ///@param amount this is the number of destroyers being purchased\n    ///@param id this is the naton id of the nation purchasing vessels\n    function buyDestroyer(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        (uint256 availablePurchases, ) = addNav.getAvailablePurchases(id);\n        require(\n            amount <= availablePurchases,\n            \"purchase exceeds daily purchase limit\"\n        );\n        uint256 drydockAmount = ImprovementsContract1(\n            improvementsContract1Address\n        ).getDrydockCount(id);\n        uint256 currentShips = getDestroyerCount(id);\n        uint256 nationInfrastructure = inf.getInfrastructureCount(id);\n        uint256 additionalPurchases = (nationInfrastructure /\n            destroyerRequiredInfrastructure);\n        require(\n            (currentShips + amount) <= (drydockAmount + additionalPurchases),\n            \"need more drydocks or infrastructure\"\n        );\n        require(\n            inf.getTechnologyCount(id) >= destroyerRequiredTechnology,\n            \"need more technology\"\n        );\n        uint256 purchasePrice = destroyerCost * amount;\n        bool steel = bonus.viewSteel(id);\n        if (steel) {\n            purchasePrice = ((purchasePrice * 85) / 100);\n        }\n        bool microchips = bonus.viewMicrochips(id);\n        if (microchips) {\n            purchasePrice = ((purchasePrice * 90) / 100);\n        }\n        uint256 balance = TreasuryContract(treasuryAddress).checkBalance(id);\n        require(balance >= purchasePrice);\n        idToNavy[id].destroyerCount += amount;\n        navAct.increasePurchases(id, amount);\n        TreasuryContract(treasuryAddress).spendBalance(id, purchasePrice);\n        emit DestroyerPurchased(id, amount, purchasePrice);\n    }\n\n    function decommissionDestroyer(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(amount <= idToNavy[id].destroyerCount, \"not enough destroyers\");\n        idToNavy[id].destroyerCount -= amount;\n        emit DestroyerDecommissioned(id, amount);\n    }\n\n    ///@dev this is a public view function that will return the number of destroyers a nation owns\n    ///@dev this function wll return the number of destroyers a nation owns\n    ///@notice this functon will return the number of destroyers a nation owns\n    ///@param id this is the nation id of the nation being queried\n    ///@return uint256 this is the number of destroyers for a given nation\n    function getDestroyerCount(uint256 id) public view returns (uint256) {\n        uint256 destroyerAmount = idToNavy[id].destroyerCount;\n        return destroyerAmount;\n    }\n\n    function decreaseDestroyerCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyNavy1Contract {\n        idToNavy[id].destroyerCount -= amount;\n    }\n\n    ///@dev this is a public function callable only by the nation owner\n    ///@dev this function will allow a nation owner to purchase a submarine vessel\n    ///@notice this function will allow a nation owner to purchase a submarine vessel\n    ///@param amount this is the number of submarines being purchased\n    ///@param id this is the naton id of the nation purchasing vessels\n    function buySubmarine(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        (uint256 availablePurchases, ) = addNav.getAvailablePurchases(id);\n        require(\n            amount <= availablePurchases,\n            \"purchase exceeds daily purchase limit\"\n        );\n        uint256 shipyardAmount = ImprovementsContract3(\n            improvementsContract3Address\n        ).getShipyardCount(id);\n        uint256 currentShips = getSubmarineCount(id);\n        uint256 nationInfrastructure = inf.getInfrastructureCount(id);\n        uint256 additionalPurchases = (nationInfrastructure /\n            submarineRequiredInfrastructure);\n        require(\n            (currentShips + amount) <= (shipyardAmount + additionalPurchases),\n            \"need more shipyards or infrastructure\"\n        );\n        require(\n            inf.getTechnologyCount(id) >= submarineRequiredTechnology,\n            \"need more technology\"\n        );\n        uint256 purchasePrice = submarineCost * amount;\n        bool steel = bonus.viewSteel(id);\n        if (steel) {\n            purchasePrice = ((purchasePrice * 85) / 100);\n        }\n        bool microchips = bonus.viewMicrochips(id);\n        if (microchips) {\n            purchasePrice = ((purchasePrice * 90) / 100);\n        }\n        uint256 balance = TreasuryContract(treasuryAddress).checkBalance(id);\n        require(balance >= purchasePrice);\n        idToNavy[id].submarineCount += amount;\n        navAct.increasePurchases(id, amount);\n        TreasuryContract(treasuryAddress).spendBalance(id, purchasePrice);\n        emit SubmarinePurchased(id, amount, purchasePrice);\n    }\n\n    function decommissionSubmarine(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(amount <= idToNavy[id].submarineCount, \"not enough submarines\");\n        idToNavy[id].submarineCount -= amount;\n        emit SubmarineDecommissioned(id, amount);\n    }\n\n    ///@dev this is a public view function that will return the number of submarines a nation owns\n    ///@dev this function wll return the number of submarines ttes a nation owns\n    ///@notice this functon will return the number of submarines a nation owns\n    ///@param id this is the nation id of the nation being queried\n    ///@return uint256 this is the number of submarines for a given nation\n    function getSubmarineCount(uint256 id) public view returns (uint256) {\n        uint256 submarineAmount = idToNavy[id].submarineCount;\n        return submarineAmount;\n    }\n\n    function decreaseSubmarineCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyNavy1Contract {\n        idToNavy[id].submarineCount -= amount;\n    }\n\n    ///@dev this is a public function callable only by the nation owner\n    ///@dev this function will allow a nation owner to purchase a aircraft carrier vessel\n    ///@notice this function will allow a nation owner to purchase a aircraft carrier vessel\n    ///@param amount this is the number of aircraft carriers being purchased\n    ///@param id this is the naton id of the nation purchasing vessels\n    function buyAircraftCarrier(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        (uint256 availablePurchases, ) = addNav.getAvailablePurchases(id);\n        require(\n            amount <= availablePurchases,\n            \"purchase exceeds daily purchase limit\"\n        );\n        uint256 shipyardAmount = ImprovementsContract3(\n            improvementsContract3Address\n        ).getShipyardCount(id);\n        uint256 currentShips = getAircraftCarrierCount(id);\n        uint256 nationInfrastructure = inf.getInfrastructureCount(id);\n        uint256 additionalPurchases = (nationInfrastructure /\n            aircraftCarrierRequiredInfrastructure);\n        require(\n            (currentShips + amount) <= (shipyardAmount + additionalPurchases),\n            \"need more shipyards or infrastructure\"\n        );\n        require(\n            inf.getTechnologyCount(id) >= aircraftCarrierRequiredTechnology,\n            \"need more technology\"\n        );\n        uint256 purchasePrice = aircraftCarrierCost * amount;\n        bool steel = bonus.viewSteel(id);\n        if (steel) {\n            purchasePrice = ((purchasePrice * 85) / 100);\n        }\n        bool microchips = bonus.viewMicrochips(id);\n        if (microchips) {\n            purchasePrice = ((purchasePrice * 90) / 100);\n        }\n        uint256 balance = TreasuryContract(treasuryAddress).checkBalance(id);\n        require(balance >= purchasePrice);\n        idToNavy[id].aircraftCarrierCount += amount;\n        navAct.increasePurchases(id, amount);\n        TreasuryContract(treasuryAddress).spendBalance(id, purchasePrice);\n        emit AircraftCarrierPurchased(id, amount, purchasePrice);\n    }\n\n    function decommissionAircraftCarrier(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(\n            amount <= idToNavy[id].aircraftCarrierCount,\n            \"not enough aircraft carriers\"\n        );\n        idToNavy[id].aircraftCarrierCount -= amount;\n        emit AircraftCarrierDecommissioned(id, amount);\n    }\n\n    ///@dev this is a public view function that will return the number of aircraft carriers a nation owns\n    ///@dev this function wll return the number of aircraft carriers a nation owns\n    ///@notice this functon will return the number of aircraft carriers a nation owns\n    ///@param id this is the nation id of the nation being queried\n    ///@return uint256 this is the number of aircraft carriers for a given nation\n    function getAircraftCarrierCount(uint256 id) public view returns (uint256) {\n        uint256 aircraftCarrierAmount = idToNavy[id].aircraftCarrierCount;\n        return aircraftCarrierAmount;\n    }\n\n    function decreaseAircraftCarrierCount(\n        uint256 id,\n        uint256 amount\n    ) public onlyNavy1Contract {\n        idToNavy[id].aircraftCarrierCount -= amount;\n    }\n}\n\n///@title AdditionalNavyContract\n///@author OxSnosh\n///@dev this contract inherits from the openzeppelin ownabl contract\n///@notice this contract will keep track of additional information about a nations navy\ncontract AdditionalNavyContract is Ownable {\n    address public navy;\n    address public navalActions;\n    address public military;\n    address public wonders1;\n    address public improvements4;\n    address public navy2;\n\n    NavyContract nav;\n    NavalActionsContract navAct;\n    MilitaryContract mil;\n    WondersContract1 won1;\n    ImprovementsContract4 imp4;\n    NavyContract2 nav2;\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _navy,\n        address _navalActions,\n        address _military,\n        address _wonders1,\n        address _improvements4,\n        address _navy2\n    ) public onlyOwner {\n        navy = _navy;\n        nav = NavyContract(_navy);\n        navalActions = _navalActions;\n        navAct = NavalActionsContract(_navalActions);\n        military = _military;\n        mil = MilitaryContract(_military);\n        wonders1 = wonders1;\n        won1 = WondersContract1(_wonders1);\n        improvements4 = _improvements4;\n        imp4 = ImprovementsContract4(_improvements4);\n        navy2 = _navy2;\n        nav2 = NavyContract2(_navy2);\n    }\n\n    ///@dev this is a public view function\n    ///@dev this function will return a nations available daily navy vessel purchases\n    ///@notice this function will return a nations available daily navy vessel purchases\n    ///@param id this is the nation id of the nation being queried\n    ///@return uint256 is the number of available navy vessel purchases for the day for that nation\n    function getAvailablePurchases(\n        uint256 id\n    ) public view returns (uint256, uint256) {\n        uint256 purchasesToday = navAct.getPurchasesToday(id);\n        uint256 maxDailyPurchases;\n        (bool isWar,) = mil.getWarPeacePreference(id);\n        bool foreignNavalBase = won1.getForeignNavalBase(id);\n        if (isWar) {\n            if (foreignNavalBase) {\n                maxDailyPurchases = 7;\n            } else if (!foreignNavalBase) {\n                maxDailyPurchases = 5;\n            }\n        } else if (!isWar) {\n            if (foreignNavalBase) {\n                maxDailyPurchases = 4;\n            } else if (!foreignNavalBase) {\n                maxDailyPurchases = 2;\n            }\n        }\n        uint256 navalConstructionYards = imp4.getNavalConstructionYardCount(id);\n        if (navalConstructionYards > 0) {\n            maxDailyPurchases += navalConstructionYards;\n        }\n        uint256 availablePurchases = (maxDailyPurchases - purchasesToday);\n        return (availablePurchases, maxDailyPurchases);\n    }\n\n    ///@dev this is a public view function that will return the number of blockade capable ships a nation has\n    ///@notice this function will return the number of blockade capable ships a nation has\n    ///@notice blockade capable ships include battleships, cruisers, frigates and submarines\n    ///@param id this is the nation id of the nation being queried\n    ///@return uint256 this is the number of blockade capable ships for a given nation\n    function getBlockadeCapableShips(uint256 id) public view returns (uint256) {\n        uint256 battleships = nav.getBattleshipCount(id);\n        uint256 cruisers = nav.getCruiserCount(id);\n        uint256 frigates = nav2.getFrigateCount(id);\n        uint256 subs = nav2.getSubmarineCount(id);\n        uint256 blockadeCapableShips = (battleships +\n            cruisers +\n            frigates +\n            subs);\n        return blockadeCapableShips;\n    }\n\n    ///@dev this is a public view function that will return the number of ships a nation has that can break a blockade\n    ///@notice this function will return the number of ships a nation has that can break a blockade\n    ///@notice blockade capable ships include battleships, cruisers, frigates and destroyers\n    ///@param id this is the nation id of the nation being queried\n    ///@return uint256 this is the number of ships that can break a blockade for a given nation\n    function getBreakBlockadeCapableShips(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 battleships = nav.getBattleshipCount(id);\n        uint256 cruisers = nav.getCruiserCount(id);\n        uint256 frigates = nav2.getFrigateCount(id);\n        uint256 destroyers = nav2.getDestroyerCount(id);\n        uint256 breakBlockadeCapableShips = (battleships +\n            cruisers +\n            frigates +\n            destroyers);\n        return breakBlockadeCapableShips;\n    }\n\n    ///@dev this is a public view function that returns the number of navy vessels that a nations drydocks support\n    ///@notice this function will return the number of ships that a nations drydocks support\n    ///@notice a nation cannot delete a drydock if it supports a vessel\n    ///@notice drydocks support corvettes, battleships, cruisers and destroyers\n    ///@param countryId is the nation id of the nation being queried\n    ///@return count is the number of vessel supported by the drydocks\n    function getVesselCountForDrydock(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 corvetteAmount = nav.getCorvetteCount(countryId);\n        uint256 battleshipAmount = nav.getBattleshipCount(countryId);\n        uint256 cruiserAmount = nav.getCruiserCount(countryId);\n        uint256 destroyerAmount = nav2.getDestroyerCount(countryId);\n        uint256 shipCount = (corvetteAmount +\n            battleshipAmount +\n            cruiserAmount +\n            destroyerAmount);\n        return shipCount;\n    }\n\n    ///@dev this is a public view function that returns the number of navy vessels that a nations shipyards support\n    ///@notice this function will return the number of ships that a nations shipyards support\n    ///@notice a nation cannot delete a shipyard if it supports a vessel\n    ///@notice shipyards support landing ships, frigates, submarines and aircraft carriers\n    ///@param countryId is the nation id of the nation being queried\n    ///@return count is the number of vessel supported by the shipyards\n    function getVesselCountForShipyard(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 landingShipAmount = nav.getLandingShipCount(countryId);\n        uint256 frigateAmount = nav2.getFrigateCount(countryId);\n        uint256 submarineAmount = nav2.getSubmarineCount(countryId);\n        uint256 aircraftCarrierAmount = nav2.getAircraftCarrierCount(countryId);\n        uint256 shipCount = (landingShipAmount +\n            frigateAmount +\n            submarineAmount +\n            aircraftCarrierAmount);\n        return shipCount;\n    }\n}\n"
    },
    "contracts/NavyBattle.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./CountryMinter.sol\";\nimport \"./Navy.sol\";\nimport \"./War.sol\";\nimport \"./Improvements.sol\";\nimport \"./War.sol\";\nimport \"./KeeperFile.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\nimport \"hardhat/console.sol\";\n\n///@title NavalBlocadeContract\n///@author OxSnosh\n///@dev this contract inherits from the openzeppelin ownable contract\n///@dev this contract inherits from the chainlink VRF contract\ncontract NavalBlockadeContract is Ownable, VRFConsumerBaseV2 {\n    uint256 public blockadeId;\n    address public navy;\n    address public additionalNavy;\n    address public navalAction;\n    address public warContract;\n    address public countryMinter;\n    address public keeper;\n    address public breakBlockadeAddress;\n\n    //Chainlik Variables\n    uint256[] private s_randomWords;\n    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;\n    uint64 private immutable i_subscriptionId;\n    bytes32 private immutable i_gasLane;\n    uint32 private immutable i_callbackGasLimit;\n    uint16 private constant REQUEST_CONFIRMATIONS = 3;\n    uint32 private constant NUM_WORDS = 1;\n\n    WarContract war;\n    CountryMinter mint;\n    NavyContract nav;\n    NavalActionsContract navAct;\n    AdditionalNavyContract addNav;\n    KeeperContract keep;\n\n    struct Blockade {\n        uint256 blockadeId;\n        uint256 blockaderId;\n        uint256 blockadedId;\n        uint256 blockadePercentageReduction;\n        uint256 blockadeDay;\n        bool blockadeActive;\n    }\n\n    event BlockadeCompleted(uint256[] attackerLosses, uint256[] defenderLosses, uint256 battleId);\n\n    mapping(uint256 => Blockade) public blockadeIdToBlockade;\n    // mapping(uint256 => uint256[]) public idDefenderToIdAttackerToActiveBlockadesAgainst;\n    // mapping(uint256 => uint256[]) public idAttackerToIdDefenderToActiveBlockadesFor;\n    mapping(uint256 => uint256[]) public idToActiveBlockadesFor;\n    mapping(uint256 => uint256[]) public idToActiveBlockadesAgainst;\n    mapping(uint256 => uint256) s_requestIdToRequestIndex;\n    mapping(uint256 => uint256[]) public s_requestIndexToRandomWords;\n\n    constructor(\n        address vrfCoordinatorV2,\n        uint64 subscriptionId,\n        bytes32 gasLane, // keyHash\n        uint32 callbackGasLimit\n    ) VRFConsumerBaseV2(vrfCoordinatorV2) {\n        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2);\n        i_gasLane = gasLane;\n        i_subscriptionId = subscriptionId;\n        i_callbackGasLimit = callbackGasLimit;\n    }\n\n    function settings(\n        address _navy,\n        address _additionalNavy,\n        address _navalAction,\n        address _war,\n        address _countryMinter,\n        address _keeper,\n        address _breakBlockadeAddress\n    ) public onlyOwner {\n        navy = _navy;\n        nav = NavyContract(_navy);\n        additionalNavy = _additionalNavy;\n        addNav = AdditionalNavyContract(_additionalNavy);\n        navalAction = _navalAction;\n        navAct = NavalActionsContract(_navalAction);\n        warContract = _war;\n        war = WarContract(_war);\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        keeper = _keeper;\n        keep = KeeperContract(_keeper);\n        breakBlockadeAddress = _breakBlockadeAddress;\n    }\n\n    ///@dev this is a public function callable only from the nation owner\n    ///@dev this function allows a nation to blockade another nation they are at war with\n    ///@notice this function allows a nation to blockade another nation they are at war with\n    ///@param attackerId is the id of the attacking nation\n    ///@param defenderId is the nation id of the defending nation\n    ///@param warId is the war id of the active war between the 2 nations\n    function blockade(\n        uint256 attackerId,\n        uint256 defenderId,\n        uint256 warId\n    ) public {\n        bool requirementsMet = checkRequirements(attackerId, defenderId, warId);\n        require(requirementsMet, \"requrements not met\");\n        uint256 slotsUsed = navAct.getActionSlotsUsed(attackerId);\n        require((slotsUsed + 1) <= 3, \"max slots used\");\n        uint256 activeBlockadesAgainstCount = idToActiveBlockadesAgainst[\n            attackerId\n        ].length;\n        require(\n            activeBlockadesAgainstCount == 0,\n            \"you cannot blockade while being blockaded\"\n        );\n        uint256 attackerShips = addNav.getBlockadeCapableShips(attackerId);\n        require(attackerShips >= 5, \"not enough blockade capable ships\");\n        uint256 defenderShips = addNav.getBreakBlockadeCapableShips(defenderId);\n        require(\n            defenderShips == 0,\n            \"defender has ships that can break blockade\"\n        );\n        bool attackerAlreadyBlockaded = checkIfAttackerAlreadyBlockaded(\n            attackerId,\n            defenderId\n        );\n        require(\n            attackerAlreadyBlockaded == false,\n            \"attacker already blockaded this nation\"\n        );\n        uint256 day = keep.getGameDay();\n        Blockade memory newBlockade = Blockade(\n            blockadeId,\n            attackerId,\n            defenderId,\n            1,\n            day,\n            true\n        );\n        blockadeIdToBlockade[blockadeId] = newBlockade;\n        navAct.increaseAction(attackerId);\n        navAct.toggleBlockaded(defenderId);\n        uint256[]\n            storage newActiveBlockadesAgainst = idToActiveBlockadesAgainst[\n                defenderId\n            ];\n        newActiveBlockadesAgainst.push(blockadeId);\n        console.log(newActiveBlockadesAgainst[0], \"blockades against index 0\");\n        // idToActiveBlockadesAgainst[defenderId] = newActiveBlockadesAgainst;\n        uint256[] storage newActiveBlockadesFor = idToActiveBlockadesFor[\n            attackerId\n        ];\n        newActiveBlockadesFor.push(blockadeId);\n        // idToActiveBlockadesFor[attackerId] = newActiveBlockadesFor;\n        war.cancelPeaceOffersUponAttack(warId);\n        fulfillRequest(blockadeId);\n        blockadeId++;\n    }\n\n    function checkRequirements(\n        uint256 attackerId,\n        uint256 defenderId,\n        uint256 warId\n    ) internal view returns (bool) {\n        bool isOwner = mint.checkOwnership(attackerId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        bool blockadedAlready = navAct.getBlockadedToday(defenderId);\n        require(blockadedAlready == false, \"nation already blockaded today\");\n        bool warActive = war.isWarActive(warId);\n        require(warActive, \"war !active\");\n        bool requirementsMet = false;\n        if (isOwner && !blockadedAlready && warActive) {\n            requirementsMet = true;\n        }\n        return requirementsMet;\n    }\n\n    function checkIfAttackerAlreadyBlockaded(\n        uint256 attackerId,\n        uint256 defenderId\n    ) internal view returns (bool) {\n        uint256[] memory activeBlockadeArray = idToActiveBlockadesAgainst[\n            defenderId\n        ];\n        for (uint256 i = 0; i < activeBlockadeArray.length; i++) {\n            uint256 idOfActiveBlockade = activeBlockadeArray[i];\n            uint256 idOfAttackerOfActiveBlockade = blockadeIdToBlockade[\n                idOfActiveBlockade\n            ].blockaderId;\n            if (idOfAttackerOfActiveBlockade == attackerId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function fulfillRequest(uint256 id) public {\n        uint256 requestId = i_vrfCoordinator.requestRandomWords(\n            i_gasLane,\n            i_subscriptionId,\n            REQUEST_CONFIRMATIONS,\n            i_callbackGasLimit,\n            NUM_WORDS\n        );\n        s_requestIdToRequestIndex[requestId] = id;\n    }\n\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) internal override {\n        uint256 requestNumber = s_requestIdToRequestIndex[requestId];\n        s_requestIndexToRandomWords[requestNumber] = randomWords;\n        s_randomWords = randomWords;\n        uint256 blockadePercentage = ((s_randomWords[0] % 5) + 1);\n        blockadeIdToBlockade[requestNumber]\n            .blockadePercentageReduction = blockadePercentage;\n        console.log(\"blockade percentage: \", blockadePercentage);\n    }\n\n    function getActiveBlockadesAgainst(\n        uint256 countryId\n    ) public view returns (uint256[] memory) {\n        uint256[] memory activeBlockadesToReturn = idToActiveBlockadesAgainst[\n            countryId\n        ];\n        return (activeBlockadesToReturn);\n    }\n\n    function getBlockadePercentageReduction(\n        uint256 countryId\n    ) public view returns (uint256) {\n        uint256[] memory activeBlockadesAgainst = idToActiveBlockadesAgainst[\n            countryId\n        ];\n        uint256 percentageReduction;\n        for (uint256 i = 0; i < activeBlockadesAgainst.length; i++) {\n            uint256 _blockadeId = activeBlockadesAgainst[i];\n            uint256 blockadePercentage = blockadeIdToBlockade[_blockadeId]\n                .blockadePercentageReduction;\n            percentageReduction += blockadePercentage;\n        }\n        console.log(\"percentage reduction: \", percentageReduction);\n        return percentageReduction;\n    }\n\n    modifier onlyBreakBlockade() {\n        require(\n            msg.sender == breakBlockadeAddress,\n            \"function only callable from the break blockade contract\"\n        );\n        _;\n    }\n\n    function checkIfBlockadeCapable(\n        uint256 countryId\n    ) external onlyBreakBlockade {\n        uint256 blockadeCapableShips = addNav.getBlockadeCapableShips(\n            countryId\n        );\n        console.log(blockadeCapableShips, \"blockade capable ships\");\n        if (blockadeCapableShips == 0) {\n            uint256[] storage blockadesFor = idToActiveBlockadesFor[countryId];\n            for (uint256 i = 0; i < blockadesFor.length; i++) {\n                blockadeId = blockadesFor[i];\n                blockadeIdToBlockade[blockadeId].blockadeActive = false;\n                uint256 blockadedCountry = blockadeIdToBlockade[blockadeId]\n                    .blockadedId;\n                uint256[] storage blockadesAgainst = idToActiveBlockadesAgainst[\n                    blockadedCountry\n                ];\n                for (uint256 j = 0; j < blockadesAgainst.length; j++) {\n                    if (blockadesAgainst[j] == blockadeId) {\n                        blockadesAgainst[j] = blockadesAgainst[j] - 1;\n                        blockadesAgainst.pop();\n                        console.log(\"blockade against deleted\");\n                    }\n                }\n                delete blockadesFor[i];\n                console.log(\"blockade for deleted\");\n            }\n        }\n    }\n\n    function breakBlockade(\n        uint256 blockaderId,\n        uint256 breakerId\n    ) external onlyBreakBlockade {\n        console.log(blockaderId, \"blockader id\");\n        console.log(breakerId, \"breaker id\");\n        console.log(\"break blockade function\");\n        uint256[] storage blockadesAgainst = idToActiveBlockadesAgainst[\n            breakerId\n        ];\n        console.log(\"length\", blockadesAgainst.length);\n        console.log(\"literally every line\");\n        for (uint256 i = 0; i < blockadesAgainst.length; i++) {\n            console.log(\"beginning og loop\");\n            uint256 _blockadeId = blockadesAgainst[i];\n            console.log(_blockadeId, \"blockade id\");\n            if (blockadeIdToBlockade[_blockadeId].blockaderId == blockaderId) {\n                console.log(\"blockade id to blockade\");\n                blockadesAgainst[i] = blockadesAgainst[i] - 1;\n                blockadesAgainst.pop();\n                console.log(\"blockade against deleted\");\n            }\n            console.log(\"end of loop\");\n        }\n        uint256[] storage blockadesFor = idToActiveBlockadesFor[blockaderId];\n        console.log(\"length\", blockadesFor.length);\n        for (uint256 j = 0; j < blockadesFor.length; j++) {\n            uint256 _blockadeId = blockadesFor[j];\n            console.log(_blockadeId, \"blockade id\");\n            if (blockadeIdToBlockade[_blockadeId].blockadedId == breakerId) {\n                blockadesFor[j] = blockadesFor[j] - 1;\n                blockadesFor.pop();\n                console.log(\"blockade for deleted\");\n            }\n        }\n        console.log(\"end of function\");\n    }\n}\n\n///@title BreakBlocadeContract\n///@author OxSnosh\n///@dev this contract inherits from the openzeppelin ownable contract\n///@dev this contract inherits from the chainlink VRF contract\ncontract BreakBlocadeContract is Ownable, VRFConsumerBaseV2, ChainlinkClient {\n    using Chainlink for Chainlink.Request;\n\n    uint256 public breakBlockadeId;\n    address public countryMinter;\n    address public navalBlockade;\n    address public navy;\n    address public warAddress;\n    address public improvements4;\n    address public navalActions;\n    address public navy2;\n    uint256 battleshipStrength = 5;\n    uint256 cruiserStrength = 6;\n    uint256 frigateStrength = 8;\n    uint256 destroyerStrength = 11;\n    uint256 submarineStrength = 12;\n    uint256 battleshipTargetSize = 11;\n    uint256 cruiserTargetSize = 10;\n    uint256 frigateTargetSize = 8;\n    uint256 destroyerTargetSize = 5;\n    uint256 submarineTargetSize = 4;\n\n    //Chainlik Variables\n    uint256[] private s_randomWords;\n    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;\n    uint64 private immutable i_subscriptionId;\n    bytes32 private immutable i_gasLane;\n    uint32 private immutable i_callbackGasLimit;\n    uint16 private constant REQUEST_CONFIRMATIONS = 3;\n    uint32 private constant NUM_WORDS = 6;\n\n    CountryMinter mint;\n    NavalBlockadeContract navBlock;\n    NavyContract nav;\n    WarContract war;\n    ImprovementsContract4 imp4;\n    NavalActionsContract navAct;\n    NavyContract2 nav2;\n\n    struct BreakBlockade {\n        uint256 battleshipCount;\n        uint256 cruiserCount;\n        uint256 frigateCount;\n        uint256 destroyerCount;\n        uint256 breakerStrength;\n        uint256 warId;\n        uint256 breakerId;\n    }\n\n    struct DefendBlockade {\n        uint256 battleshipCount;\n        uint256 cruiserCount;\n        uint256 frigateCount;\n        uint256 submarineCount;\n        uint256 defenderStrength;\n        uint256 warId;\n        uint256 defenderId;\n    }\n\n    mapping(uint256 => BreakBlockade) breakBlockadeIdToBreakBlockade;\n    mapping(uint256 => DefendBlockade) breakBlockadeIdToDefendBlockade;\n    mapping(uint256 => uint256[]) battleIdToBreakBlockadeChanceArray;\n    mapping(uint256 => uint256[]) battleIdToBreakBlockadeTypeArray;\n    mapping(uint256 => uint256) battleIdToBreakBlockadeCumulativeSumOdds;\n    mapping(uint256 => uint256[]) battleIdToBreakBlockadeLosses;\n    mapping(uint256 => uint256[]) battleIdToDefendBlockadeChanceArray;\n    mapping(uint256 => uint256[]) battleIdToDefendBlockadeTypeArray;\n    mapping(uint256 => uint256) battleIdToDefendBlockadeCumulativeSumOdds;\n    mapping(uint256 => uint256[]) battleIdToDefendBlockadeLosses;\n    mapping(uint256 => uint256) s_requestIdToRequestIndex;\n    mapping(uint256 => uint256[]) public s_requestIndexToRandomWords;\n\n    constructor(\n        address vrfCoordinatorV2,\n        uint64 subscriptionId,\n        bytes32 gasLane, // keyHash\n        uint32 callbackGasLimit\n    ) VRFConsumerBaseV2(vrfCoordinatorV2) {\n        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2);\n        i_gasLane = gasLane;\n        i_subscriptionId = subscriptionId;\n        i_callbackGasLimit = callbackGasLimit;\n    }\n\n    function settings(\n        address _countryMinter,\n        address _navalBlockade,\n        address _navy,\n        address _warAddress,\n        address _improvements4,\n        address _navalActions,\n        address _navy2\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        navalBlockade = _navalBlockade;\n        navBlock = NavalBlockadeContract(_navalBlockade);\n        navy = _navy;\n        nav = NavyContract(_navy);\n        warAddress = _warAddress;\n        war = WarContract(_warAddress);\n        improvements4 = _improvements4;\n        imp4 = ImprovementsContract4(_improvements4);\n        navalActions = _navalActions;\n        navAct = NavalActionsContract(_navalActions);\n        navy2 = _navy2;\n        nav2 = NavyContract2(_navy2);\n    }\n\n    ///@dev this is a public function callable only from the nation owner\n    ///@dev this function allows a nation to break a blockade another nation imposed on them\n    ///@notice this function allows a nation to break a blockade another nation imposed on them\n    ///@param warId is the war id of the active war between the 2 nations\n    ///@param attackerId is the id of the attacking nation\n    ///@param blockaderId is the nation id of the defending nation\n    function breakBlockade(\n        uint256 warId,\n        uint256 attackerId,\n        uint256 blockaderId\n    ) public {\n        bool isOwner = mint.checkOwnership(attackerId, msg.sender);\n        require(isOwner, \"caller not nation owner\");\n        bool warActive = war.isWarActive(warId);\n        require(warActive, \"war !active\");\n        uint256 slotsUsed = navAct.getActionSlotsUsed(attackerId);\n        require((slotsUsed + 1) <= 3, \"max slots used\");\n        uint256[] memory attackerBlockades = navBlock.getActiveBlockadesAgainst(\n            attackerId\n        );\n        bool isBlockader = false;\n        console.log(blockaderId, \"blockaderId\");\n        console.log(attackerBlockades.length, \"attacker blockades length\");\n        for (uint256 i; i < attackerBlockades.length; i++) {\n            if (attackerBlockades[i] == blockaderId) {\n                console.log(attackerBlockades[i], \"attacker blocades i\");\n                isBlockader = true;\n            } else {\n                isBlockader = false;\n            }\n        }\n        require(isBlockader, \"!blockaded by this nation\");\n        navAct.increaseAction(attackerId);\n        generateBreakBlockadeStruct(warId, attackerId, breakBlockadeId);\n        generateDefendBlockadeStruct(warId, blockaderId, breakBlockadeId);\n        generateBreakBlockadeChanceArray(breakBlockadeId);\n        generateDefendBlockadeChanceArray(breakBlockadeId);\n        war.cancelPeaceOffersUponAttack(warId);\n        fulfillRequest(breakBlockadeId);\n        breakBlockadeId++;\n    }\n\n    function generateBreakBlockadeStruct(\n        uint256 warId,\n        uint256 attackerId,\n        uint256 breakBlockId\n    ) internal {\n        uint256 battleships = nav.getBattleshipCount(attackerId);\n        uint256 cruisers = nav.getCruiserCount(attackerId);\n        uint256 frigates = nav2.getFrigateCount(attackerId);\n        uint256 destroyers = nav2.getDestroyerCount(attackerId);\n        BreakBlockade storage newBreakBlockade = breakBlockadeIdToBreakBlockade[\n            breakBlockId\n        ];\n        newBreakBlockade.battleshipCount = battleships;\n        newBreakBlockade.cruiserCount = cruisers;\n        newBreakBlockade.frigateCount = frigates;\n        newBreakBlockade.destroyerCount = destroyers;\n        newBreakBlockade.warId = warId;\n        newBreakBlockade.breakerId = attackerId;\n        uint256 strength = getBreakerStrength(attackerId);\n        newBreakBlockade.breakerStrength = strength;\n    }\n\n    function generateDefendBlockadeStruct(\n        uint256 warId,\n        uint256 defenderId,\n        uint256 breakBlockId\n    ) internal {\n        uint256 battleships = nav.getBattleshipCount(defenderId);\n        uint256 cruisers = nav.getCruiserCount(defenderId);\n        uint256 frigates = nav2.getFrigateCount(defenderId);\n        uint256 submarines = nav2.getSubmarineCount(defenderId);\n        DefendBlockade\n            storage newDefendBlockade = breakBlockadeIdToDefendBlockade[\n                breakBlockId\n            ];\n        newDefendBlockade.battleshipCount = battleships;\n        newDefendBlockade.cruiserCount = cruisers;\n        newDefendBlockade.frigateCount = frigates;\n        newDefendBlockade.submarineCount = submarines;\n        newDefendBlockade.warId = warId;\n        newDefendBlockade.defenderId = defenderId;\n        uint256 strength = getDefenderStrength(defenderId);\n        newDefendBlockade.defenderStrength = strength;\n    }\n\n    function generateBreakBlockadeChanceArray(uint256 breakBlockId) internal {\n        uint256[] storage chances = battleIdToBreakBlockadeChanceArray[\n            breakBlockId\n        ];\n        uint256[] storage types = battleIdToBreakBlockadeTypeArray[\n            breakBlockId\n        ];\n        uint256 cumulativeSum;\n        //battleship\n        if (breakBlockadeIdToBreakBlockade[breakBlockId].battleshipCount > 0) {\n            uint256 battleshipOdds = (breakBlockadeIdToBreakBlockade[\n                breakBlockId\n            ].battleshipCount * battleshipTargetSize);\n            uint256 battleshipOddsToPush = (battleshipOdds + cumulativeSum);\n            chances.push(battleshipOddsToPush);\n            types.push(3);\n            console.log(\"pushed a battleship\");\n            cumulativeSum = battleshipOddsToPush;\n        }\n        //cruiser\n        if (breakBlockadeIdToBreakBlockade[breakBlockId].cruiserCount > 0) {\n            uint256 cruiserOdds = (breakBlockadeIdToBreakBlockade[breakBlockId]\n                .cruiserCount * cruiserTargetSize);\n            uint256 cruiserOddsToPush = (cruiserOdds + cumulativeSum);\n            chances.push(cruiserOddsToPush);\n            types.push(4);\n            console.log(\"pushed a cruiser\");\n            cumulativeSum = cruiserOddsToPush;\n        }\n        //frigate\n        if (breakBlockadeIdToBreakBlockade[breakBlockId].frigateCount > 0) {\n            uint256 frigateOdds = (breakBlockadeIdToBreakBlockade[breakBlockId]\n                .frigateCount * frigateTargetSize);\n            uint256 frigateOddsToPush = (frigateOdds + cumulativeSum);\n            chances.push(frigateOddsToPush);\n            types.push(5);\n            console.log(\"pushed a frigate\");\n            cumulativeSum = frigateOddsToPush;\n        }\n        //destroyer\n        if (breakBlockadeIdToBreakBlockade[breakBlockId].destroyerCount > 0) {\n            uint256 destroyerOdds = (breakBlockadeIdToBreakBlockade[\n                breakBlockId\n            ].destroyerCount * destroyerTargetSize);\n            uint256 destroyerOddsToPush = (destroyerOdds + cumulativeSum);\n            chances.push(destroyerOddsToPush);\n            types.push(6);\n            console.log(\"pushed a destroyer\");\n            cumulativeSum = destroyerOddsToPush;\n        }\n        battleIdToBreakBlockadeChanceArray[breakBlockId] = chances;\n        battleIdToBreakBlockadeTypeArray[breakBlockId] = types;\n        battleIdToBreakBlockadeCumulativeSumOdds[breakBlockId] = cumulativeSum;\n    }\n\n    function generateDefendBlockadeChanceArray(uint256 breakBlockId) internal {\n        uint256[] storage chances = battleIdToDefendBlockadeChanceArray[\n            breakBlockId\n        ];\n        uint256[] storage types = battleIdToDefendBlockadeTypeArray[\n            breakBlockId\n        ];\n        uint256 cumulativeSum;\n        //battleship\n        if (breakBlockadeIdToDefendBlockade[breakBlockId].battleshipCount > 0) {\n            uint256 battleshipOdds = (breakBlockadeIdToDefendBlockade[\n                breakBlockId\n            ].battleshipCount * battleshipTargetSize);\n            uint256 battleshipOddsToPush = (battleshipOdds + cumulativeSum);\n            chances.push(battleshipOddsToPush);\n            types.push(3);\n            console.log(\"pushed a battleship DEFEND\");\n            cumulativeSum = battleshipOddsToPush;\n        }\n        //cruiser\n        if (breakBlockadeIdToDefendBlockade[breakBlockId].cruiserCount > 0) {\n            uint256 cruiserOdds = (breakBlockadeIdToDefendBlockade[breakBlockId]\n                .cruiserCount * cruiserTargetSize);\n            uint256 cruiserOddsToPush = (cruiserOdds + cumulativeSum);\n            chances.push(cruiserOddsToPush);\n            types.push(4);\n            console.log(\"pushed a cruiser DEFEND\");\n            cumulativeSum = cruiserOddsToPush;\n        }\n        //frigate\n        if (breakBlockadeIdToDefendBlockade[breakBlockId].frigateCount > 0) {\n            uint256 frigateOdds = (breakBlockadeIdToDefendBlockade[breakBlockId]\n                .frigateCount * frigateTargetSize);\n            uint256 frigateOddsToPush = (frigateOdds + cumulativeSum);\n            chances.push(frigateOddsToPush);\n            types.push(5);\n            console.log(\"pushed a frigate DEFEND\");\n            cumulativeSum = frigateOddsToPush;\n        }\n        //submarine\n        if (breakBlockadeIdToDefendBlockade[breakBlockId].submarineCount > 0) {\n            uint256 submarineOdds = (breakBlockadeIdToDefendBlockade[\n                breakBlockId\n            ].submarineCount * destroyerTargetSize);\n            uint256 submarineOddsToPush = (submarineOdds + cumulativeSum);\n            chances.push(submarineOddsToPush);\n            types.push(7);\n            console.log(\"pushed a submarine DEFEND\");\n            cumulativeSum = submarineOddsToPush;\n        }\n        battleIdToDefendBlockadeChanceArray[breakBlockId] = chances;\n        battleIdToDefendBlockadeTypeArray[breakBlockId] = types;\n        battleIdToDefendBlockadeCumulativeSumOdds[breakBlockId] = cumulativeSum;\n    }\n\n    function getBreakerStrength(\n        uint256 battleId\n    ) public view returns (uint256) {\n        uint256 _battleshipStrength = breakBlockadeIdToBreakBlockade[battleId]\n            .battleshipCount * battleshipStrength;\n        uint256 _cruiserStrength = breakBlockadeIdToBreakBlockade[battleId]\n            .cruiserCount * cruiserStrength;\n        uint256 _frigateStrength = breakBlockadeIdToBreakBlockade[battleId]\n            .frigateCount * frigateStrength;\n        uint256 _destroyerStrength = breakBlockadeIdToBreakBlockade[battleId]\n            .destroyerCount * destroyerStrength;\n        uint256 strength = (_battleshipStrength +\n            _cruiserStrength +\n            _frigateStrength +\n            _destroyerStrength);\n        uint256 breakerId = breakBlockadeIdToBreakBlockade[battleId].breakerId;\n        uint256 navalAcademyCount = imp4.getNavalAcademyCount(breakerId);\n        if (navalAcademyCount > 0) {\n            uint256 breakerShipCount = getBreakerShipCount(breakerId);\n            strength += (breakerShipCount * navalAcademyCount);\n        }\n        return strength;\n    }\n\n    function getDefenderStrength(\n        uint256 battleId\n    ) public view returns (uint256) {\n        uint256 _battleshipStrength = breakBlockadeIdToDefendBlockade[battleId]\n            .battleshipCount * battleshipStrength;\n        uint256 _cruiserStrength = breakBlockadeIdToDefendBlockade[battleId]\n            .cruiserCount * cruiserStrength;\n        uint256 _frigateStrength = breakBlockadeIdToDefendBlockade[battleId]\n            .frigateCount * frigateStrength;\n        uint256 _submarineStrength = breakBlockadeIdToDefendBlockade[battleId]\n            .submarineCount * submarineStrength;\n        uint256 strength = (_battleshipStrength +\n            _cruiserStrength +\n            _frigateStrength +\n            _submarineStrength);\n        uint256 defenderId = breakBlockadeIdToDefendBlockade[battleId]\n            .defenderId;\n        uint256 navalAcademyCount = imp4.getNavalAcademyCount(defenderId);\n        if (navalAcademyCount > 0) {\n            uint256 defenderShipCount = getDefenderShipCount(defenderId);\n            strength += (defenderShipCount * navalAcademyCount);\n        }\n        return strength;\n    }\n\n    function fulfillRequest(uint256 battleId) public {\n        uint256 requestId = i_vrfCoordinator.requestRandomWords(\n            i_gasLane,\n            i_subscriptionId,\n            REQUEST_CONFIRMATIONS,\n            i_callbackGasLimit,\n            NUM_WORDS\n        );\n        s_requestIdToRequestIndex[requestId] = battleId;\n    }\n\n    bytes32 navyAttackJobId;\n    address oracleAddress;\n    uint256 fee;\n\n    // address linkAddress;\n\n    function updateJobId(bytes32 _jobId) public onlyOwner {\n        navyAttackJobId = _jobId;\n    }\n\n    function updateOracleAddress(address _oracleAddress) public onlyOwner {\n        setChainlinkOracle(_oracleAddress);\n        oracleAddress = _oracleAddress;\n    }\n\n    function updateFee(uint256 _fee) public onlyOwner {\n        fee = _fee;\n    }\n\n    function updateLinkAddress(address _linkAddress) public onlyOwner {\n        setChainlinkToken(_linkAddress);\n        // linkAddress = _linkAddress;\n    }\n\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) internal override {\n        console.log(\"fulfill random words\");\n        Chainlink.Request memory req = buildOperatorRequest(\n            navyAttackJobId,\n            this.completeBattleSequence.selector\n        );\n        uint256 requestNumber = s_requestIdToRequestIndex[requestId];\n        console.log(requestNumber, \"requestNumber\");\n        req.addUint(\"battleId\", requestNumber);\n        req.addBytes(\"randomWords\", abi.encode(randomWords));\n        s_requestIndexToRandomWords[requestNumber] = randomWords;\n        uint256[] memory attackerChances = battleIdToBreakBlockadeChanceArray[\n            requestNumber\n        ];\n        uint256[] memory attackerTypes = battleIdToBreakBlockadeTypeArray[\n            requestNumber\n        ];\n        uint256[] memory defenderChances = battleIdToDefendBlockadeChanceArray[\n            requestNumber\n        ];\n        uint256[] memory defenderTypes = battleIdToDefendBlockadeTypeArray[\n            requestNumber\n        ];\n        console.log(attackerChances[0], attackerChances[1], attackerChances[2]);\n        console.log(attackerTypes[0], attackerTypes[1], attackerTypes[2]);\n        console.log(defenderChances[0], defenderChances[1], defenderChances[2]);\n        console.log(defenderTypes[0], defenderTypes[1], defenderTypes[2]);\n        req.addBytes(\"attackerChances\", abi.encode(attackerChances));\n        req.addBytes(\"attackerTypes\", abi.encode(attackerTypes));\n        req.addBytes(\"defenderChances\", abi.encode(defenderChances));\n        req.addBytes(\"defenderTypes\", abi.encode(defenderTypes));\n        sendOperatorRequest(req, fee);\n        console.log(\"request sent\");\n        // uint256 breakerStartingStrength = getBreakerStrength(requestNumber);\n        // console.log(breakerStartingStrength, \"breaker starting strength\");\n        // uint256 defenderStartingStrength = getDefenderStrength(requestNumber);\n        // console.log(defenderStartingStrength, \"defender starting strength\");\n        // uint256 totalStrength = (breakerStartingStrength +\n        //     defenderStartingStrength);\n        // console.log(totalStrength, \"total strength\");\n        // console.log(randomNumberForBattle, \"random number for battle\");\n        // uint256 outcomeNumber = (randomNumberForBattle % totalStrength);\n        // console.log(outcomeNumber, \"outcome number\");\n        // completeBattleSequesnce(\n        //     requestNumber,\n        //     outcomeNumber,\n        //     breakerStartingStrength,\n        //     randomWords\n        // );\n    }\n\n    event BreakBlockadeComlpete(\n        uint256[] attackerLosses,\n        uint256[] defenderLosses,\n        uint256 battleId\n    );\n\n    function completeBattleSequence(\n        bytes32 requestId,\n        uint256[] memory _attackerLosses,\n        uint256[] memory _defenderLosses,\n        uint256 battleId\n    ) public recordChainlinkFulfillment(requestId) {\n\n        emit BreakBlockadeComlpete(_attackerLosses, _defenderLosses, battleId);\n\n        // console.log(_defenderLosses[0]);\n        // console.log(_defenderLosses[1]);\n        // console.log(_defenderLosses[2]);\n        // console.log(battleId);\n        // uint256[] storage defenderLosses = battleIdToDefendBlockadeLosses[\n        //     requestNumber\n        // ];\n        // uint256[] storage breakerLosses = battleIdToBreakBlockadeLosses[\n        //     requestNumber\n        // ];\n        // uint256 _defenderId = breakBlockadeIdToDefendBlockade[requestNumber]\n        //     .defenderId;\n        // uint256 _breakerId = breakBlockadeIdToBreakBlockade[requestNumber]\n        //     .breakerId;\n        // if (outcomeNumber <= breakerStartingStrength) {\n        //     console.log(\"blokckader loss\");\n        //     uint256[] memory typeArray = battleIdToDefendBlockadeTypeArray[\n        //         requestNumber\n        //     ];\n        //     uint256 randomArray = (randomWords[1] % typeArray.length);\n        //     uint256 shipType = typeArray[randomArray];\n        //     console.log(shipType, \"ship type\");\n        //     defenderLosses.push(shipType);\n        //     console.log(\"umm\");\n        //     navBlock.breakBlockade(_defenderId, _breakerId);\n        // } else {\n        //     console.log(\"breaker loss\");\n        //     uint256[] memory typeArray = battleIdToBreakBlockadeTypeArray[\n        //         requestNumber\n        //     ];\n        //     uint256 randomArray = (randomWords[1] % typeArray.length);\n        //     uint256 shipType = typeArray[randomArray];\n        //     console.log(shipType, \"ship type\");\n        //     breakerLosses.push(shipType);\n        // }\n        // console.log(breakerLosses.length, \"breaker losses\");\n        // console.log(defenderLosses.length, \"defender losses\");\n        // nav.decrementLosses(\n        //     defenderLosses,\n        //     _defenderId,\n        //     breakerLosses,\n        //     _breakerId\n        // );\n        // uint256 warId = breakBlockadeIdToBreakBlockade[requestNumber].warId;\n        // war.addNavyCasualties(warId, _breakerId, breakerLosses.length);\n        // war.addNavyCasualties(warId, _defenderId, defenderLosses.length);\n        // console.log(\"maybe\");\n    }\n\n    // function getLosses(uint256 battleId, uint256 numberBetweenZeroAndTwo)\n    //     public\n    //     view\n    //     returns (uint256)\n    // {\n    //     uint256 breakerId = breakBlockadeIdToBreakBlockade[battleId].breakerId;\n    //     uint256 breakerCount = getBreakerShipCount(breakerId);\n    //     uint256 defenderId = breakBlockadeIdToDefendBlockade[battleId]\n    //         .defenderId;\n    //     uint256 defenderCount = getDefenderShipCount(defenderId);\n    //     uint256 totalShips = (breakerCount + defenderCount);\n    //     uint256 losses;\n    //     if (totalShips < 4) {\n    //         losses = 1;\n    //     } else if (totalShips <= 10) {\n    //         losses = (1 + numberBetweenZeroAndTwo);\n    //     } else if (totalShips <= 30) {\n    //         losses = (2 + numberBetweenZeroAndTwo);\n    //     } else if (totalShips <= 50) {\n    //         losses = (3 + numberBetweenZeroAndTwo);\n    //     } else if (totalShips <= 70) {\n    //         losses = (4 + numberBetweenZeroAndTwo);\n    //     } else if (totalShips <= 100) {\n    //         losses = (5 + numberBetweenZeroAndTwo);\n    //     } else {\n    //         losses = (6 + numberBetweenZeroAndTwo);\n    //     }\n    //     console.log(losses, \"losses\");\n    //     return losses;\n    // }\n\n    function getBreakerShipCount(\n        uint256 countryId\n    ) internal view returns (uint256) {\n        uint256 battleshipCount = nav.getBattleshipCount(countryId);\n        uint256 cruiserCount = nav.getCruiserCount(countryId);\n        uint256 frigateCount = nav2.getFrigateCount(countryId);\n        uint256 destroyerCount = nav2.getDestroyerCount(countryId);\n        uint256 count = (battleshipCount +\n            cruiserCount +\n            frigateCount +\n            destroyerCount);\n        return count;\n    }\n\n    function getDefenderShipCount(\n        uint256 countryId\n    ) internal view returns (uint256) {\n        uint256 battleshipCount = nav.getBattleshipCount(countryId);\n        uint256 cruiserCount = nav.getCruiserCount(countryId);\n        uint256 frigateCount = nav2.getFrigateCount(countryId);\n        uint256 submarineCount = nav2.getSubmarineCount(countryId);\n        uint256 count = (battleshipCount +\n            cruiserCount +\n            frigateCount +\n            submarineCount);\n        return count;\n    }\n\n    function generateLossForDefender(\n        uint256 battleId,\n        uint256 randomNumberForShipLoss\n    ) public {\n        // uint256[] storage chanceArray = battleIdToDefendBlockadeChanceArray[\n        //     battleId\n        // ];\n        // uint256[] storage typeArray = battleIdToDefendBlockadeTypeArray[\n        //     battleId\n        // ];\n        // uint256 randomArray = (randomNumberForShipLoss % typeArray.length);\n        // uint256 shipType = typeArray[randomArray];\n        // uint256[] storage defenderLosses = battleIdToDefendBlockadeLosses[\n        //     battleId\n        // ];\n        // defenderLosses.push(shipType);\n        // battleship\n        // cruiser\n        // frigate\n        // destroyer / submarine\n        // if (shipType == 3) {\n        // }\n        // uint256 cumulativeValue = battleIdToDefendBlockadeCumulativeSumOdds[\n        //     battleId\n        // ];\n        // uint256 randomNumber = (randomNumberForShipLoss % cumulativeValue);\n        // uint256 shipType;\n        // uint256 amountToDecrease;\n        // uint256 j;\n        // for (uint256 i; i < chanceArray.length; i++) {\n        //     if (randomNumber <= chanceArray[i]) {\n        //         shipType = typeArray[i];\n        //         amountToDecrease = getAmountToDecrease(shipType);\n        //         j = i;\n        //         break;\n        //     }\n        // }\n        // for (j; j < chanceArray.length; j++) {\n        //     if (chanceArray[j] >= randomNumber) {\n        //         chanceArray[j] -= amountToDecrease;\n        //     }\n        // }\n        // battleIdToDefendBlockadeCumulativeSumOdds[battleId] -= amountToDecrease;\n    }\n\n    // function generateLossForBreaker(\n    //     uint256 battleId,\n    //     uint256 randomNumberForShipLoss\n    // ) public {\n    //     uint256[] storage chanceArray = battleIdToBreakBlockadeChanceArray[\n    //         battleId\n    //     ];\n    //     uint256[] storage typeArray = battleIdToBreakBlockadeTypeArray[\n    //         battleId\n    //     ];\n    //     uint256 cumulativeValue = battleIdToBreakBlockadeCumulativeSumOdds[\n    //         battleId\n    //     ];\n    //     uint256 randomNumber = (randomNumberForShipLoss % cumulativeValue);\n    //     uint256 shipType;\n    //     uint256 amountToDecrease;\n    //     bool ranAlready = false;\n    //     if (ranAlready == false) {\n    //         for (uint256 i; i < chanceArray.length; i++) {\n    //             if (randomNumber <= chanceArray[i]) {\n    //                 shipType = typeArray[i];\n    //                 amountToDecrease = getAmountToDecrease(shipType);\n    //             }\n    //             uint256 j = i;\n    //             for (j; j < chanceArray.length; j++) {\n    //                 if (chanceArray[j] >= randomNumber) {\n    //                     chanceArray[j] -= amountToDecrease;\n    //                 }\n    //                 ranAlready = true;\n    //             }\n    //         }\n    //     }\n    //     battleIdToBreakBlockadeCumulativeSumOdds[battleId] -= amountToDecrease;\n    //     uint256[] storage defenderLosses = battleIdToBreakBlockadeLosses[\n    //         battleId\n    //     ];\n    //     defenderLosses.push(shipType);\n    // }\n\n    // function getAmountToDecrease(uint256 shipType)\n    //     internal\n    //     pure\n    //     returns (uint256)\n    // {\n    //     uint256 amountToDecrease;\n    //     if (shipType == 1) {\n    //         amountToDecrease = 15;\n    //     } else if (shipType == 2) {\n    //         amountToDecrease = 13;\n    //     } else if (shipType == 3) {\n    //         amountToDecrease = 11;\n    //     } else if (shipType == 4) {\n    //         amountToDecrease = 10;\n    //     } else if (shipType == 5) {\n    //         amountToDecrease = 8;\n    //     } else if (shipType == 6) {\n    //         amountToDecrease = 5;\n    //     } else if (shipType == 7) {\n    //         amountToDecrease = 4;\n    //     } else if (shipType == 8) {\n    //         amountToDecrease = 1;\n    //     }\n    //     return amountToDecrease;\n    // }\n}\n\n///@title NavalAttackContract\n///@author OxSnosh\n///@dev this contract inherits from the openzeppelin ownable contract\n///@dev this contract inherits from the chainlink VRF contract\ncontract NavalAttackContract is Ownable, VRFConsumerBaseV2, ChainlinkClient {\n    using Chainlink for Chainlink.Request;\n\n    address public navy;\n    uint256 public navyBattleId;\n    address public navyBlockade;\n    address public warAddress;\n    address public improvements4;\n    address public navalActions;\n    address public navy2;\n\n    uint256 corvetteStrength = 1;\n    uint256 landingShipStrength = 3;\n    uint256 battleshipStrength = 5;\n    uint256 cruiserStrength = 6;\n    uint256 frigateStrength = 8;\n    uint256 destroyerStrength = 11;\n    uint256 submarineStrength = 12;\n    uint256 aircraftCarrierStrength = 15;\n    uint256 corvetteTargetSize = 15;\n    uint256 landingShipTargetSize = 13;\n    uint256 battleshipTargetSize = 11;\n    uint256 cruiserTargetSize = 10;\n    uint256 frigateTargetSize = 8;\n    uint256 destroyerTargetSize = 5;\n    uint256 submarineTargetSize = 4;\n    uint256 aircraftCarrierTargetSize = 1;\n\n    //Chainlik Variables\n    uint256[] private s_randomWords;\n    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;\n    uint64 private immutable i_subscriptionId;\n    bytes32 private immutable i_gasLane;\n    uint32 private immutable i_callbackGasLimit;\n    uint16 private constant REQUEST_CONFIRMATIONS = 3;\n    uint32 private constant NUM_WORDS = 6;\n\n    NavyContract nav;\n    NavalBlockadeContract navBlock;\n    WarContract war;\n    ImprovementsContract4 imp4;\n    NavalActionsContract navAct;\n    NavyContract2 nav2;\n\n    struct NavyForces {\n        uint256 corvetteCount;\n        uint256 landingShipCount;\n        uint256 battleshipCount;\n        uint256 cruiserCount;\n        uint256 frigateCount;\n        uint256 destroyerCount;\n        uint256 submarineCount;\n        uint256 aircraftCarrierCount;\n        uint256 startingStrength;\n        uint256 warId;\n        uint256 countryId;\n    }\n\n    mapping(uint256 => NavyForces) idToAttackerNavy;\n    mapping(uint256 => NavyForces) idToDefenderNavy;\n    mapping(uint256 => uint256[]) battleIdToAttackerChanceArray;\n    mapping(uint256 => uint256[]) battleIdToAttackerTypeArray;\n    mapping(uint256 => uint256) battleIdToAttackerCumulativeSumOdds;\n    mapping(uint256 => uint256[]) battleIdToAttackerLosses;\n    mapping(uint256 => uint256[]) battleIdToDefenderChanceArray;\n    mapping(uint256 => uint256[]) battleIdToDefenderTypeArray;\n    mapping(uint256 => uint256) battleIdToDefenderCumulativeSumOdds;\n    mapping(uint256 => uint256[]) battleIdToDefenderLosses;\n    mapping(uint256 => uint256) s_requestIdToRequestIndex;\n    mapping(uint256 => uint256[]) public s_requestIndexToRandomWords;\n\n    constructor(\n        address vrfCoordinatorV2,\n        uint64 subscriptionId,\n        bytes32 gasLane, // keyHash\n        uint32 callbackGasLimit\n    ) VRFConsumerBaseV2(vrfCoordinatorV2) {\n        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2);\n        i_gasLane = gasLane;\n        i_subscriptionId = subscriptionId;\n        i_callbackGasLimit = callbackGasLimit;\n    }\n\n    function settings(\n        address _navy,\n        address _war,\n        address _improvements4,\n        address _navalActions,\n        address _navy2\n    ) public onlyOwner {\n        navy = _navy;\n        nav = NavyContract(_navy);\n        warAddress = _war;\n        war = WarContract(_war);\n        improvements4 = _improvements4;\n        imp4 = ImprovementsContract4(_improvements4);\n        navalActions = _navalActions;\n        navAct = NavalActionsContract(_navalActions);\n        navy2 = _navy2;\n        nav2 = NavyContract2(_navy2);\n    }\n\n    ///@dev this is a public function callable only from the nation owner\n    ///@dev this function allows a nation to attack the navy of another nation\n    ///@notice this function allows a nation to attack the navy of another nation\n    ///@param warId is the war id of the active war between the 2 nations\n    ///@param attackerId is the id of the attacking nation\n    ///@param defenderId is the nation id of the defending nation\n    function navalAttack(\n        uint256 warId,\n        uint256 attackerId,\n        uint256 defenderId\n    ) public {\n        bool isActiveWar = war.isWarActive(warId);\n        require(isActiveWar, \"!active war\");\n        uint256 slotsUsed = navAct.getActionSlotsUsed(attackerId);\n        require((slotsUsed + 1) <= 3, \"max slots used\");\n        (uint256 warOffense, uint256 warDefense) = war.getInvolvedParties(\n            warId\n        );\n        require(\n            warOffense == attackerId || warOffense == defenderId,\n            \"invalid parameters\"\n        );\n        require(\n            warDefense == attackerId || warDefense == defenderId,\n            \"invalid parameters\"\n        );\n        generateAttackerNavyStruct(warId, navyBattleId, attackerId);\n        generateDefenderNavyStruct(warId, navyBattleId, defenderId);\n        generateAttackerChanceArray(navyBattleId);\n        generateDefenderChanceArray(navyBattleId);\n        war.cancelPeaceOffersUponAttack(warId);\n        fulfillRequest(navyBattleId);\n        navAct.increaseAction(attackerId);\n        navyBattleId++;\n    }\n\n    function generateAttackerNavyStruct(\n        uint256 warId,\n        uint256 battleId,\n        uint256 countryId\n    ) internal {\n        uint256 corvetteCount = nav.getCorvetteCount(countryId);\n        uint256 landingShipCount = nav.getLandingShipCount(countryId);\n        uint256 battleshipCount = nav.getBattleshipCount(countryId);\n        uint256 cruiserCount = nav.getCruiserCount(countryId);\n        uint256 frigateCount = nav2.getFrigateCount(countryId);\n        uint256 destroyerCount = nav2.getDestroyerCount(countryId);\n        uint256 submarineCount = nav2.getSubmarineCount(countryId);\n        uint256 aircraftCarrierCount = nav2.getAircraftCarrierCount(countryId);\n        console.log(\"creating struct\");\n        console.log(\n            battleshipCount,\n            cruiserCount,\n            frigateCount,\n            submarineCount\n        );\n        NavyForces storage newNavyForces = idToAttackerNavy[battleId];\n        newNavyForces.corvetteCount = corvetteCount;\n        newNavyForces.landingShipCount = landingShipCount;\n        newNavyForces.battleshipCount = battleshipCount;\n        console.log(\n            \"battleship count from mapping\",\n            idToAttackerNavy[battleId].battleshipCount,\n            battleId\n        );\n        newNavyForces.cruiserCount = cruiserCount;\n        newNavyForces.frigateCount = frigateCount;\n        newNavyForces.destroyerCount = destroyerCount;\n        newNavyForces.submarineCount = submarineCount;\n        newNavyForces.aircraftCarrierCount = aircraftCarrierCount;\n        uint256 strengthAttacker = getAttackerStrength(navyBattleId);\n        newNavyForces.startingStrength = strengthAttacker;\n        newNavyForces.warId = warId;\n        newNavyForces.countryId = countryId;\n    }\n\n    function generateDefenderNavyStruct(\n        uint256 warId,\n        uint256 attackId,\n        uint256 countryId\n    ) internal {\n        uint256 corvetteCount = nav.getCorvetteCount(countryId);\n        uint256 landingShipCount = nav.getLandingShipCount(countryId);\n        uint256 battleshipCount = nav.getBattleshipCount(countryId);\n        uint256 cruiserCount = nav.getCruiserCount(countryId);\n        uint256 frigateCount = nav2.getFrigateCount(countryId);\n        uint256 destroyerCount = nav2.getDestroyerCount(countryId);\n        uint256 submarineCount = nav2.getSubmarineCount(countryId);\n        uint256 aircraftCarrierCount = nav2.getAircraftCarrierCount(countryId);\n        console.log(\n            battleshipCount,\n            cruiserCount,\n            frigateCount,\n            submarineCount\n        );\n        NavyForces storage newNavyForces = idToDefenderNavy[attackId];\n        newNavyForces.corvetteCount = corvetteCount;\n        newNavyForces.landingShipCount = landingShipCount;\n        newNavyForces.battleshipCount = battleshipCount;\n        newNavyForces.cruiserCount = cruiserCount;\n        newNavyForces.frigateCount = frigateCount;\n        newNavyForces.destroyerCount = destroyerCount;\n        newNavyForces.submarineCount = submarineCount;\n        newNavyForces.aircraftCarrierCount = aircraftCarrierCount;\n        uint256 defenderStrength = getDefenderStrength(navyBattleId);\n        newNavyForces.startingStrength = defenderStrength;\n        newNavyForces.warId = warId;\n        newNavyForces.countryId = countryId;\n    }\n\n    function generateAttackerChanceArray(uint256 battleId) internal {\n        uint256[] storage chances = battleIdToAttackerChanceArray[battleId];\n        uint256[] storage types = battleIdToAttackerTypeArray[battleId];\n        uint256 cumulativeSum;\n        //corvette\n        if (idToAttackerNavy[battleId].corvetteCount > 0) {\n            uint256 corvetteOdds = (idToAttackerNavy[battleId].corvetteCount *\n                corvetteTargetSize);\n            chances.push(corvetteOdds);\n            types.push(1);\n            cumulativeSum = corvetteOdds;\n        }\n        //landing ship\n        if (idToAttackerNavy[battleId].landingShipCount > 0) {\n            uint256 landingShipOdds = (idToAttackerNavy[battleId]\n                .landingShipCount * landingShipTargetSize);\n            uint256 landingShipOddsToPush = (landingShipOdds + cumulativeSum);\n            chances.push(landingShipOddsToPush);\n            types.push(2);\n            cumulativeSum = landingShipOddsToPush;\n        }\n        //battleship\n        console.log(\n            idToAttackerNavy[battleId].battleshipCount,\n            \"triggering array generation\"\n        );\n        if (idToAttackerNavy[battleId].battleshipCount > 0) {\n            console.log(\"creating chance and type array\");\n            uint256 battleshipOdds = (idToAttackerNavy[battleId]\n                .battleshipCount * battleshipTargetSize);\n            uint256 battleshipOddsToPush = (battleshipOdds + cumulativeSum);\n            chances.push(battleshipOddsToPush);\n            console.log(chances[chances.length - 1]);\n            types.push(3);\n            console.log(types[types.length - 1]);\n            cumulativeSum = battleshipOddsToPush;\n        }\n        //cruiser\n        if (idToAttackerNavy[battleId].cruiserCount > 0) {\n            uint256 cruiserOdds = (idToAttackerNavy[battleId].cruiserCount *\n                cruiserTargetSize);\n            uint256 cruiserOddsToPush = (cruiserOdds + cumulativeSum);\n            chances.push(cruiserOddsToPush);\n            types.push(4);\n            cumulativeSum = cruiserOddsToPush;\n        }\n        //frigate\n        if (idToAttackerNavy[battleId].frigateCount > 0) {\n            uint256 frigateOdds = (idToAttackerNavy[battleId].frigateCount *\n                frigateTargetSize);\n            uint256 frigateOddsToPush = (frigateOdds + cumulativeSum);\n            chances.push(frigateOddsToPush);\n            types.push(5);\n            cumulativeSum = frigateOddsToPush;\n        }\n        //destroyer\n        if (idToAttackerNavy[battleId].destroyerCount > 0) {\n            uint256 destroyerOdds = (idToAttackerNavy[battleId].destroyerCount *\n                destroyerTargetSize);\n            uint256 destroyerOddsToPush = (destroyerOdds + cumulativeSum);\n            chances.push(destroyerOddsToPush);\n            types.push(6);\n            cumulativeSum = destroyerOddsToPush;\n        }\n        //submarine\n        if (idToAttackerNavy[battleId].submarineCount > 0) {\n            uint256 submarineOdds = (idToAttackerNavy[battleId].submarineCount *\n                submarineTargetSize);\n            uint256 submarineOddsToPush = (submarineOdds + cumulativeSum);\n            chances.push(submarineOddsToPush);\n            types.push(7);\n            cumulativeSum = submarineOddsToPush;\n        }\n        //aircraft carrier\n        if (idToAttackerNavy[battleId].aircraftCarrierCount > 0) {\n            uint256 aircraftCarrierOdds = (idToAttackerNavy[battleId]\n                .aircraftCarrierCount * aircraftCarrierTargetSize);\n            uint256 aircraftCarrierOddsToPush = (aircraftCarrierOdds +\n                cumulativeSum);\n            chances.push(aircraftCarrierOddsToPush);\n            types.push(8);\n            cumulativeSum = aircraftCarrierOddsToPush;\n        }\n        battleIdToAttackerChanceArray[battleId] = chances;\n        battleIdToAttackerTypeArray[battleId] = types;\n        battleIdToAttackerCumulativeSumOdds[battleId] = cumulativeSum;\n    }\n\n    function generateDefenderChanceArray(uint256 battleId) internal {\n        uint256[] storage chances = battleIdToDefenderChanceArray[battleId];\n        uint256[] storage types = battleIdToDefenderTypeArray[battleId];\n        uint256 cumulativeSum;\n        //corvette\n        if (idToDefenderNavy[battleId].corvetteCount > 0) {\n            uint256 corvetteOdds = (idToDefenderNavy[battleId].corvetteCount *\n                corvetteTargetSize);\n            chances.push(corvetteOdds);\n            types.push(1);\n            cumulativeSum += corvetteOdds;\n        }\n        //landing ship\n        if (idToDefenderNavy[battleId].landingShipCount > 0) {\n            uint256 landingShipOdds = (idToDefenderNavy[battleId]\n                .landingShipCount * landingShipTargetSize);\n            uint256 landingShipOddsToPush = (landingShipOdds + cumulativeSum);\n            chances.push(landingShipOddsToPush);\n            types.push(2);\n            cumulativeSum = landingShipOddsToPush;\n        }\n        //battleship\n        if (idToDefenderNavy[battleId].battleshipCount > 0) {\n            uint256 battleshipOdds = (idToDefenderNavy[battleId]\n                .battleshipCount * battleshipTargetSize);\n            uint256 battleshipOddsToPush = (battleshipOdds + cumulativeSum);\n            chances.push(battleshipOddsToPush);\n            types.push(3);\n            cumulativeSum = battleshipOddsToPush;\n        }\n        //cruiser\n        if (idToDefenderNavy[battleId].cruiserCount > 0) {\n            uint256 cruiserOdds = (idToDefenderNavy[battleId].cruiserCount *\n                cruiserTargetSize);\n            uint256 cruiserOddsToPush = (cruiserOdds + cumulativeSum);\n            chances.push(cruiserOddsToPush);\n            types.push(4);\n            cumulativeSum = cruiserOddsToPush;\n        }\n        //frigate\n        if (idToDefenderNavy[battleId].frigateCount > 0) {\n            uint256 frigateOdds = (idToDefenderNavy[battleId].frigateCount *\n                frigateTargetSize);\n            uint256 frigateOddsToPush = (frigateOdds + cumulativeSum);\n            chances.push(frigateOddsToPush);\n            types.push(5);\n            cumulativeSum = frigateOddsToPush;\n        }\n        //destroyer\n        if (idToDefenderNavy[battleId].destroyerCount > 0) {\n            uint256 destroyerOdds = (idToDefenderNavy[battleId].destroyerCount *\n                destroyerTargetSize);\n            uint256 destroyerOddsToPush = (destroyerOdds + cumulativeSum);\n            chances.push(destroyerOddsToPush);\n            types.push(6);\n            cumulativeSum = destroyerOddsToPush;\n        }\n        //submarine\n        if (idToDefenderNavy[battleId].submarineCount > 0) {\n            uint256 submarineOdds = (idToDefenderNavy[battleId].submarineCount *\n                submarineTargetSize);\n            uint256 submarineOddsToPush = (submarineOdds + cumulativeSum);\n            chances.push(submarineOddsToPush);\n            types.push(7);\n            cumulativeSum = submarineOddsToPush;\n        }\n        //aircraft carrier\n        if (idToDefenderNavy[battleId].aircraftCarrierCount > 0) {\n            uint256 aircraftCarrierOdds = (idToDefenderNavy[battleId]\n                .aircraftCarrierCount * aircraftCarrierTargetSize);\n            uint256 aircraftCarrierOddsToPush = (aircraftCarrierOdds +\n                cumulativeSum);\n            chances.push(aircraftCarrierOddsToPush);\n            types.push(8);\n            cumulativeSum = aircraftCarrierOddsToPush;\n        }\n        battleIdToDefenderChanceArray[battleId] = chances;\n        battleIdToDefenderTypeArray[battleId] = types;\n        battleIdToDefenderCumulativeSumOdds[battleId] = cumulativeSum;\n    }\n\n    function getAttackerStrength(\n        uint256 battleId\n    ) public view returns (uint256) {\n        uint256 _corvetteStrength = idToAttackerNavy[battleId].corvetteCount *\n            corvetteStrength;\n        uint256 _landingShipStrength = idToAttackerNavy[battleId]\n            .landingShipCount * landingShipStrength;\n        uint256 _battleshipStrength = idToAttackerNavy[battleId]\n            .battleshipCount * battleshipStrength;\n        console.log(\n            \"count from getStrenf()\",\n            idToAttackerNavy[battleId].battleshipCount\n        );\n        uint256 _cruiserStrength = idToAttackerNavy[battleId].cruiserCount *\n            cruiserStrength;\n        console.log(\n            \"count from getStrenf()\",\n            idToAttackerNavy[battleId].cruiserCount\n        );\n        uint256 _frigateStrength = idToAttackerNavy[battleId].frigateCount *\n            frigateStrength;\n        uint256 _destroyerStrength = idToAttackerNavy[battleId].destroyerCount *\n            destroyerStrength;\n        uint256 _submarineStrength = idToAttackerNavy[battleId].submarineCount *\n            submarineStrength;\n        uint256 _aircraftCarrierStrength = idToAttackerNavy[battleId]\n            .aircraftCarrierCount * aircraftCarrierStrength;\n        console.log(\"cruisers\", idToAttackerNavy[battleId].cruiserCount);\n        console.log(\"cruiser strength\", _cruiserStrength);\n        console.log(\"cruiser strength\", cruiserStrength);\n        uint256 strength = (_corvetteStrength +\n            _landingShipStrength +\n            _battleshipStrength +\n            _cruiserStrength +\n            _frigateStrength +\n            _destroyerStrength +\n            _submarineStrength +\n            _aircraftCarrierStrength);\n        uint256 attackerId = idToAttackerNavy[battleId].countryId;\n        uint256 navalAcademyCount = imp4.getNavalAcademyCount(attackerId);\n        if (navalAcademyCount > 0) {\n            uint256 shipCount = getShipCount(attackerId);\n            strength += (shipCount * navalAcademyCount);\n        }\n        console.log(\"strength att\", strength);\n        return strength;\n    }\n\n    function getDefenderStrength(\n        uint256 battleId\n    ) public view returns (uint256) {\n        uint256 _corvetteStrength = idToDefenderNavy[battleId].corvetteCount *\n            corvetteStrength;\n        uint256 _landingShipStrength = idToDefenderNavy[battleId]\n            .landingShipCount * landingShipStrength;\n        uint256 _battleshipStrength = idToDefenderNavy[battleId]\n            .battleshipCount * battleshipStrength;\n        console.log(\n            \"count from getStrenf()\",\n            idToDefenderNavy[battleId].battleshipCount\n        );\n        uint256 _cruiserStrength = idToDefenderNavy[battleId].cruiserCount *\n            cruiserStrength;\n        console.log(\n            \"count from getStrenf()\",\n            idToDefenderNavy[battleId].cruiserCount\n        );\n        uint256 _frigateStrength = idToDefenderNavy[battleId].frigateCount *\n            frigateStrength;\n        uint256 _destroyerStrength = idToDefenderNavy[battleId].destroyerCount *\n            destroyerStrength;\n        uint256 _submarineStrength = idToDefenderNavy[battleId].submarineCount *\n            submarineStrength;\n        uint256 _aircraftCarrierStrength = idToDefenderNavy[battleId]\n            .aircraftCarrierCount * aircraftCarrierStrength;\n        uint256 strength = (_corvetteStrength +\n            _landingShipStrength +\n            _battleshipStrength +\n            _cruiserStrength +\n            _frigateStrength +\n            _destroyerStrength +\n            _submarineStrength +\n            _aircraftCarrierStrength);\n        uint256 defenderId = idToDefenderNavy[battleId].countryId;\n        uint256 navalAcademyCount = imp4.getNavalAcademyCount(defenderId);\n        if (navalAcademyCount > 0) {\n            uint256 shipCount = getShipCount(defenderId);\n            strength += (shipCount * navalAcademyCount);\n        }\n        console.log(\"strength def\", strength);\n        return strength;\n    }\n\n    function fulfillRequest(uint256 battleId) public {\n        console.log(\"arrived at fulfillRequest()\");\n        uint256 requestId = i_vrfCoordinator.requestRandomWords(\n            i_gasLane,\n            i_subscriptionId,\n            REQUEST_CONFIRMATIONS,\n            i_callbackGasLimit,\n            NUM_WORDS\n        );\n        console.log(\"random words requested\");\n        s_requestIdToRequestIndex[requestId] = battleId;\n    }\n\n    bytes32 navyAttackJobId;\n    address oracleAddress;\n    uint256 fee;\n\n    // address linkAddress;\n\n    function updateJobId(bytes32 _jobId) public onlyOwner {\n        navyAttackJobId = _jobId;\n    }\n\n    function updateOracleAddress(address _oracleAddress) public onlyOwner {\n        setChainlinkOracle(_oracleAddress);\n        oracleAddress = _oracleAddress;\n    }\n\n    function updateFee(uint256 _fee) public onlyOwner {\n        fee = _fee;\n    }\n\n    function updateLinkAddress(address _linkAddress) public onlyOwner {\n        setChainlinkToken(_linkAddress);\n        // linkAddress = _linkAddress;\n    }\n\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) internal override {\n        Chainlink.Request memory req = buildOperatorRequest(\n            navyAttackJobId,\n            this.completeNavalAttack.selector\n        );\n        uint256 requestNumber = s_requestIdToRequestIndex[requestId];\n        console.log(requestNumber, \"requestNumber\");\n        req.addUint(\"battleId\", requestNumber);\n        s_requestIndexToRandomWords[requestNumber] = randomWords;\n        s_randomWords = randomWords;\n        req.addBytes(\"randomWords\", abi.encode(randomWords));\n        // uint256 numberBetweenZeroAndTwo = (s_randomWords[0] % 2);\n        // uint256 losses = getLosses(requestNumber, numberBetweenZeroAndTwo);\n        // console.log(\"losses\", losses);\n        // req.addUint(\"losses\", losses);\n        uint256[] memory attackerChances = battleIdToAttackerChanceArray[\n            requestNumber\n        ];\n        uint256[] memory attackerTypes = battleIdToAttackerTypeArray[\n            requestNumber\n        ];\n        uint256[] memory defenderChances = battleIdToDefenderChanceArray[\n            requestNumber\n        ];\n        uint256[] memory defenderTypes = battleIdToDefenderTypeArray[\n            requestNumber\n        ];\n        req.addBytes(\"attackerChances\", abi.encode(attackerChances));\n        req.addBytes(\"attackerTypes\", abi.encode(attackerTypes));\n        req.addBytes(\"defenderChances\", abi.encode(defenderChances));\n        req.addBytes(\"defenderTypes\", abi.encode(defenderTypes));\n        sendOperatorRequest(req, fee);\n        console.log(\"request sent\");\n        // uint256 attackerStartingStrength = idToAttackerNavy[requestNumber]\n        //     .startingStrength;\n        // console.log(\"attack strength\", attackerStartingStrength);\n        // uint256 defenderStartingStrength = idToDefenderNavy[requestNumber]\n        //     .startingStrength;\n        // console.log(\"def strength\", defenderStartingStrength);\n        // uint256 totalStrength = (attackerStartingStrength +\n        //     defenderStartingStrength);\n        // console.log(\"total strength\", totalStrength);\n        // console.log(\"arrived to for loop\");\n    }\n\n    event NavalAttackComplete(\n        uint256[] attackerLosses,\n        uint256[] defenderLosses,\n        uint256 battleId\n    );\n\n    function completeNavalAttack(\n        bytes32 requestId,\n        uint256[] memory _attackerLosses,\n        uint256[] memory _defenderLosses,\n        uint256 battleId\n    ) public {\n        console.log(_defenderLosses[0]);\n        console.log(_defenderLosses[1]);\n        console.log(_defenderLosses[2]);\n        console.log(battleId);\n\n        emit NavalAttackComplete(_attackerLosses, _defenderLosses, battleId);\n\n        // for (uint256 i = 0; i <= losses + 1; i++) {\n        //     console.log(\"loop\", i);\n        //     uint256 randomNumberForTeamSelection = (s_randomWords[i] %\n        //         totalStrength);\n        //     uint256 randomNumnerForShipSelection = s_randomWords[i + 8];\n        //     if (randomNumberForTeamSelection <= attackerStartingStrength) {\n        //         console.log(\"defender loss\");\n        //         generateLossForDefender(\n        //             requestNumber,\n        //             randomNumnerForShipSelection\n        //         );\n        //     } else {\n        //         console.log(\"attacker loss\");\n        //         generateLossForAttacker(\n        //             requestNumber,\n        //             randomNumnerForShipSelection\n        //         );\n        //     }\n        // }\n        // uint256[] memory defenderLosses = battleIdToDefenderLosses[\n        //     requestNumber\n        // ];\n        // uint256[] memory attackerLosses = battleIdToAttackerLosses[\n        //     requestNumber\n        // ];\n        // uint256 defenderId = idToDefenderNavy[requestNumber].countryId;\n        // uint256 attackerId = idToAttackerNavy[requestNumber].countryId;\n        // nav.decrementLosses(\n        //     defenderLosses,\n        //     defenderId,\n        //     attackerLosses,\n        //     attackerId\n        // );\n        // console.log(\"losses decremented\");\n        // uint256 warId = idToAttackerNavy[requestNumber].warId;\n        // war.addNavyCasualties(warId, defenderId, defenderLosses.length);\n        // war.addNavyCasualties(warId, attackerId, attackerLosses.length);\n        // navBlock.checkIfBlockadeCapable(defenderId);\n        // console.log(\"naval attack complete\");\n    }\n\n    function getLosses(\n        uint256 battleId,\n        uint256 numberBetweenZeroAndTwo\n    ) public view returns (uint256) {\n        uint256 attackerId = idToAttackerNavy[battleId].countryId;\n        uint256 attackerCount = getShipCount(attackerId);\n        uint256 defenderId = idToDefenderNavy[battleId].countryId;\n        uint256 defenderCount = getShipCount(defenderId);\n        uint256 totalShips = (attackerCount + defenderCount);\n        uint256 losses;\n        if (totalShips < 4) {\n            losses = 1;\n        } else if (totalShips <= 10) {\n            losses = (1 + numberBetweenZeroAndTwo);\n        } else if (totalShips <= 30) {\n            losses = (2 + numberBetweenZeroAndTwo);\n        } else if (totalShips <= 50) {\n            losses = (3 + numberBetweenZeroAndTwo);\n        } else if (totalShips <= 70) {\n            losses = (4 + numberBetweenZeroAndTwo);\n        } else if (totalShips <= 100) {\n            losses = (5 + numberBetweenZeroAndTwo);\n        } else {\n            losses = (6 + numberBetweenZeroAndTwo);\n        }\n        return losses;\n    }\n\n    function getShipCount(uint256 countryId) internal view returns (uint256) {\n        uint256 corvetteCount = nav.getCorvetteCount(countryId);\n        uint256 landingShipCount = nav.getLandingShipCount(countryId);\n        uint256 battleshipCount = nav.getBattleshipCount(countryId);\n        uint256 cruiserCount = nav.getCruiserCount(countryId);\n        uint256 frigateCount = nav2.getFrigateCount(countryId);\n        uint256 destroyerCount = nav2.getDestroyerCount(countryId);\n        uint256 submarineCount = nav2.getSubmarineCount(countryId);\n        uint256 aircraftCarrierCount = nav2.getAircraftCarrierCount(countryId);\n        uint256 count = (corvetteCount +\n            landingShipCount +\n            battleshipCount +\n            cruiserCount +\n            frigateCount +\n            destroyerCount +\n            submarineCount +\n            aircraftCarrierCount);\n        return count;\n    }\n\n    // function generateLossForDefender(\n    //     uint256 battleId,\n    //     uint256 randomNumberForShipLoss\n    // ) public {\n    //     uint256[] storage chanceArray = battleIdToDefenderChanceArray[battleId];\n    //     uint256[] storage typeArray = battleIdToDefenderTypeArray[battleId];\n    //     uint256 cumulativeValue = battleIdToDefenderCumulativeSumOdds[battleId];\n    //     uint256 randomNumber = (randomNumberForShipLoss % cumulativeValue);\n    //     uint256 shipType;\n    //     uint256 amountToDecrease;\n    //     uint256 j;\n    //     for (uint256 i; i < chanceArray.length; i++) {\n    //         if (randomNumber <= chanceArray[i]) {\n    //             shipType = typeArray[i];\n    //             amountToDecrease = getAmountToDecrease(shipType);\n    //             j = i;\n    //             break;\n    //         }\n    //     }\n    //     for (j; j < chanceArray.length; j++) {\n    //         if (chanceArray[j] >= randomNumber) {\n    //             chanceArray[j] -= amountToDecrease;\n    //         }\n    //     }\n    //     battleIdToDefenderCumulativeSumOdds[battleId] -= amountToDecrease;\n    //     uint256[] storage defenderLosses = battleIdToDefenderLosses[battleId];\n    //     defenderLosses.push(shipType);\n    // }\n\n    // function generateLossForAttacker(\n    //     uint256 battleId,\n    //     uint256 randomNumberForShipLoss\n    // ) public {\n    //     uint256[] storage chanceArray = battleIdToAttackerChanceArray[battleId];\n    //     uint256[] storage typeArray = battleIdToAttackerTypeArray[battleId];\n    //     uint256 cumulativeValue = battleIdToAttackerCumulativeSumOdds[battleId];\n    //     uint256 randomNumber = (randomNumberForShipLoss % cumulativeValue);\n    //     uint256 shipType;\n    //     uint256 amountToDecrease;\n    //     bool ranAlready = false;\n    //     if (ranAlready == false) {\n    //         for (uint256 i; i < chanceArray.length; i++) {\n    //             if (randomNumber <= chanceArray[i]) {\n    //                 shipType = typeArray[i];\n    //                 amountToDecrease = getAmountToDecrease(shipType);\n    //             }\n    //             uint256 j = i;\n    //             for (j; j < chanceArray.length; j++) {\n    //                 if (chanceArray[j] >= randomNumber) {\n    //                     chanceArray[j] -= amountToDecrease;\n    //                 }\n    //                 ranAlready = true;\n    //             }\n    //         }\n    //     }\n    //     battleIdToAttackerCumulativeSumOdds[battleId] -= amountToDecrease;\n    //     uint256[] storage defenderLosses = battleIdToAttackerLosses[battleId];\n    //     defenderLosses.push(shipType);\n    // }\n\n    // function getAmountToDecrease(\n    //     uint256 shipType\n    // ) internal pure returns (uint256) {\n    //     uint256 amountToDecrease;\n    //     if (shipType == 1) {\n    //         amountToDecrease = 15;\n    //     } else if (shipType == 2) {\n    //         amountToDecrease = 13;\n    //     } else if (shipType == 3) {\n    //         amountToDecrease = 11;\n    //     } else if (shipType == 4) {\n    //         amountToDecrease = 10;\n    //     } else if (shipType == 5) {\n    //         amountToDecrease = 8;\n    //     } else if (shipType == 6) {\n    //         amountToDecrease = 5;\n    //     } else if (shipType == 7) {\n    //         amountToDecrease = 4;\n    //     } else if (shipType == 8) {\n    //         amountToDecrease = 1;\n    //     }\n    //     return amountToDecrease;\n    // }\n}\n"
    },
    "contracts/Nuke.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./CountryMinter.sol\";\nimport \"./War.sol\";\nimport \"./Wonders.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Forces.sol\";\nimport \"./Navy.sol\";\nimport \"./Improvements.sol\";\nimport \"./KeeperFile.sol\";\nimport \"./CountryParameters.sol\";\nimport \"./Missiles.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport \"hardhat/console.sol\";\n\n///@title NukeContract\n///@author OxSnosh\n///@dev this contract inherits from chainlink VRF\n///@dev this contract inherits from openzeppelin ownable\n///@notice this contract will allow a nation to launch a nuclear missile at anoter nation\ncontract NukeContract is Ownable, VRFConsumerBaseV2 {\n    uint256 nukeAttackId;\n    address countryMinter;\n    address warAddress;\n    address wonders1;\n    address wonders4;\n    address improvements3;\n    address improvements4;\n    address infrastructure;\n    address forces;\n    address navy;\n    address missiles;\n    address keeper;\n    address parameters;\n    uint256 mod = 50;\n\n    //Chainlik Variables\n    uint256[] private s_randomWords;\n    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;\n    uint64 private immutable i_subscriptionId;\n    bytes32 private immutable i_gasLane;\n    uint32 private immutable i_callbackGasLimit;\n    uint16 private constant REQUEST_CONFIRMATIONS = 3;\n    uint32 private constant NUM_WORDS = 1;\n\n    CountryMinter mint;\n    WarContract war;\n    WondersContract1 won1;\n    WondersContract4 won4;\n    ImprovementsContract3 imp3;\n    ImprovementsContract4 imp4;\n    InfrastructureContract inf;\n    ForcesContract force;\n    NavyContract nav;\n    MissilesContract mis;\n    CountryParametersContract param;\n    KeeperContract keep;\n\n    struct NukeAttack {\n        uint256 warId;\n        uint256 attackerId;\n        uint256 defenderId;\n        uint256 attackType;\n    }\n\n    mapping(uint256 => NukeAttack) nukeAttackIdToNukeAttack;\n    mapping(uint256 => uint256) s_requestIdToRequestIndex;\n    mapping(uint256 => uint256[]) public s_requestIndexToRandomWords;\n    mapping(uint256 => uint256) public gameDayToNukesLanded;\n    mapping(uint256 => mapping(uint256 => bool))\n        public nationIdToDayToNukeLanded;\n\n    event NukeLaunched(\n        uint256 indexed id,\n        uint256 indexed attackerId,\n        uint256 indexed defenderId,\n        uint256 warId,\n        uint256 attackType\n    );\n\n    event NukeAttackEvent(\n        uint256 indexed id,\n        uint256 indexed attackerId,\n        uint256 indexed defenderId,\n        uint256 warId,\n        bool landed\n    );\n\n    ///@dev this function contains the variable necessary for chainlink randomness\n    constructor(\n        address vrfCoordinatorV2,\n        uint64 subscriptionId,\n        bytes32 gasLane, // keyHash\n        uint32 callbackGasLimit\n    ) VRFConsumerBaseV2(vrfCoordinatorV2) {\n        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2);\n        i_gasLane = gasLane;\n        i_subscriptionId = subscriptionId;\n        i_callbackGasLimit = callbackGasLimit;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _countryMinter,\n        address _warAddress,\n        address _wonders1,\n        address _wonders4,\n        address _improvements3,\n        address _improvements4,\n        address _infrastructure,\n        address _forces,\n        address _navy,\n        address _missiles,\n        address _keeper\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        warAddress = _warAddress;\n        war = WarContract(_warAddress);\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        wonders4 = _wonders4;\n        won4 = WondersContract4(_wonders4);\n        improvements3 = _improvements3;\n        imp3 = ImprovementsContract3(_improvements3);\n        improvements4 = _improvements4;\n        imp4 = ImprovementsContract4(_improvements4);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        forces = _forces;\n        force = ForcesContract(_forces);\n        navy = _navy;\n        nav = NavyContract(_navy);\n        missiles = _missiles;\n        mis = MissilesContract(_missiles);\n        keeper = _keeper;\n        keep = KeeperContract(_keeper);\n    }\n\n    function settings2(address _parameters) public onlyOwner {\n        parameters = _parameters;\n        param = CountryParametersContract(_parameters);\n    }\n\n    ///@dev this is a public function callable only by the attacking nation owner\n    ///@dev this function will launch a nuke strike against another nation, nations are required to be at war\n    ///@notice this function will launch a nuke strike against another nation, nations are required to be at war\n    ///@notice a nuke cannot be launched until a war is one day old\n    ///@param attackType determines if the attack is a standard attack or an attack targeting infrastructure, land or technology\n    ///@notice attack type will be 1 for a standard attack, 2 for an infrastructre attack, 3 for a land attack and 4 for a technology attack\n    ///@notice if an attacking nation does not have a emp wonder, than the attack type will need to be a standard attack\n    ///@param warId will be the war id of the active war between the 2 nations\n    ///@param attackerId will be the id of the attacking nation (launching the nuke)\n    ///@param defenderId will be the id of the defending nation\n    function launchNuke(\n        uint256 warId,\n        uint256 attackerId,\n        uint256 defenderId,\n        uint256 attackType\n    ) public {\n        bool isOwner = mint.checkOwnership(attackerId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        bool isActive = war.isWarActive(warId);\n        require(isActive, \"war not active\");\n        (uint256 offenseId, uint256 defenseId) = war.getInvolvedParties(warId);\n        require(\n            attackerId == offenseId || attackerId == defenseId,\n            \"attacker not involved in this war\"\n        );\n        require(\n            defenderId == offenseId || defenderId == defenseId,\n            \"defender not involved in this war\"\n        );\n        (uint256 daysLeft, ) = war.getDaysLeft(warId);\n        require(daysLeft < 6, \"not at war long enough to launch a nuke\");\n        uint256 count = mis.getNukeCount(attackerId);\n        require(count >= 1, \"need to own a nuke\");\n        uint256 day = keep.getGameDay();\n        require(\n            nationIdToDayToNukeLanded[defenderId][day] == false,\n            \"defender already nuked this day\"\n        );\n        completeNukeLaunch(warId, attackerId, defenderId, attackType);\n    }\n\n    function completeNukeLaunch(\n        uint256 warId,\n        uint256 attackerId,\n        uint256 defenderId,\n        uint256 attackType\n    ) internal {\n        bool emp = won1.getEmpWeaponization(attackerId);\n        if (!emp) {\n            require(\n                attackType == 1,\n                \"can only launch a standard attack without emp\"\n            );\n        } else {\n            require(attackType <= 4, \"invalid attack type\");\n        }\n        uint256 tech = inf.getTechnologyCount(attackerId);\n        if (attackType == 2 || attackType == 3 || attackType == 4) {\n            require(\n                tech >= 5000,\n                \"emp attacks require a nation to have 5,000 tech\"\n            );\n        }\n        NukeAttack memory newAttack = NukeAttack(\n            warId,\n            attackerId,\n            defenderId,\n            attackType\n        );\n        nukeAttackIdToNukeAttack[nukeAttackId] = newAttack;\n        war.cancelPeaceOffersUponAttack(warId);\n        fulfillRequest(nukeAttackId);\n        emit NukeLaunched(\n            nukeAttackId,\n            attackerId,\n            defenderId,\n            warId,\n            attackType\n        );\n        nukeAttackId++;\n    }\n\n    ///@dev this function will be called by the launchNuke() function\n    ///@dev this function will send a randomness request to the chainlink VRF contract\n    function fulfillRequest(uint256 id) internal {\n        uint256 requestId = i_vrfCoordinator.requestRandomWords(\n            i_gasLane,\n            i_subscriptionId,\n            REQUEST_CONFIRMATIONS,\n            i_callbackGasLimit,\n            NUM_WORDS\n        );\n        s_requestIdToRequestIndex[requestId] = id;\n    }\n\n    ///@dev this function will be called by the chainlink VRF contract in response to a randomness request\n    ///@dev the random numbers will be used to determine if the nuke strike was a success or not\n    ///@notice a nations default odds of a successful nuke strike are 50%\n    ///@notice if a defender has a strategic defense initiative the odds of a successful strike go down 20%\n    ///@notice if the attacker has sattelites, the odds of a succesful strike go up 5% per sattelite\n    ///@notice if a defender has a missile defense, the odds of a sucessful strike go down 5% per missile defense\n    ///@param requestId will be the request id passed in from the fulfillRequest() function\n    ///@param randomWords is the randomly generate number for the calculation of a successful nuke strike\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) internal override {\n        console.log(\"request ID from fullfill\", requestId);\n        uint256 requestNumber = s_requestIdToRequestIndex[requestId];\n        console.log(\"requestNumber\", requestNumber);\n        s_requestIndexToRandomWords[requestNumber] = randomWords;\n        s_randomWords = randomWords;\n        uint256 attackerId = nukeAttackIdToNukeAttack[requestNumber].attackerId;\n        uint256 defenderId = nukeAttackIdToNukeAttack[requestNumber].defenderId;\n        console.log(\"attackerId\", attackerId);\n        console.log(\"defenderId\", defenderId);\n        uint256 thwartOdds = getThwartOdds(attackerId, defenderId);\n        console.log(\"thwartOdds\", thwartOdds);\n        uint256 randomNukeSuccessNumber = ((s_randomWords[0] % 100) + 1);\n        console.log(\"randomNukeSuccessNumber\", randomNukeSuccessNumber);\n        if (randomNukeSuccessNumber > thwartOdds) {\n            console.log(\"Nuke attaq success\");\n            inflictNukeDamage(requestNumber);\n            mis.decreaseNukeCountFromNukeContract(attackerId);\n            param.inflictAnarchy(defenderId);\n            uint256 gameDay = keep.getGameDay();\n            gameDayToNukesLanded[gameDay]++;\n            emit NukeAttackEvent(\n                requestNumber,\n                attackerId,\n                defenderId,\n                nukeAttackIdToNukeAttack[requestNumber].warId,\n                true\n            );\n            uint256 day = keep.getGameDay();\n            nationIdToDayToNukeLanded[defenderId][day] = true;\n            console.log(\"did this run?\", nationIdToDayToNukeLanded[defenderId][day]);\n            console.log(defenderId, day);\n        } else {\n            console.log(\"Nuke attaq thwarted\");\n            mis.decreaseNukeCountFromNukeContract(attackerId);\n            emit NukeAttackEvent(\n                requestNumber,\n                attackerId,\n                defenderId,\n                nukeAttackIdToNukeAttack[requestNumber].warId,\n                false\n            );\n        }\n    }\n\n    function getThwartOdds(\n        uint256 attackerId,\n        uint256 defenderId\n    ) public view returns (uint256) {\n        uint256 thwartOdds = 50;\n        bool strategicDefenseInitiative = won4.getStrategicDefenseInitiative(\n            defenderId\n        );\n        uint256 defenderMissileDefenses = imp4.getMissileDefenseCount(\n            defenderId\n        );\n        uint256 attackerSattelites = imp3.getSatelliteCount(attackerId);\n        if (strategicDefenseInitiative) {\n            thwartOdds += 20;\n        }\n        if (defenderMissileDefenses > 0) {\n            thwartOdds += (defenderMissileDefenses * 5);\n        }\n        if (attackerSattelites > 0) {\n            thwartOdds -= (attackerSattelites * 5);\n        }\n        return thwartOdds;\n    }\n\n    ///@dev this is an internal function that will be called in the event of a succesful nuke strike\n    ///@notice this function will take the attack tyoe and direct the type of damage to inflict\n    ///@param attackId this is the type of attack that was launched that will determine if the attack was a standard attack or an infrastructure, land or tech attack\n    function inflictNukeDamage(uint256 attackId) internal {\n        uint256 attackType = nukeAttackIdToNukeAttack[attackId].attackType;\n        if (attackType == 1) {\n            standardAttack(attackId);\n        } else if (attackType == 2) {\n            infrastructureAttack(attackId);\n        } else if (attackType == 3) {\n            landAttack(attackId);\n        } else if (attackType == 4) {\n            technologyAttack(attackId);\n        }\n    }\n\n    ///@dev this is the function that will be called in the event of a standard attack\n    ///@notice a standard nuke attack will decrease land, infrastructure and tech by 35%\n    function standardAttack(uint256 attackId) internal {\n        uint256 defenderId = nukeAttackIdToNukeAttack[attackId].defenderId;\n        uint256 attackerId = nukeAttackIdToNukeAttack[attackId].attackerId;\n        force.decreaseDefendingSoldierCountFromNukeAttack(defenderId);\n        force.decreaseDefendingTankCountFromNukeContract(defenderId);\n        nav.decreaseNavyFromNukeContract(defenderId);\n        inf.decreaseLandCountFromNukeContract(defenderId, 35, 1);\n        inf.decreaseInfrastructureCountFromNukeContract(\n            defenderId,\n            attackerId,\n            35,\n            1\n        );\n        inf.decreaseTechCountFromNukeContract(defenderId, 35, 1);\n        mis.decreaseCruiseMissileCountFromNukeContract(defenderId);\n    }\n\n    ///@dev this is the function that will be called in the event of a infrastructure attack\n    ///@notice an infrastructure nuke attack will decrease infrastructure by 45% and land and tech by 25%\n    function infrastructureAttack(uint256 attackId) internal {\n        uint256 defenderId = nukeAttackIdToNukeAttack[attackId].defenderId;\n        uint256 attackerId = nukeAttackIdToNukeAttack[attackId].attackerId;\n        force.decreaseDefendingSoldierCountFromNukeAttack(defenderId);\n        force.decreaseDefendingTankCountFromNukeContract(defenderId);\n        nav.decreaseNavyFromNukeContract(defenderId);\n        inf.decreaseLandCountFromNukeContract(defenderId, 25, 2);\n        inf.decreaseInfrastructureCountFromNukeContract(\n            defenderId,\n            attackerId,\n            45,\n            2\n        );\n        inf.decreaseTechCountFromNukeContract(defenderId, 25, 2);\n        mis.decreaseCruiseMissileCountFromNukeContract(defenderId);\n    }\n\n    ///@dev this is the function that will be called in the event of a land attack\n    ///@notice a land nuke attack will decrease land by 45% and infrastructe and tech by 25%\n    function landAttack(uint256 attackId) internal {\n        uint256 defenderId = nukeAttackIdToNukeAttack[attackId].defenderId;\n        uint256 attackerId = nukeAttackIdToNukeAttack[attackId].attackerId;\n        force.decreaseDefendingSoldierCountFromNukeAttack(defenderId);\n        force.decreaseDefendingTankCountFromNukeContract(defenderId);\n        nav.decreaseNavyFromNukeContract(defenderId);\n        inf.decreaseLandCountFromNukeContract(defenderId, 45, 3);\n        inf.decreaseInfrastructureCountFromNukeContract(\n            defenderId,\n            attackerId,\n            25,\n            3\n        );\n        inf.decreaseTechCountFromNukeContract(defenderId, 25, 3);\n        mis.decreaseCruiseMissileCountFromNukeContract(defenderId);\n    }\n\n    ///@dev this is the function that will be called in the event of a tech attack\n    ///@notice a tech nuke attack will decrease tech by 45% and infrastructe and land by 25%\n    function technologyAttack(uint256 attackId) internal {\n        uint256 defenderId = nukeAttackIdToNukeAttack[attackId].defenderId;\n        uint256 attackerId = nukeAttackIdToNukeAttack[attackId].attackerId;\n        force.decreaseDefendingSoldierCountFromNukeAttack(defenderId);\n        force.decreaseDefendingTankCountFromNukeContract(defenderId);\n        nav.decreaseNavyFromNukeContract(defenderId);\n        inf.decreaseLandCountFromNukeContract(defenderId, 25, 4);\n        inf.decreaseInfrastructureCountFromNukeContract(\n            defenderId,\n            attackerId,\n            25,\n            4\n        );\n        inf.decreaseTechCountFromNukeContract(defenderId, 45, 4);\n        mis.decreaseCruiseMissileCountFromNukeContract(defenderId);\n    }\n\n    ///@dev this function is a public view function that will return the number of nukes launched in the game in the last 7 days\n    ///@dev this function will be used to calculate global radiation levels (next function)\n    function calculateNukesLandedLastSevenDays() public view returns (uint256) {\n        uint256 sum = 0;\n        uint256 gameDay = keep.getGameDay();\n        uint256 daysToIterate;\n        if (gameDay < 7) {\n            daysToIterate = gameDay;\n        } else {\n            daysToIterate = 7;\n        }\n        for (uint256 i = 0; i < daysToIterate; i++) {\n            sum += gameDayToNukesLanded[gameDay - i];\n        }\n        return sum;\n    }\n\n    ///@dev this is a public view function that will return the global radiation levels that will be used in a nations environment calculation\n    ///@notice this function will return the global radiation levels for the game\n    ///@notice global radiation is calulates by miltiplying nukes landed in the last 7 days by a modifier (default 300) and dividing by the number of countries\n    ///@return uint256 is the global radiation level\n    function getGlobalRadiation() public view returns (uint256) {\n        uint256 countries = mint.getCountryCount();\n        if (countries == 0) {\n            countries = 1;\n        }\n        uint256 nukesLanded = calculateNukesLandedLastSevenDays();\n        uint256 globalRadiation = ((nukesLanded * mod) / countries);\n        return globalRadiation;\n    }\n\n    ///@dev this is a function callable by the owner of the contract that will allow the caller to update the modifier for the global radiation level\n    ///@notice this function will allow the owner of the contract to adjust the modifier for the global radiation level\n    ///@param newModifier is the new modifier for the global radiation level\n    function updateGlobalRadiationModifier(\n        uint256 newModifier\n    ) public onlyOwner {\n        mod = newModifier;\n    }\n}\n"
    },
    "contracts/Resources.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./Infrastructure.sol\";\nimport \"./Improvements.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./CountryParameters.sol\";\nimport \"./Senate.sol\";\nimport \"./Crime.sol\";\nimport \"hardhat/console.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n///@title ResourcesContract\n///@author OxSnosh\n///@notice this contract will keep track of a nations resources and trades\n///@dev this contract inherits from chainlink VRF\n///@dev this contract inherits from oepnzeppelin ownable\ncontract ResourcesContract is VRFConsumerBaseV2, Ownable {\n    uint256 public resourcesLength = 21;\n    uint256[] private s_randomWords;\n    uint256[] public tradingPartners;\n    uint256[] public proposedTrades;\n    uint256[] public trades;\n    address public infrastructure;\n    address public improvements2;\n    address public countryMinter;\n    address public bonusResources;\n    address public senate;\n    address public parameters;\n    address public techMkt;\n\n    CountryMinter mint;\n    BonusResourcesContract bonus;\n    CountryParametersContract params;\n    SenateContract sen;\n\n    //Chainlik Variables\n    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;\n    uint64 private immutable i_subscriptionId;\n    bytes32 private immutable i_gasLane;\n    uint32 private immutable i_callbackGasLimit;\n    uint16 private constant REQUEST_CONFIRMATIONS = 3;\n    uint32 private constant NUM_WORDS = 2;\n\n    struct Resources1 {\n        bool aluminium;\n        //Aluminum\n        //DONE //Increases soldier efficiency +20%,\n        //DONE //lowers infrastructure purchase cost -7%, and\n        //DONE //lowers aircraft purchase costs -8%.\n        bool cattle;\n        //Cattle\n        //DONE //Increases number of citizens +5%\n        //DONE //and lowers land purchase cost -10%.\n        bool coal;\n        //Coal\n        //DONE //Increases the purchased land area of a nation by 15%,\n        //DONE //increases soldier efficiency +8%,\n        //DONE //and lowers infrastructure purchase cost -4%.\n        bool fish;\n        //Fish\n        //DONE //Increases number of citizens +8%\n        //DOME //and lowers land purchase cost -5%.\n        bool furs;\n        //Furs\n        //DONE //Increases citizen's daily income +$3.50\n        //and triples the natural growth of a nation.\n        bool gems;\n        //Gems\n        //DONE //Increases citizen's daily income +$1.50\n        //DONE //and increases population happiness +3.\n        bool gold;\n        //Gold\n        //DONE //Increases citizen's daily income +$3.00\n        //DONE //and lowers technology cost by 5%.\n        bool iron;\n        //Iron\n        //DONE //Lowers soldier purchase cost -$3.00,\n        //DONE //lowers infrastructure upkeep costs -10%,\n        //DONE //lowers infrastructure purchase costs -5%,\n        //DONE //and lowers tank upkeep costs -5%.\n        bool lead;\n        //Lead\n        //DONE //Lowers cruise missile and nuclear weapon purchase cost and upkeep cost -20%,\n        //DONE //lowers aircraft upkeep cost -25%,\n        //lowers tank purchase and upkeep costs -8%,\n        //DONE //lowers soldier upkeep cost -15%,\n        //DONE //reduces environment penalties for owning nuclear weapons by 50%,\n        //DONE //and lowers all navy vessel upkeep cost -20%.\n        bool lumber;\n        //Lumber\n        //DONE //Lowers infrastructure purchase cost -6%\n        //DONE //and lowers infrastructure upkeep costs -8%.\n        bool marble;\n        //Marble\n        //DONE //Lowers infrastructure purchase cost -10%.\n    }\n\n    struct Resources2 {\n        bool oil;\n        //Oil\n        //DONE //Lowers soldier purchase cost -$3.00,\n        //DONE //increases population happiness +2,\n        //DONE //increases soldier efficiency +10%,\n        //DONE //lowers tank upkeep cost -5%,\n        //DONE //lowers aircraft purchase cost -4%,\n        //DONE //and lowers all navy vessel upkeep cost -10%.\n        //\n        bool pigs;\n        //Pigs\n        //DONE //Lowers soldier upkeep cost -$0.50,\n        //DONE //increases soldier efficiency +15%,\n        //DONE //and increases number of citizens +4%.\n        bool rubber;\n        //Rubber\n        //DONE //Increases purchased land area of a nation by 20%,\n        //DONE //lowers land purchase cost -10%,\n        //DONE //triples the value of land when selling (from $100 to $300),\n        //DONE //lowers infrastructure purchase cost -3%,\n        //DONE //and lowers aircraft purchase cost -4%.\n        bool silver;\n        //Silver\n        //DONE //Increases citizen's daily income +$2.00\n        //DONE //and increases population happiness +2.\n        bool spices;\n        //Spices\n        //DONE //Increases the purchased land area of a nation by 8%\n        //DONE //and increases population happiness +2.\n        bool sugar;\n        //Sugar\n        //DONE //Increases number of citizens +3%,\n        //DONE //and increases population happiness +1.\n        bool uranium;\n        //Uranium\n        //DONE //Reduces infrastructure upkeep cost -3%.\n        //DONE //Allow nations to develop nuclear weapons\n        //If a nations government preference favors nuclear technology for the use of nuclear\n        //power plants but does not support nuclear weapons then the nation will receive +$3.00\n        //per citizen and +$0.15 for every level of tech purchased up to level 30 but loses -1\n        //population happiness.\n        //DONE //If a nation owns nuclear weapons but does not have uranium the cost to maintain nukes\n        //is doubled.\n        //DONE //Lowers Submarine and Aircraft Carrier navy vessel purchase and upkeep cost -5%.\n        bool water;\n        //Water\n        //DONE //Increases number of citizens per mile before population unhappiness by 50,\n        //DONE //increases population happiness +3,\n        //DONE //and improves a nation's environment by 1.\n        bool wheat;\n        //Wheat\n        //DONE //Increases number of citizens +8%.\n        bool wine;\n        //Wine\n        //DONE //Increases population happiness +3.\n    }\n\n    mapping(uint256 => Resources1) public idToResources1;\n    mapping(uint256 => Resources2) public idToResources2;\n    mapping(uint256 => uint256[]) public idToPlayerResources;\n    mapping(uint256 => uint256[]) public idToRandomResourceSelection;\n    mapping(uint256 => uint256[]) public idToTradingPartners;\n    mapping(uint256 => uint256[]) public idToProposedTradingPartners;\n    mapping(uint256 => uint256) s_requestIdToRequestIndex;\n    mapping(uint256 => uint256[]) public s_requestIndexToRandomWords;\n\n    event TradeProposed(\n        uint256 indexed requestorId,\n        uint256 indexed recipientId\n    );\n    event TradeAccepted(\n        uint256 indexed requestorId,\n        uint256 indexed recipientId\n    );\n    event TradeProposalCancelled(\n        uint256 indexed requestorId,\n        uint256 indexed recipientId\n    );\n    event TradeCancelled(\n        uint256 indexed requestorId,\n        uint256 indexed recipientId\n    );\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"this function is only callable from the country minter contract\"\n        );\n        _;\n    }\n\n    ///@dev constructor function will accept variables for chainlink randomness\n    constructor(\n        address vrfCoordinatorV2,\n        uint64 subscriptionId,\n        bytes32 gasLane, // keyHash\n        uint32 callbackGasLimit\n    ) VRFConsumerBaseV2(vrfCoordinatorV2) {\n        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2);\n        i_gasLane = gasLane;\n        i_subscriptionId = subscriptionId;\n        i_callbackGasLimit = callbackGasLimit;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _infrastructure,\n        address _improvements2,\n        address _countryMinter,\n        address _bonusResources,\n        address _senate,\n        address _technologyMarket,\n        address _parameters\n    ) public onlyOwner {\n        infrastructure = _infrastructure;\n        improvements2 = _improvements2;\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        bonusResources = _bonusResources;\n        bonus = BonusResourcesContract(_bonusResources);\n        senate = _senate;\n        sen = SenateContract(_senate);\n        techMkt = _technologyMarket;\n        parameters = _parameters;\n        params = CountryParametersContract(_parameters);\n    }\n\n    ///@dev this is a public function that is only callable from the country minter contract when a nation is minted\n    ///@dev this function will allow a nation to store the resources they have access to\n    ///@notice this function will allow a nation to store the resources they have access to\n    ///@dev this function will call the chainlink vrf contract to assign the minted nation two resources randomly\n    ///@param id is the nation id of the nation being minted\n    function generateResources(uint256 id) public onlyCountryMinter {\n        Resources1 memory newResources1 = Resources1(\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false\n        );\n        Resources2 memory newResources2 = Resources2(\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false\n        );\n        idToResources1[id] = newResources1;\n        idToResources2[id] = newResources2;\n        fulfillRequest(id);  \n    }\n\n    ///@dev this is the function that will call the chainlink vrf contract to return random numbers\n    ///@dev this is an internal function that can only be called from within this contract\n    function fulfillRequest(uint256 id) internal {\n        uint256 requestId = i_vrfCoordinator.requestRandomWords(\n            i_gasLane,\n            i_subscriptionId,\n            REQUEST_CONFIRMATIONS,\n            i_callbackGasLimit,\n            NUM_WORDS\n        );\n        s_requestIdToRequestIndex[requestId] = id;\n    }\n\n    ///@dev this is the function that the chainlink vrf contract will call when it answers\n    ///@param requestId this is the id of the request sent to the vrf contract\n    ///@param randomWords is the random numbers being returned after being generated off chain\n    ///@dev this function will assign a nation 2 random resources and assure that they are 2 different resources\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) internal override {\n        uint256 requestNumber = s_requestIdToRequestIndex[requestId];\n        s_requestIndexToRandomWords[requestNumber] = randomWords;\n        s_randomWords = s_requestIndexToRandomWords[requestNumber];\n        uint256 randomResource1 = (s_randomWords[0] % 20);\n        uint256 randomResource2 = (s_randomWords[1] % 20);\n        if (randomResource1 == randomResource2 && randomResource2 == 20) {\n            randomResource2 = 0;\n        }\n        if (randomResource1 == randomResource2) {\n            randomResource2 = randomResource2 + 1;\n        }\n        uint256[2] memory playerResources = [randomResource1, randomResource2];\n        idToPlayerResources[requestNumber] = playerResources;\n        setResources(requestNumber);\n    }\n\n    ///@dev this is a function that is callable only from the owner of the contract\n    ///@dev this function was used in testing of the smart contract and should be deleted before deployment\n    function mockResourcesForTesting(\n        uint256 countryId,\n        uint256 resource1,\n        uint256 resource2\n    ) public onlyOwner {\n        uint256[2] memory playerResources = [resource1, resource2];\n        idToPlayerResources[countryId] = playerResources;\n        setResources(countryId);\n    }\n\n    ///@dev this function is an internal function that will be called when a nation is minted or adds or removes a trading partner\n    ///@dev this will set the nations assigned resources to true and call the next funtion that will set all the resources of its trading partners to true\n    ///@param id is the nation id of the nation whose resources ar ebeing reset after minting or adding/removing a trading partner\n    function setResources(uint256 id) internal {\n        idToResources1[id].aluminium = false;\n        idToResources1[id].cattle = false;\n        idToResources1[id].coal = false;\n        idToResources1[id].fish = false;\n        idToResources1[id].furs = false;\n        idToResources1[id].gems = false;\n        idToResources1[id].gold = false;\n        idToResources1[id].iron = false;\n        idToResources1[id].lead = false;\n        idToResources1[id].lumber = false;\n        idToResources1[id].marble = false;\n        idToResources2[id].oil = false;\n        idToResources2[id].pigs = false;\n        idToResources2[id].rubber = false;\n        idToResources2[id].silver = false;\n        idToResources2[id].spices = false;\n        idToResources2[id].sugar = false;\n        idToResources2[id].uranium = false;\n        idToResources2[id].water = false;\n        idToResources2[id].wheat = false;\n        idToResources2[id].wine = false;\n        uint256 resource1 = idToPlayerResources[id][0];\n        uint256 resource2 = idToPlayerResources[id][1];\n        if (resource1 == 0 || resource2 == 0) {\n            idToResources1[id].aluminium = true;\n        }\n        if (resource1 == 1 || resource2 == 1) {\n            idToResources1[id].cattle = true;\n        }\n        if (resource1 == 2 || resource2 == 2) {\n            idToResources1[id].coal = true;\n        }\n        if (resource1 == 3 || resource2 == 3) {\n            idToResources1[id].fish = true;\n        }\n        if (resource1 == 4 || resource2 == 4) {\n            idToResources1[id].furs = true;\n        }\n        if (resource1 == 5 || resource2 == 5) {\n            idToResources1[id].gems = true;\n        }\n        if (resource1 == 6 || resource2 == 6) {\n            idToResources1[id].gold = true;\n        }\n        if (resource1 == 7 || resource2 == 7) {\n            idToResources1[id].iron = true;\n        }\n        if (resource1 == 8 || resource2 == 8) {\n            idToResources1[id].lead = true;\n        }\n        if (resource1 == 9 || resource2 == 9) {\n            idToResources1[id].lumber = true;\n        }\n        if (resource1 == 10 || resource2 == 10) {\n            idToResources1[id].marble = true;\n        }\n        if (resource1 == 11 || resource2 == 11) {\n            idToResources2[id].oil = true;\n        }\n        if (resource1 == 12 || resource2 == 12) {\n            idToResources2[id].pigs = true;\n        }\n        if (resource1 == 13 || resource2 == 13) {\n            idToResources2[id].rubber = true;\n        }\n        if (resource1 == 14 || resource2 == 14) {\n            idToResources2[id].silver = true;\n        }\n        if (resource1 == 15 || resource2 == 15) {\n            idToResources2[id].spices = true;\n        }\n        if (resource1 == 16 || resource2 == 16) {\n            idToResources2[id].sugar = true;\n        }\n        if (resource1 == 17 || resource2 == 17) {\n            idToResources2[id].uranium = true;\n        }\n        if (resource1 == 18 || resource2 == 18) {\n            idToResources2[id].water = true;\n        }\n        if (resource1 == 19 || resource2 == 19) {\n            idToResources2[id].wheat = true;\n        }\n        if (resource1 == 20 || resource2 == 20) {\n            idToResources2[id].wine = true;\n        }\n        setTrades(id);\n    }\n\n    ///@dev this function is internal and can only be called by this contract\n    ///@dev this function will loop through a nations trading partners and set the resources partner nations to true\n    ///@param id is the nation id of the nation reseting their resources\n    ///@dev this function is called from the previous setResources() function\n    function setTrades(uint256 id) internal {\n        uint256[] memory activeTrades = idToTradingPartners[id];\n        uint256 i;\n        for (i = 0; i < activeTrades.length; i++) {\n            uint256 tradingPartner = activeTrades[i];\n            (\n                uint256 resource1,\n                uint256 resource2\n            ) = getResourcesFromTradingPartner(tradingPartner);\n            if (resource1 == 0 || resource2 == 0) {\n                idToResources1[id].aluminium = true;\n            }\n            if (resource1 == 1 || resource2 == 1) {\n                idToResources1[id].cattle = true;\n            }\n            if (resource1 == 2 || resource2 == 2) {\n                idToResources1[id].coal = true;\n            }\n            if (resource1 == 3 || resource2 == 3) {\n                idToResources1[id].fish = true;\n            }\n            if (resource1 == 4 || resource2 == 4) {\n                idToResources1[id].furs = true;\n            }\n            if (resource1 == 5 || resource2 == 5) {\n                idToResources1[id].gems = true;\n            }\n            if (resource1 == 6 || resource2 == 6) {\n                idToResources1[id].gold = true;\n            }\n            if (resource1 == 7 || resource2 == 7) {\n                idToResources1[id].iron = true;\n            }\n            if (resource1 == 8 || resource2 == 8) {\n                idToResources1[id].lead = true;\n            }\n            if (resource1 == 9 || resource2 == 9) {\n                idToResources1[id].lumber = true;\n            }\n            if (resource1 == 10 || resource2 == 10) {\n                idToResources1[id].marble = true;\n            }\n            if (resource1 == 11 || resource2 == 11) {\n                idToResources2[id].oil = true;\n            }\n            if (resource1 == 12 || resource2 == 12) {\n                idToResources2[id].pigs = true;\n            }\n            if (resource1 == 13 || resource2 == 13) {\n                idToResources2[id].rubber = true;\n            }\n            if (resource1 == 14 || resource2 == 14) {\n                idToResources2[id].silver = true;\n            }\n            if (resource1 == 15 || resource2 == 15) {\n                idToResources2[id].spices = true;\n            }\n            if (resource1 == 16 || resource2 == 16) {\n                idToResources2[id].sugar = true;\n            }\n            if (resource1 == 17 || resource2 == 17) {\n                idToResources2[id].uranium = true;\n            }\n            if (resource1 == 18 || resource2 == 18) {\n                idToResources2[id].water = true;\n            }\n            if (resource1 == 19 || resource2 == 19) {\n                idToResources2[id].wheat = true;\n            }\n            if (resource1 == 20 || resource2 == 20) {\n                idToResources2[id].wine = true;\n            }\n        }\n        bonus.setBonusResources(id);\n    }\n\n    ///@dev this is a public function that can be called by any nation owner\n    ///@dev this function allows a nation owner to propose a trade with another nation\n    ///@notice this function allows a nation owner to propose a trade with another nation\n    ///@param requestorId is the nation id of the nation requesting the trading partnership\n    ///@param recipientId is the nation id of the nation receiving the trade proposal\n    ///@notice once proposed the recipient nation will need to accept the trade\n    ///@notice a requesting nation can only have 3 trades active in order to propose a trade (4 with a harbor)\n    ///@notice a recipient nation can only have 4 trades active to accept a trade (5 with a harbor)\n    function proposeTrade(uint256 requestorId, uint256 recipientId) public {\n        bool isOwner = mint.checkOwnership(requestorId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        bool isPossibleRequestor = isTradePossibleForRequestor(requestorId);\n        bool isPossibleRecipient = isTradePossibleForRecipient(recipientId);\n        require(isPossibleRequestor == true, \"trade is not possible\");\n        require(isPossibleRecipient == true, \"trade is not possible\");\n        bool sanctioned = sen.isSanctioned(requestorId, recipientId);\n        require(sanctioned == false, \"trade is sanctioned\");\n        idToProposedTradingPartners[recipientId].push(requestorId);\n        idToProposedTradingPartners[requestorId].push(recipientId);\n        emit TradeProposed(requestorId, recipientId);\n    }\n\n    ///@dev this is a public function but is only callable from the nation owner\n    ///@notice this function will allow a nation owner to cancel a proposed trande\n    ///@param nationId this is the nation Id of the nation owner looking to cancel a proposed trade\n    ///@param partnerId this is the nation Id of the proposed trading partner that is getting the proposed trade cancelled\n    ///@dev this function will revert if the partnerId parameter is not a current proposed trade\n    function cancelProposedTrade(uint256 nationId, uint256 partnerId) public {\n        bool isOwner = mint.checkOwnership(nationId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256[] storage nationProposedTrades = idToProposedTradingPartners[\n            nationId\n        ];\n        uint256[] storage partnerProposedTrades = idToProposedTradingPartners[\n            partnerId\n        ];\n        for (uint i = 0; i <= nationProposedTrades.length; i++) {\n            if (nationProposedTrades[i] == partnerId) {\n                nationProposedTrades[i] = nationProposedTrades[\n                    nationProposedTrades.length - 1\n                ];\n                nationProposedTrades.pop();\n                for (uint j = 0; j <= partnerProposedTrades.length; j++) {\n                    if (partnerProposedTrades[j] == nationId) {\n                        partnerProposedTrades[j] = partnerProposedTrades[\n                            partnerProposedTrades.length - 1\n                        ];\n                        partnerProposedTrades.pop();\n                    }\n                }\n            } else {\n                revert(\"No proposed trade with this partner\");\n            }\n        }\n        emit TradeProposalCancelled(nationId, partnerId);\n    }\n\n    ///@dev this is a public view function that will return a nations proposed trading partners\n    ///@notice this function will return a nation's proposed trading partners\n    ///@return uint256 is an array of the nation id's of a nations proposed trading partners\n    ///@param id is the nation id of the nation being queried\n    function getProposedTradingPartners(\n        uint256 id\n    ) public view returns (uint256[] memory) {\n        return idToProposedTradingPartners[id];\n    }\n\n    ///@dev a trade proposal will only go through if a proposal is possible for the requestor and recipient\n    ///@dev this function is an internal function that will return a boolean true if the proposed trade is possible for the requestor\n    ///@notice this function will return true if the trade is possible for the requestor\n    ///@notice a requestor can have a maximum of 3 active and proposed trades (4 with a harbor) in order to propose a trade\n    ///@return bool is true if the trade is possible for the requestor\n    function isTradePossibleForRequestor(\n        uint256 requestorId\n    ) internal view returns (bool) {\n        uint256[] memory requestorTradeAgreements = idToTradingPartners[\n            requestorId\n        ];\n        uint256[]\n            memory proposedTradesOfRequestor = idToProposedTradingPartners[\n                requestorId\n            ];\n        uint256 requestorTradesActive = requestorTradeAgreements.length;\n        uint256 requestorProposedTrades = proposedTradesOfRequestor.length;\n        uint256 requestorTotalTrades = requestorTradesActive +\n            requestorProposedTrades;\n        uint256 requestorHarborAmount = ImprovementsContract2(improvements2)\n            .getHarborCount(requestorId);\n        uint256 requestorMaxTrades = 3;\n        if (requestorHarborAmount > 0) {\n            requestorMaxTrades = 4;\n        }\n        if (requestorMaxTrades >= (requestorTotalTrades + 1)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    ///@dev a trade proposal will only go through if a proposal is possible for the requestor and recipient\n    ///@dev this function is an internal function that will return a boolean true if the proposed trade is possible for the recipient\n    ///@notice this function will return true if the trade is possible for the recipient\n    ///@notice a recipient can have a maximum of 4 active and proposed trades (5 with a harbor) in order to have a trade proposed\n    ///@return bool is true if the trade is possible for the recipient\n    function isTradePossibleForRecipient(\n        uint256 recipientId\n    ) internal view returns (bool) {\n        uint256[] memory recipientTradeAgreements = idToTradingPartners[\n            recipientId\n        ];\n        uint256[]\n            memory proposedTradesOfRecipient = idToProposedTradingPartners[\n                recipientId\n            ];\n        uint256 recipientTradesActive = recipientTradeAgreements.length;\n        uint256 recipientProposedTrades = proposedTradesOfRecipient.length;\n        uint256 recipientTotalTrades = recipientTradesActive +\n            recipientProposedTrades;\n        uint256 recipientHarborAmount = ImprovementsContract2(improvements2)\n            .getHarborCount(recipientId);\n        uint256 recipientMaxTrades = 4;\n        if (recipientHarborAmount > 0) {\n            recipientMaxTrades = 5;\n        }\n        if (recipientMaxTrades >= (recipientTotalTrades + 1)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    ///@dev this is a public function callable from the recipient of a trade proposal that will allow a nation to accept a trade proposal\n    ///@notice this function will allow the recipient of a trade proposal to accept a trade proposal\n    ///@param recipientId is the nation id of the recipient of the trade proposal\n    ///@param requestorId is the nation id of the requestor of the trade proposal\n    ///@notice once a trade proposal is accepted the requesting nations and recipient nations resources will be reset to reflect the additional resources\n    function fulfillTradingPartner(\n        uint256 recipientId,\n        uint256 requestorId\n    ) public {\n        bool isOwner = mint.checkOwnership(recipientId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        bool isProposed = isProposedTrade(recipientId, requestorId);\n        require(isProposed == true, \"Not an active trade proposal\");\n        uint256[]\n            storage proposedTradesOfRequestor = idToProposedTradingPartners[\n                requestorId\n            ];\n        bool sanctioned = sen.isSanctioned(recipientId, requestorId);\n        require(sanctioned == false, \"trade is sanctioned\");\n        for (uint256 i = 0; i < proposedTradesOfRequestor.length; i++) {\n            if (proposedTradesOfRequestor[i] == recipientId) {\n                proposedTradesOfRequestor[i] = proposedTradesOfRequestor[\n                    proposedTradesOfRequestor.length - 1\n                ];\n                proposedTradesOfRequestor.pop();\n            }\n        }\n        uint256[]\n            storage proposedTradesOfRecipient = idToProposedTradingPartners[\n                recipientId\n            ];\n        for (uint256 i = 0; i < proposedTradesOfRecipient.length; i++) {\n            if (proposedTradesOfRecipient[i] == requestorId) {\n                proposedTradesOfRecipient[i] = proposedTradesOfRecipient[\n                    proposedTradesOfRecipient.length - 1\n                ];\n                proposedTradesOfRecipient.pop();\n            }\n        }\n        uint256[] storage recipientTradeAgreements = idToTradingPartners[\n            recipientId\n        ];\n        recipientTradeAgreements.push(requestorId);\n        uint256[] storage requestorTradeAgreements = idToTradingPartners[\n            requestorId\n        ];\n        requestorTradeAgreements.push(recipientId);\n        setResources(recipientId);\n        setResources(requestorId);\n        emit TradeAccepted(requestorId, recipientId);\n    }\n\n    ///@dev this is a public function callable by either member of an active trade that will remove the active trade\n    ///@notice this function will allow a trade agreement to be terminated\n    ///@param nationId is the nation id of the nation initializing the trade cancellation\n    ///@param partnerId is the nation id of the partner nation in the trade agreement being cancelled\n    function removeTradingPartner(uint256 nationId, uint256 partnerId) public {\n        bool isOwner = mint.checkOwnership(nationId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        bool isActive = isActiveTrade(nationId, partnerId);\n        require(isActive == true, \"this is not an active trade\");\n        for (uint256 i = 0; i < idToTradingPartners[nationId].length; i++) {\n            if (idToTradingPartners[nationId][i] == partnerId) {\n                idToTradingPartners[nationId][i] = idToTradingPartners[\n                    nationId\n                ][idToTradingPartners[nationId].length - 1];\n                idToTradingPartners[nationId].pop();\n            }\n        }\n        for (uint256 i = 0; i < idToTradingPartners[partnerId].length; i++) {\n            if (idToTradingPartners[partnerId][i] == nationId) {\n                idToTradingPartners[partnerId][i] = idToTradingPartners[\n                    partnerId\n                ][idToTradingPartners[partnerId].length - 1];\n                idToTradingPartners[partnerId].pop();\n            }\n        }\n        setResources(nationId);\n        setResources(partnerId);\n        emit TradeCancelled(nationId, partnerId);\n    }\n\n    ///@dev this is a public view function that will take two trading partners in the parameters and return a boolean value\n    ///@dev this function will return true if there is a proposed trade between the two nation id's being passed in\n    ///@param recipientId is the nation id of the first nation being queried\n    ///@param requestorId is the nation id of the second nation being queried\n    ///@return isProposed will be true if there is an active proposal between the two nations\n    function isProposedTrade(\n        uint256 recipientId,\n        uint256 requestorId\n    ) public view returns (bool isProposed) {\n        uint256[]\n            memory proposedTradesOfRecipient = idToProposedTradingPartners[\n                recipientId\n            ];\n        for (uint256 i = 0; i < proposedTradesOfRecipient.length; i++) {\n            if (proposedTradesOfRecipient[i] == requestorId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    ///@dev this is a public view function that will take two trading partners in the parameters and return a boolean value\n    ///@dev this function will return true if there is an active trade between the two nation id's being passed in\n    ///@param country1Id is the nation id of the first nation being queried\n    ///@param country2Id is the nation id of the second nation being queried\n    ///@return isActive will be true if there is an active trae between the two nations\n    function isActiveTrade(\n        uint256 country1Id,\n        uint256 country2Id\n    ) public view returns (bool isActive) {\n        uint256[] memory activeTrades = idToTradingPartners[country1Id];\n        for (uint256 i = 0; i < activeTrades.length; i++) {\n            if (activeTrades[i] == country2Id) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    ///@dev this is a public view function that will return the 2 resources for a given nation\n    ///@notice this function will return a given nations 2 randomly selected resources\n    ///@param partnerId this is the nation id of the nation being queried\n    ///@return uint256 is the numerical representation of the nations resources\n    function getResourcesFromTradingPartner(\n        uint256 partnerId\n    ) public view returns (uint256, uint256) {\n        uint256[] memory partnerResources = idToPlayerResources[partnerId];\n        uint256 resource1 = partnerResources[0];\n        uint256 resource2 = partnerResources[1];\n        return (resource1, resource2);\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the aluminium resource\n    ///@notice this function will return a boolean value of true if a nation has access to the aluminium resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the aluminium resource\n    function viewAluminium(uint256 id) public view returns (bool) {\n        bool isAluminium = idToResources1[id].aluminium;\n        return isAluminium;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the cattle resource\n    ///@notice this function will return a boolean value of true if a nation has access to the cattle resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the cattle resource\n    function viewCattle(uint256 id) public view returns (bool) {\n        bool isCattle = idToResources1[id].cattle;\n        return isCattle;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the coal resource\n    ///@notice this function will return a boolean value of true if a nation has access to the coal resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the coal resource\n    function viewCoal(uint256 id) public view returns (bool) {\n        bool isCoal = idToResources1[id].coal;\n        return isCoal;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the fish resource\n    ///@notice this function will return a boolean value of true if a nation has access to the fish resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the fish resource\n    function viewFish(uint256 id) public view returns (bool) {\n        bool isFish = idToResources1[id].fish;\n        return isFish;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the furs resource\n    ///@notice this function will return a boolean value of true if a nation has access to the furs resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the furs resource\n    function viewFurs(uint256 id) public view returns (bool) {\n        bool isFurs = idToResources1[id].furs;\n        return isFurs;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the gems resource\n    ///@notice this function will return a boolean value of true if a nation has access to the gems resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the gems resource\n    function viewGems(uint256 id) public view returns (bool) {\n        bool isGems = idToResources1[id].gems;\n        return isGems;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the gold resource\n    ///@notice this function will return a boolean value of true if a nation has access to the gold resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the gold resource\n    function viewGold(uint256 id) public view returns (bool) {\n        bool isGold = idToResources1[id].gold;\n        return isGold;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the iron resource\n    ///@notice this function will return a boolean value of true if a nation has access to the iron resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the iron resource\n    function viewIron(uint256 id) public view returns (bool) {\n        bool isIron = idToResources1[id].iron;\n        return isIron;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the lead resource\n    ///@notice this function will return a boolean value of true if a nation has access to the lead resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the lead resource\n    function viewLead(uint256 id) public view returns (bool) {\n        bool isLead = idToResources1[id].lead;\n        return isLead;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the lumber resource\n    ///@notice this function will return a boolean value of true if a nation has access to the lumber resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the lumber resource\n    function viewLumber(uint256 id) public view returns (bool) {\n        bool isLumber = idToResources1[id].lumber;\n        return isLumber;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the marble resource\n    ///@notice this function will return a boolean value of true if a nation has access to the marble resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the marble resource\n    function viewMarble(uint256 id) public view returns (bool) {\n        bool isMarble = idToResources1[id].marble;\n        return isMarble;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the oil resource\n    ///@notice this function will return a boolean value of true if a nation has access to the oil resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the oil resource\n    function viewOil(uint256 id) public view returns (bool) {\n        bool isOil = idToResources2[id].oil;\n        return isOil;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the pigs resource\n    ///@notice this function will return a boolean value of true if a nation has access to the pigs resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the pigs resource\n    function viewPigs(uint256 id) public view returns (bool) {\n        bool isPigs = idToResources2[id].pigs;\n        return isPigs;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the rubber resource\n    ///@notice this function will return a boolean value of true if a nation has access to the rubber resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the rubber resource\n    function viewRubber(uint256 id) public view returns (bool) {\n        bool isRubber = idToResources2[id].rubber;\n        return isRubber;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the silver resource\n    ///@notice this function will return a boolean value of true if a nation has access to the silver resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the silver resource\n    function viewSilver(uint256 id) public view returns (bool) {\n        bool isSilver = idToResources2[id].silver;\n        return isSilver;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the spices resource\n    ///@notice this function will return a boolean value of true if a nation has access to the spices resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the spices resource\n    function viewSpices(uint256 id) public view returns (bool) {\n        bool isSpices = idToResources2[id].spices;\n        return isSpices;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the sugar resource\n    ///@notice this function will return a boolean value of true if a nation has access to the sugar resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the sugar resource\n    function viewSugar(uint256 id) public view returns (bool) {\n        bool isSugar = idToResources2[id].sugar;\n        return isSugar;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the uranium resource\n    ///@notice this function will return a boolean value of true if a nation has access to the uranium resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the uranium resource\n    function viewUranium(uint256 id) public view returns (bool) {\n        bool isUranium = idToResources2[id].uranium;\n        return isUranium;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the water resource\n    ///@notice this function will return a boolean value of true if a nation has access to the water resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the water resource\n    function viewWater(uint256 id) public view returns (bool) {\n        bool isWater = idToResources2[id].water;\n        return isWater;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the wheat resource\n    ///@notice this function will return a boolean value of true if a nation has access to the wheat resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the wheat resource\n    function viewWheat(uint256 id) public view returns (bool) {\n        bool isWheat = idToResources2[id].wheat;\n        return isWheat;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the wine resource\n    ///@notice this function will return a boolean value of true if a nation has access to the wine resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the wine resource\n    function viewWine(uint256 id) public view returns (bool) {\n        bool isWine = idToResources2[id].wine;\n        return isWine;\n    }\n\n    ///@dev this is a public view function that will return an array of a natons 2 resources\n    ///@notice this function will return an array of a nations 2 selected resources\n    ///@param id is the nation id of the nation being queried\n    ///@return uint256 is an array of the players resources for the nation id passed into the function\n    function getPlayerResources(\n        uint256 id\n    ) public view returns (uint256[] memory) {\n        uint256[] memory resources = idToPlayerResources[id];\n        return resources;\n    }\n\n    ///@dev this is a public view function that will return an array with a nations trading partners\n    ///@notice this function will return a given nation's trading partners\n    ///@param id is the nation id of the nation being queried\n    ///@return uint256 is an array of the nation id's of a nations trading pertners\n    function getTradingPartners(\n        uint256 id\n    ) public view returns (uint256[] memory) {\n        uint256[] memory partners = idToTradingPartners[id];\n        return partners;\n    }\n\n    modifier onlySenateContract() {\n        require(\n            msg.sender == senate,\n            \"this function is only callable from the senate contract\"\n        );\n        _;\n    }\n\n    function removeTradingPartnersFromSanction(\n        uint256 idSanctioned,\n        uint256 sanctionTeam\n    ) public onlySenateContract {\n        uint256[] memory partners = idToTradingPartners[idSanctioned];\n\n        for (uint256 i = 0; i < partners.length; i++) {\n            uint256 partnerId = partners[i];\n            uint256 partnerTeam = params.getTeam(partnerId);\n            if (partnerTeam == sanctionTeam) {\n                for (\n                    uint256 j = 0;\n                    j < idToTradingPartners[idSanctioned].length;\n                    j++\n                ) {\n                    if (idToTradingPartners[idSanctioned][j] == partnerId) {\n                        idToTradingPartners[idSanctioned][\n                            j\n                        ] = idToTradingPartners[idSanctioned][\n                            idToTradingPartners[idSanctioned].length - 1\n                        ];\n                        idToTradingPartners[idSanctioned].pop();\n                    }\n                }\n                for (\n                    uint256 k = 0;\n                    k < idToTradingPartners[partnerId].length;\n                    k++\n                ) {\n                    if (idToTradingPartners[partnerId][k] == idSanctioned) {\n                        idToTradingPartners[partnerId][k] = idToTradingPartners[\n                            partnerId\n                        ][idToTradingPartners[partnerId].length - 1];\n                        idToTradingPartners[partnerId].pop();\n                        setResources(partnerId);\n                    }\n                }\n            }\n        }\n        setResources(idSanctioned);\n    }\n\n    modifier onlyTechMarket() {\n        require(\n            msg.sender == techMkt,\n            \"function only callable from tech market\"\n        );\n        _;\n    }\n\n    function triggerForResources(uint256 id) external onlyTechMarket {\n        setResources(id);\n    }\n}\n\n///@title BonusResourcesContract\n///@author OxSnosh\n///@notice this contract will keep track of a nations bonus resources\n///@dev this contract inherits from chainlink VRF\n///@dev this contract inherits from oepnzeppelin ownable\ncontract BonusResourcesContract is Ownable {\n    address public infrastructure;\n    address public improvements2;\n    address public countryMinter;\n    address public resources;\n    address public crime;\n\n    CountryMinter mint;\n    ResourcesContract res;\n    CrimeContract crim;\n\n    struct BonusResources {\n        bool beer;\n        //beer\n        //requires Water, Wheat, Lumber, Aluminium\n        // //DONE //Increases population happiness + 2.\n        bool steel;\n        //steel\n        // //DONE //reduces infrastructure cost -2%.\n        // //DONE //Lowers all vessel purchase costs -15%\n        //requires Coal and Iron\n        bool construction;\n        //construction\n        // //DONE //Reduces infrastructure cost -5% and\n        // //DONE //raises the aircraft limit +10.\n        //requires Lumber, Iron, Marble, Aluminium, tech > 5\n        bool fastFood;\n        //fast food\n        // //DONE //Increases population happiness + 2.\n        //requires Cattle, Sugar, Spices, Pigs\n        bool fineJewelry;\n        //fine jewelry\n        // //DONE //Increases population happiness + 3.\n        //requires Gold, Silver, Gems, Coal\n        bool scholars;\n        //scholars\n        // //DONE //increases population income +$3.00\n        //requires literacy rate > 90%, lumber, lead\n        bool asphalt;\n        //asphalt\n        // //DONE //Lowers infrastructure upkeep cost -5%.\n        //requires Construction, Oil, Rubber\n        bool automobiles;\n        //automobiles\n        // //DONE //Increases population happiness +3.\n        //requires Asphalt, Steel\n        bool affluentPopulation;\n        //affluent population\n        //DONE //Increases number of citizens +5%.\n        //requires fineJewelry, Fish, Furs, Wine\n        bool microchips;\n        //microchips\n        // //DONE //reduces tech cost -8%\n        // //DONE //increases population happiness +2\n        // //DONE //lowers frigate, destroyer, submarine, aircraft carrier upkeep cost -10%\n        //requires Gold, Lead, Oil, tech > 10\n        bool radiationCleanup;\n        //radiation cleanup\n        //reduces nuclear anarchy effects by 1 day\n        // //DONE //Improves a nation's environment by 1\n        // //DONE //Reduces global radiation for your nation by 50%\n        //requires Construction, Microchips, Steel and Technology > 15\n    }\n\n    mapping(uint256 => BonusResources) public idToBonusResources;\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"this function is only callable from the country minter contract\"\n        );\n        _;\n    }\n\n    modifier onlyResources() {\n        require(\n            msg.sender == resources,\n            \"function only callable from resources contract\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _infrastructure,\n        address _countryMinter,\n        address _resources,\n        address _crime\n    ) public onlyOwner {\n        infrastructure = _infrastructure;\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        crime = _crime;\n        crim = CrimeContract(_crime);\n    }\n\n    ///@dev this is a public function that is only callable from the country minter contract when a nation is minted\n    ///@dev this function will allow a nation to store the bonus resources they have access to\n    ///@notice this function will allow a nation to store the bonus resources they have access to\n    ///@param id is the nation id of the nation being minted\n    function generateBonusResources(uint256 id) public onlyCountryMinter {\n        BonusResources memory newBonusResources = BonusResources(\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false\n        );\n        idToBonusResources[id] = newBonusResources;\n    }\n\n    ///@dev this is an internal function only callable from this contract\n    ///@notice bonus resources are certain resources that you can get credit for only hen you have the correct mix of primary resources and parameters\n    ///@param id is the nation id of the nation whose resources are being reset\n    function setBonusResources(uint256 id) public onlyResources {\n        idToBonusResources[id].affluentPopulation = false;\n        idToBonusResources[id].asphalt = false;\n        idToBonusResources[id].automobiles = false;\n        idToBonusResources[id].beer = false;\n        idToBonusResources[id].construction = false;\n        idToBonusResources[id].fastFood = false;\n        idToBonusResources[id].fineJewelry = false;\n        idToBonusResources[id].microchips = false;\n        idToBonusResources[id].radiationCleanup = false;\n        idToBonusResources[id].scholars = false;\n        idToBonusResources[id].steel = false;\n        //check for beer (aluminium, luber, water, wheat)\n        bool beer = checkBeer(id);\n        if (beer) {\n            idToBonusResources[id].beer = true;\n        }\n        //check for steel (coal, iron)\n        bool steel = checkSteel(id);\n        if (steel) {\n            idToBonusResources[id].steel = true;\n        }\n        //construction (lumber, iron, marble, aluminum)\n        bool construction = checkConstruction(id);\n        if (construction) {\n            idToBonusResources[id].construction = true;\n        }\n        //fast food (cattle sugar spices pigs)\n        bool fastFood = checkFastFood(id);\n        if (fastFood) {\n            idToBonusResources[id].fastFood = true;\n        }\n        //fine jewelry (gold silver gems coal)\n        bool fineJewelry = checkFineJewelry(id);\n        if (fineJewelry) {\n            idToBonusResources[id].fineJewelry = true;\n        }\n        //scholars (lumber, lead, literacy >90%)\n        bool scholars = checkScholars(id);\n        if (scholars) {\n            idToBonusResources[id].scholars = true;\n        }\n        //asphalt (construction, oil, rubber)\n        bool asphalt = checkAsphalt(id);\n        if (asphalt) {\n            idToBonusResources[id].asphalt = true;\n        }\n        //automobiles (asphalt, Steel)\n        bool automobiles = checkAutomobiles(id);\n        if (automobiles) {\n            idToBonusResources[id].automobiles = true;\n        }\n        //affluent population (fine jewelry fish furs wine)\n        bool affluentPopulation = checkAffluentPopulation(id);\n        if (affluentPopulation) {\n            idToBonusResources[id].affluentPopulation = true;\n        }\n        setAdditionalBonusResources(id);\n    }\n\n    function setAdditionalBonusResources(uint256 id) internal {\n        //microchips (Gold, Lead, Oil, tech > 10)\n        uint256 techAmount = InfrastructureContract(infrastructure)\n            .getTechnologyCount(id);\n        bool microchips = checkMicrochips(id);\n        if (techAmount >= 10 && microchips) {\n            idToBonusResources[id].microchips = true;\n        }\n        //radiation cleanup (Construction, Microchips, Steel and Technology > 15)\n        bool radiationCleanup = checkRadiationCleanup(id);\n        if (techAmount >= 10 && radiationCleanup) {\n            idToBonusResources[id].radiationCleanup = true;\n        }\n    }\n\n    function checkBeer(uint256 id) public view returns (bool) {\n        bool aluminium = res.viewAluminium(id);\n        bool lumber = res.viewLumber(id);\n        bool water = res.viewWater(id);\n        bool wheat = res.viewWheat(id);\n        if (aluminium && lumber && water && wheat) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function checkSteel(uint256 id) public view returns (bool) {\n        bool iron = res.viewIron(id);\n        bool coal = res.viewCoal(id);\n        if (iron && coal) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function checkConstruction(uint256 id) public view returns (bool) {\n        bool aluminium = res.viewAluminium(id);\n        bool iron = res.viewIron(id);\n        bool lumber = res.viewLumber(id);\n        bool marble = res.viewMarble(id);\n        if (aluminium && iron && lumber && marble) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function checkFastFood(uint256 id) public view returns (bool) {\n        bool cattle = res.viewCattle(id);\n        bool sugar = res.viewSugar(id);\n        bool spices = res.viewSpices(id);\n        bool pigs = res.viewPigs(id);\n        if (cattle && sugar && spices && pigs) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function checkFineJewelry(uint256 id) public view returns (bool) {\n        bool gold = res.viewGold(id);\n        bool silver = res.viewSilver(id);\n        bool gems = res.viewGems(id);\n        bool coal = res.viewCoal(id);\n        if (gold && silver && gems && coal) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function checkScholars(uint256 id) public view returns (bool) {\n        bool lumber = res.viewLumber(id);\n        bool lead = res.viewLead(id);\n        uint256 literacyPercentage = crim.getLiteracy(id);\n        if (lumber && lead && literacyPercentage >= 90) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function checkAsphalt(uint256 id) public view returns (bool) {\n        bool construction = idToBonusResources[id].construction;\n        bool oil = res.viewOil(id);\n        bool rubber = res.viewRubber(id);\n        if (construction && oil && rubber) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function checkAutomobiles(uint256 id) public view returns (bool) {\n        bool asphalt = idToBonusResources[id].asphalt;\n        bool steel = idToBonusResources[id].steel;\n        if (asphalt && steel) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function checkAffluentPopulation(uint256 id) public view returns (bool) {\n        bool fineJewelry = idToBonusResources[id].fineJewelry;\n        bool fish = res.viewFish(id);\n        bool furs = res.viewFurs(id);\n        bool wine = res.viewWine(id);\n        if (fineJewelry && fish && furs && wine) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function checkMicrochips(uint256 id) public view returns (bool) {\n        bool gold = res.viewGold(id);\n        bool lead = res.viewLead(id);\n        bool oil = res.viewOil(id);\n        if (gold && lead && oil) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function checkRadiationCleanup(uint256 id) public view returns (bool) {\n        bool construction = idToBonusResources[id].construction;\n        bool microchips = idToBonusResources[id].microchips;\n        bool steel = idToBonusResources[id].steel;\n        if (construction && microchips && steel) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the affluent population resource\n    ///@notice this function will return a boolean value of true if a nation has access to the affluent population resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the affluent population resource\n    function viewAffluentPopulation(uint256 id) public view returns (bool) {\n        bool isAffluentPopulation = idToBonusResources[id].affluentPopulation;\n        return isAffluentPopulation;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the asphalt resource\n    ///@notice this function will return a boolean value of true if a nation has access to the asphalt resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the asphalt resource\n    function viewAsphalt(uint256 id) public view returns (bool) {\n        bool isAsphalt = idToBonusResources[id].asphalt;\n        return isAsphalt;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the automobiles resource\n    ///@notice this function will return a boolean value of true if a nation has access to the automobiles resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the automobiles resource\n    function viewAutomobiles(uint256 id) public view returns (bool) {\n        bool isAutomobiles = idToBonusResources[id].automobiles;\n        return isAutomobiles;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the beer resource\n    ///@notice this function will return a boolean value of true if a nation has access to the beer resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the beer resource\n    function viewBeer(uint256 id) public view returns (bool) {\n        bool isBeer = idToBonusResources[id].beer;\n        return isBeer;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the construction resource\n    ///@notice this function will return a boolean value of true if a nation has access to the construction resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the construction resource\n    function viewConstruction(uint256 id) public view returns (bool) {\n        bool isConstruction = idToBonusResources[id].construction;\n        return isConstruction;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the fast food resource\n    ///@notice this function will return a boolean value of true if a nation has access to the fast food resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the fast food resource\n    function viewFastFood(uint256 id) public view returns (bool) {\n        bool isFastFood = idToBonusResources[id].fastFood;\n        return isFastFood;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the fine jewelry resource\n    ///@notice this function will return a boolean value of true if a nation has access to the fine jewelry resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the fine jewelry resource\n    function viewFineJewelry(uint256 id) public view returns (bool) {\n        bool isFineJewelry = idToBonusResources[id].fineJewelry;\n        return isFineJewelry;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the microships resource\n    ///@notice this function will return a boolean value of true if a nation has access to the microships resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the microchips resource\n    function viewMicrochips(uint256 id) public view returns (bool) {\n        bool isMicrochips = idToBonusResources[id].microchips;\n        return isMicrochips;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the radiation cleanup resource\n    ///@notice this function will return a boolean value of true if a nation has access to the radiation cleanup resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the radiation cleanup resource\n    function viewRadiationCleanup(uint256 id) public view returns (bool) {\n        bool isRadiationCleanup = idToBonusResources[id].radiationCleanup;\n        return isRadiationCleanup;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the scholars resource\n    ///@notice this function will return a boolean value of true if a nation has access to the scholars resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the scholars resource\n    function viewScholars(uint256 id) public view returns (bool) {\n        bool isScholars = idToBonusResources[id].scholars;\n        return isScholars;\n    }\n\n    ///@dev this is a public view function that will retrun a boolean value of true if a nation has access to the steel resource\n    ///@notice this function will return a boolean value of true if a nation has access to the steel resource\n    ///@param id is the nation id of the nation being queried\n    ///@return bool this value will be true if the nation has the steel resource\n    function viewSteel(uint256 id) public view returns (bool) {\n        bool isSteel = idToBonusResources[id].steel;\n        return isSteel;\n    }\n}\n"
    },
    "contracts/Senate.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./CountryParameters.sol\";\nimport \"./Wonders.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./KeeperFile.sol\";\nimport \"./Resources.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\";\n\n///@title SenateContract\n///@author OxSnosh\n///@notice this contract will allow nation owners to vote for team senators\n///@notice team senators will be able to sanction nations from trading with trading partners on the same team\n///@dev this contract inherits from the openzeppelin ownable contract\ncontract SenateContract is ChainlinkClient, KeeperCompatibleInterface, Ownable {\n    using Chainlink for Chainlink.Request;\n\n    uint256 public epoch;\n    uint256 public interval;\n    uint256 public dayOfLastElection;\n    uint256 maximumSanctions = 25;\n    address public countryMinter;\n    address public parameters;\n    address public wonders3;\n    address public keeper;\n    address public resources;\n    \n\n    WondersContract3 won3;\n    CountryMinter mint;\n    KeeperContract keep;\n    CountryParametersContract params;\n    ResourcesContract res;\n\n    struct Voter {\n        uint256 lastVoteCast;\n        bool senator;\n        uint256 team;\n        uint256 dayTeamJoined;\n        mapping(uint256 => bool) sanctionsByTeam;\n        mapping(uint256 => uint256) dayOfSanctionByTeam;\n    }\n\n    event Vote(\n        uint256 indexed voterId,\n        uint256 indexed team,\n        uint256 indexed voteCastFor,\n        address voter\n    );\n\n    event Sanction (\n        uint256 indexed senatorId,\n        uint256 indexed team,\n        uint256 indexed sanctionedId\n    );\n\n    event SanctionLifted(\n        uint256 indexed senatorId,\n        uint256 indexed team,\n        uint256 indexed sanctionedId\n    );\n\n    mapping(uint256 => Voter) public idToVoter;\n    mapping(uint256 => uint256[]) public teamToCurrentSanctions;\n    mapping(uint256 => mapping(uint256 => uint256[])) epochToTeamToSenatorVotes;\n    mapping(uint256 => mapping(uint256 => uint256[])) epochToTeamToWinners;\n\n    ///@param _interval is in days\n    constructor(uint _interval) {\n        interval = _interval;\n    }\n\n    ///@param _interval is in days\n    function updateInterval(uint _interval) public onlyOwner {\n        interval = _interval;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _countryMinter,\n        address _parameters,\n        address _wonders3,\n        address _keeper,\n        address _resources\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        parameters = _parameters;\n        wonders3 = _wonders3;\n        won3 = WondersContract3(_wonders3);\n        keeper = _keeper;\n        keep = KeeperContract(_keeper);\n        resources = _resources;\n        res = ResourcesContract(_resources);\n    }\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"function only callable from countryminter\"\n        );\n        _;\n    }\n\n    modifier onlyCountryParameters() {\n        require(\n            msg.sender == parameters,\n            \"function only callable from country paraeters contract\"\n        );\n        _;\n    }\n\n    function updateCountryMinter(address newAddress) public onlyOwner {\n        countryMinter = newAddress;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateCountryParametersContract(\n        address newAddress\n    ) public onlyOwner {\n        parameters = newAddress;\n        params = CountryParametersContract(newAddress);\n    }\n\n    ///@dev this function is only callable by the country minter contract when a nation is minted\n    ///@notice this contract will allow set up a nations voting and senate capabilities upon minting\n    ///@param id is the nation id of the nation being minted\n    function generateVoter(uint256 id) public onlyCountryMinter {\n        uint256 day = keep.getGameDay();\n        Voter storage newVoter = idToVoter[id];\n        newVoter.lastVoteCast = 0;\n        newVoter.senator = false;\n        newVoter.team = 0;\n        newVoter.dayTeamJoined = day;\n    }\n\n    ///@dev this function is only callable from the country parameters contract\n    ///@notice this function will reset a nations team and votes for senator when a nation changes teams\n    ///@param id is the nation id of the nation that changed team\n    ///@param newTeam is the id of the new team the given nation joined\n    function updateTeam(\n        uint256 id,\n        uint256 newTeam\n    ) public onlyCountryParameters {\n        uint256 day = keep.getGameDay();\n        idToVoter[id].team = newTeam;\n        idToVoter[id].dayTeamJoined = day;\n    }\n\n    ///@dev this is a public function callable only by the nation owner that will allow a nation to vote for a team senator\n    ///@notice this function will allow a nation to vote for a team senator on their team\n    ///@notice this function will emit a Vote event when a nation votes\n    ///@notice you can only vote for a fellow team member\n    ///@notice you can only vote once per epoch\n    ///@param idVoter is the nation id of the nation casting the vote\n    ///@param idOfSenateVote is the nation id of the nation being voted for senate\n    function voteForSenator(uint256 idVoter, uint256 idOfSenateVote) public {\n        bool isOwner = mint.checkOwnership(idVoter, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(idVoter != idOfSenateVote, \"cannot vote for yourself\");\n        uint256 dayLastVoted = idToVoter[idVoter].lastVoteCast;\n        require(\n            dayLastVoted <= dayOfLastElection,\n            \"you already voted this epoch\"\n        );\n        uint256 dayTeamJoined = idToVoter[idVoter].dayTeamJoined;\n        uint256 gameDay = keep.getGameDay();\n        if (gameDay >= 30) {\n            require(\n                (dayTeamJoined + 30) < gameDay,\n                \"you must be on a team for 30 days before voting for a senator\"\n            );\n        }\n        uint256 voterTeam = idToVoter[idVoter].team;\n        uint256 teamOfVote = idToVoter[idOfSenateVote].team;\n        require(\n            teamOfVote == voterTeam,\n            \"you can only vote for a fellow team member\"\n        );\n        epochToTeamToSenatorVotes[epoch][voterTeam].push(idOfSenateVote);\n        bool lobbyists = won3.getPoliticalLobbyists(idVoter);\n        if (lobbyists) {\n            epochToTeamToSenatorVotes[epoch][voterTeam].push(idOfSenateVote);\n        }\n        idToVoter[idVoter].lastVoteCast = gameDay;\n        emit Vote(idVoter, voterTeam, idOfSenateVote, msg.sender);\n    }\n\n    function checkUpkeep(\n        bytes calldata /* checkData */\n    )\n        external\n        view\n        returns (bool upkeepNeeded, bytes memory /* performData */)\n    {\n        uint256 gameDay = keep.getGameDay();\n        upkeepNeeded = (gameDay - dayOfLastElection) > interval;\n        return (upkeepNeeded, \"\");\n    }\n\n    function performUpkeep(bytes calldata /* performData */) external override {\n        uint256 gameDay = keep.getGameDay();\n        if ((gameDay - dayOfLastElection) > interval) {\n            console.log(\"performing upkeep\");\n            for (uint256 i = 0; i <= 8; i++) {\n                console.log(\"TEAM\", i);\n                runElections(i, epoch);\n            }\n            epoch++;\n            dayOfLastElection = gameDay;\n        }\n    }\n\n    bytes32 jobId;\n    address oracleAddress;\n    uint256 fee;\n    uint256 orderId;\n\n    function updateJobId(bytes32 _jobId) public onlyOwner {\n        jobId = _jobId;\n    }\n\n    function updateOracleAddress(address _oracleAddress) public onlyOwner {\n        oracleAddress = _oracleAddress;\n        setChainlinkOracle(_oracleAddress);\n    }\n\n    function updateFee(uint256 _fee) public onlyOwner {\n        fee = _fee;\n    }\n\n    function updateLinkAddress(address _linkAddress) public onlyOwner {\n        setChainlinkToken(_linkAddress);\n    }\n\n    ///@dev this is a public function that will be called from an off chain source\n    ///@notice this function is only callable from the keeper performUpkeep()\n    ///@notice this function will make the nations who won the team 7 election senators\n    ///@param team this is the team for which the election is being conducted\n    ///@param _epoch this is the epoch for which the election is occuring\n    function runElections(\n        uint256 team,\n        uint256 _epoch\n    ) internal returns (bytes32 _requestId) {\n        console.log(\"election called for\", team);\n        Chainlink.Request memory req = buildOperatorRequest(\n            jobId,\n            this.completeElection.selector\n        );\n        uint256[] memory teamVotes = epochToTeamToSenatorVotes[epoch][\n            team\n        ];\n        req.addUint(\"orderId\", orderId);\n        req.addUint(\"teamNumber\", team);\n        req.addBytes(\"teamVotes\", abi.encode(teamVotes));\n        req.addUint(\"epoch\", _epoch);\n        orderId++;\n        console.log(\"sending election for team\", team);\n        bytes32 requestId = sendOperatorRequest(req, fee);\n        console.log(\"operator request sent for\", team);\n        return requestId;\n    }\n\n    ///@dev \n    function completeElection(\n        bytes memory winners,\n        uint256 team,\n        uint256 _epoch\n    ) public {\n        uint256[] memory _winners = abi.decode(winners, (uint256[]));\n        if(epoch > 0) {\n            uint256[] memory currentSenators = epochToTeamToWinners[_epoch-1][team];\n            for (uint i = 0; i < currentSenators.length; i++) {\n                idToVoter[currentSenators[i]].senator = false;\n            }\n        }\n        for (uint256 i = 0; i < _winners.length; i++) {\n            idToVoter[_winners[i]].senator = true;\n        }        \n        epochToTeamToWinners[_epoch][team] = _winners;\n    }\n\n    ///@dev this is a public function that can only be called by the contract owner \n    ///@param _maximumSanctions is the maximum number of sanctions a team can have at one time\n    function updaateMaximumSanctions(uint256 _maximumSanctions) public onlyOwner {\n        maximumSanctions = _maximumSanctions;\n    }\n\n    ///@dev this is a public function callable by a senator\n    ///@notice this function will only work if the senator and the nation being sanctioned are on the same team\n    ///@param idSenator is the id of the senator calling the function that will cast the vote to sanction\n    ///@param idSanctioned is the nation id of the nation who the senator is voting to sanction\n    function sanctionTeamMember(\n        uint256 idSenator,\n        uint256 idSanctioned\n    ) public {\n        bool owner = mint.checkOwnership(idSenator, msg.sender);\n        require(owner, \"!nation owner\");\n        require(idToVoter[idSenator].senator == true, \"!senator\");\n        require(\n            idToVoter[idSanctioned].senator == false,\n            \"cannot sanction a senator\"\n        );\n        uint256 senatorTeam = idToVoter[idSenator].team;\n        uint256 sanctionedTeam = idToVoter[idSanctioned].team;\n        require(\n            senatorTeam == sanctionedTeam,\n            \"you can only sanction a fellow team member\"\n        );\n        uint256[] memory currentTeamSanctions = teamToCurrentSanctions[\n            sanctionedTeam\n        ];\n        require (\n            currentTeamSanctions.length < maximumSanctions,\n            \"this team has reached the limit for sanctions\"\n        );\n        uint256 gameDay = keep.getGameDay();\n        Voter storage sanctioned = idToVoter[idSanctioned];\n        require(\n            sanctioned.sanctionsByTeam[sanctionedTeam] == false,\n            \"this nation is already sanctioned\"\n        );\n        sanctioned.sanctionsByTeam[sanctionedTeam] = true;\n        sanctioned.dayOfSanctionByTeam[sanctionedTeam] = gameDay;\n        res.removeTradingPartnersFromSanction(idSanctioned, sanctionedTeam);\n        emit Sanction(idSenator, senatorTeam, idSanctioned);\n    }\n\n    ///@dev this is a public function callable by a senator\n    ///@notice this function will only work if the senator and the nation being sanctioned are on the same team\n    ///@notice sanctions can only be lifted after 10 days\n    ///@notice lifting a sanction only requires one vote from a senator\n    ///@param idSenator is the id of the senator calling the function that will cast the vote to lift the sanction\n    ///@param idSanctioned is the nation id of the nation who the senator is voting to lift the sanction on\n    function liftSanctionVote(uint256 idSenator, uint256 idSanctioned) public {\n        require(idToVoter[idSenator].senator == true, \"!senator\");\n        uint256 senatorTeam = idToVoter[idSenator].team;\n        uint256 sanctionedTeam = idToVoter[idSanctioned].team;\n        require(\n            senatorTeam == sanctionedTeam,\n            \"you can only lift a sanction on a fellow team member\"\n        );\n        Voter storage sanctioned = idToVoter[idSanctioned];\n        uint256 gameDay = keep.getGameDay();\n        uint256 dayOfTeamSanction = sanctioned.dayOfSanctionByTeam[senatorTeam];\n        require(\n            (dayOfTeamSanction + 10) < gameDay,\n            \"you must wait 10 days before lifting a sanction\"\n        );\n        require (\n            sanctioned.sanctionsByTeam[sanctionedTeam] == true,\n            \"this nation is not sanctioned\"\n        );\n        sanctioned.sanctionsByTeam[senatorTeam] = false;\n        uint256[] storage currentTeamSanctions = teamToCurrentSanctions[\n            sanctionedTeam\n        ];\n        for (uint256 i = 0; i < currentTeamSanctions.length; i++) {\n            if (currentTeamSanctions[i] == idSanctioned) {\n                currentTeamSanctions[i] = currentTeamSanctions[\n                    currentTeamSanctions.length - 1\n                ];\n                currentTeamSanctions.pop();\n            }\n        }\n        emit SanctionLifted(idSenator, senatorTeam, idSanctioned);\n    }\n\n    ///@dev this is a public view function that will return if a nation is a senator\n    ///@notice this function will return if a nation is a senator\n    ///@param id this is the nation id of the nation being queried\n    ///@return bool will be true if a nation is a senator\n    function isSenator(uint256 id) public view returns (bool) {\n        return idToVoter[id].senator;\n    }\n\n    ///@notice this function will return the current election epoch\n    function getCurrentEpoch() public view returns (uint256) {\n        return epoch;\n    }\n\n    function isSanctioned(\n        uint256 idSender,\n        uint256 idReceiver\n    ) public view returns (bool) {\n        uint256 senderTeam = idToVoter[idSender].team;\n        uint256 receiverTeam = idToVoter[idReceiver].team;\n        bool senderSanctionedSenderTeam = idToVoter[idSender].sanctionsByTeam[senderTeam];\n        bool recieverSanctionedRecieverTeam = idToVoter[idReceiver].sanctionsByTeam[receiverTeam];\n        bool senderSanctionedRecieverTeam = idToVoter[idSender].sanctionsByTeam[receiverTeam];\n        bool recieverSanctionedSenderTeam = idToVoter[idReceiver].sanctionsByTeam[senderTeam];\n        bool sanctioned;\n        if (senderTeam == receiverTeam) {\n            if (senderSanctionedSenderTeam == true || recieverSanctionedRecieverTeam == true) {\n                sanctioned = true;\n            } else {\n                sanctioned = false;\n            }\n        } else if (senderTeam != receiverTeam) {\n            if (senderSanctionedRecieverTeam == true || recieverSanctionedSenderTeam == true) {\n                sanctioned = true;\n            } else {\n                sanctioned = false;\n            }\n        }\n        return sanctioned;\n    }\n\n    function electSenatorForTesting(uint256 id) public onlyOwner {\n        idToVoter[id].senator = true;\n    }\n}\n"
    },
    "contracts/Spies.sol": {
      "content": "\n//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./Treasury.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Resources.sol\";\nimport \"./Wonders.sol\";\nimport \"./Improvements.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./War.sol\";\nimport \"./NationStrength.sol\";\nimport \"./GroundBattle.sol\";\nimport \"./KeeperFile.sol\";\nimport \"./CountryParameters.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"hardhat/console.sol\";\n\ncontract SpyContract is Ownable {\n    uint256 public spyCost = 100000;\n    address public treasury;\n    address public spyOperations;\n    address public countryMinter;\n    address public improvements2;\n    address public wonder1;\n\n    CountryMinter mint;\n    ImprovementsContract2 imp2;\n    WondersContract1 won1;\n\n    event SpiesPurchased(uint256 indexed id, uint256 indexed amount);\n\n    event SpiesDecommissioned(uint256 indexed id, uint256 indexed amount);\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _spyOperations,\n        address _treasury,\n        address _countryMinter,\n        address _improvements2,\n        address _wonders1\n    ) public onlyOwner {\n        spyOperations = _spyOperations;\n        treasury = _treasury;\n        countryMinter = _countryMinter;\n        mint = CountryMinter(countryMinter);\n        improvements2 = _improvements2;\n        imp2 = ImprovementsContract2(improvements2);\n        wonder1 = _wonders1;\n        won1 = WondersContract1(wonder1);\n    }\n\n    mapping(uint256 => uint256) public idToSpies;\n\n    modifier onlySpyOperations() {\n        require(\n            msg.sender == spyOperations,\n            \"only callable from spy operations contract\"\n        );\n        _;\n    }\n\n    ///@dev this is a public function only callable by the nation owner that will purchase spies\n    ///@notice this function will allow a natio nowner to purchase spies\n    ///@notice you cannot buy more spies than the maximum amount for your nation\n    ///@param amount is the amount of spies being purchased\n    ///@param id is the nation id of the nation buying spies\n    function buySpies(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 maxSpyCount = getMaxSpyCount(id);\n        uint256 currentSpyCount = idToSpies[id];\n        require(\n            (currentSpyCount + amount) <= maxSpyCount,\n            \"cannot own that many spies\"\n        );\n        uint256 purchasePrice = spyCost * amount;\n        uint256 balance = TreasuryContract(treasury).checkBalance(id);\n        require(\n            balance >= purchasePrice,\n            \"insufficient balance to purchase spies\"\n        );\n        idToSpies[id] += amount;\n        TreasuryContract(treasury).spendBalance(id, purchasePrice);\n        emit SpiesPurchased(id, amount);\n    }\n\n    function updateSpyPrice(uint256 newCost) public onlyOwner {\n        spyCost = newCost;\n    }\n\n    function getSpyPrice() public view returns (uint256) {\n        return spyCost;\n    }\n\n    ///@dev this is a public view function that will return the maximum amount of spies a given country can own\n    ///@notice this function will return the maximum amount of spies a nation can own\n    ///@notice the base max spy count for a nation is 50\n    ///@notice intel agencies will increase the max number of spies by 100\n    ///@notice a central intelligence agency wonder will increase the max number of spies by 250\n    ///@param id is the nation id for the nation being queried\n    ///@return uint256 is the maximum number of spies for a given nation\n    function getMaxSpyCount(uint256 id) public view returns (uint256) {\n        uint256 maxSpyCount = 50;\n        uint256 intelAgencies = imp2.getIntelAgencyCount(id);\n        if (intelAgencies > 0) {\n            maxSpyCount += (intelAgencies * 100);\n        }\n        bool cia = won1.getCentralIntelligenceAgency(id);\n        if (cia) {\n            maxSpyCount += 250;\n        }\n        return maxSpyCount;\n    }\n\n    function decommissionSpies(uint256 amount, uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 spyCount = idToSpies[id];\n        require(\n            (spyCount - amount) >= 0,\n            \"not enough spies to decommission that many\"\n        );\n        idToSpies[id] -= amount;\n        emit SpiesDecommissioned(id, amount);\n    }\n\n    ///@dev this is a public function only callable from the Spy Contract\n    ///@notice this function will allow the spy contract to decrease the number of spies of an nation that is lost by the attacker during a spy attack\n    ///@param id is the nation id of the nation losing their spy when the attack fails\n    function decreaseAttackerSpyCount(uint256 id) public onlySpyOperations {\n        idToSpies[id] -= 1;\n    }\n\n    ///@dev this is a public view function that allows the spy contract to decrease the number of spies of a nation in a spy attack\n    ///@notice this function will allow the spy contract to decrease the number of spies lost during a spy attack\n    ///@param amount is the number of spies lost during the attack\n    ///@param id is the nation suffering losses during the spy attack\n    function decreaseDefenderSpyCount(\n        uint256 amount,\n        uint256 id\n    ) public onlySpyOperations {\n        idToSpies[id] -= amount;\n    }\n\n    ///@dev this is a public view function that will return the current spy count for a nation\n    ///@notice this function will return a nations current spy count\n    ///@param countryId is the nation ID of the nation being queried\n    ///@return count is the spy count for a given nation\n    function getSpyCount(\n        uint256 countryId\n    ) public view returns (uint256 count) {\n        uint256 spyAmount = idToSpies[countryId];\n        return spyAmount;\n    }\n}"
    },
    "contracts/SpyOperations.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./Infrastructure.sol\";\nimport \"./Forces.sol\";\nimport \"./Military.sol\";\nimport \"./NationStrength.sol\";\nimport \"./Treasury.sol\";\nimport \"./CountryParameters.sol\";\nimport \"./Wonders.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./KeeperFile.sol\";\nimport \"./Spies.sol\";\nimport \"./Missiles.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"hardhat/console.sol\";\n\n///@title SpyOperationsContract\n///@author OxSnosh\n///@dev this contact inherits from openzeppelin's ownable contract\ncontract SpyOperationsContract is Ownable {\n\n    uint256 public attackId;\n    address public forces;\n    address public spies;\n    address public infrastructure;\n    address public military;\n    address public nationStrength;\n    address public treasury;\n    address public parameters;\n    address public missiles;\n    address public wonders1;\n    address public wonders2;\n    address public countryMinter;\n    address public keeper;\n\n    ForcesContract force;\n    InfrastructureContract inf;\n    MilitaryContract mil;\n    NationStrengthContract strength;\n    TreasuryContract tsy;\n    CountryParametersContract params;\n    MissilesContract mis;\n    WondersContract1 won1;\n    WondersContract2 won2;\n    CountryMinter mint;\n    KeeperContract keep;\n    SpyContract spy;\n\n    struct SpyAttack {\n        uint256 encryptedAttackerId;\n        uint256 defenderId;\n        uint256 attackType;\n        bool attackThwarted;\n        uint256 attackerId;\n    }\n\n    mapping(uint256 => SpyAttack) spyAttackIdToSpyAttack;\n    mapping(uint256 => uint256) s_requestIdToRequestIndex;\n    mapping(uint256 => uint256[]) public s_randomnessRequestIdToRandomWords;\n\n    event randomNumbersRequested(uint256 indexed requestId);\n\n    function settings(\n        address _infrastructure,\n        address _forces,\n        address _military,\n        address _nationStrength,\n        address _wonders1,\n        address _wonders2,\n        address _treasury,\n        address _parameters,\n        address _missiles,\n        address _countryMinter\n    ) public onlyOwner {\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        forces = _forces;\n        force = ForcesContract(_forces);\n        military = _military;\n        mil = MilitaryContract(_military);\n        nationStrength = _nationStrength;\n        strength = NationStrengthContract(_nationStrength);\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        wonders2 = _wonders2;\n        won2 = WondersContract2(_wonders2);\n        treasury = _treasury;\n        tsy = TreasuryContract(_treasury);\n        parameters = _parameters;\n        params = CountryParametersContract(_parameters);\n        missiles = _missiles;\n        mis = MissilesContract(_missiles);\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n    }\n\n    function settings2(address _keeper, address _spies) public onlyOwner {\n        keeper = _keeper;\n        keep = KeeperContract(_keeper);\n        spies = _spies;\n        spy = SpyContract(_spies);\n    }\n\n    ///@dev this functin is callable only by a nation owner and will allow a naton to conduct a spy operation\n    ///@notice this function will allow a nation to conduct a spy operation against another nation\n    ///@param defenderId is the id of the defending nation\n    ///@param attackType the id of the attack as it is stored on this contract\n    function checkSpyOperation(\n        uint256 defenderId,\n        uint256 attackType\n    ) public view returns (bool) {\n        uint256 infrastructureAmount = inf.getInfrastructureCount(defenderId);\n        uint256 techAmount = inf.getTechnologyCount(defenderId);\n        uint256 landAmount = inf.getLandCount(defenderId);\n        if (attackType == 4) {\n            require(\n                landAmount >= 15,\n                \"defender does not have enough land to conduct operation\"\n            );\n        }\n        if (attackType == 10) {\n            require(\n                techAmount >= 15,\n                \"defender does not have enough tech to conduct operation\"\n            );\n        }\n        if (attackType == 13) {\n            require(\n                infrastructureAmount >= 15,\n                \"defender does not have enough infrastructure to conduct operation\"\n            );\n        }\n        uint256 nukeCount = mis.getNukeCount(defenderId);\n        bool silo = won2.getHiddenNuclearMissileSilo(defenderId);\n        if (attackType == 14) {\n            if (silo) {\n                require(\n                    nukeCount >= 6,\n                    \"defender does not have enough nukes to conduct operation\"\n                );\n            } else {\n                require(\n                    nukeCount >= 1,\n                    \"defender does not have enough nukes to conduct operation\"\n                );\n            }\n        }\n        return true;\n    }\n\n\n    function getAttackerSuccessScore(\n        uint256 countryId\n    ) public view returns (uint256) {\n        uint256 spyCount = spy.getSpyCount(countryId);\n        uint256 techAmount = inf.getTechnologyCount(countryId);\n        uint256 attackSuccessScore = (spyCount + (techAmount / 15));\n        bool cia = won1.getCentralIntelligenceAgency(countryId);\n        if (cia) {\n            attackSuccessScore = ((attackSuccessScore * 110) / 100);\n        }\n        bool accomodativeGovt = checkAccomodativeGovernment(countryId);\n        if (accomodativeGovt) {\n            attackSuccessScore = ((attackSuccessScore * 110) / 100);\n        }\n        return attackSuccessScore;\n    }\n\n    function checkAccomodativeGovernment(uint256 countryId)\n        public\n        view\n        returns (bool)\n    {\n        uint256 government = params.getGovernmentType(\n            countryId\n        );\n        if (\n            government == 2 ||\n            government == 7 ||\n            government == 10\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function getDefenseSuccessScore(\n        uint256 countryId\n    ) public view returns (uint256) {\n        uint256 spyCount = spy.getSpyCount(countryId);\n        uint256 techAmount = inf.getTechnologyCount(countryId);\n        uint256 landAmount = inf.getLandCount(countryId);\n        uint256 threatLevel = mil.getThreatLevel(countryId);\n        uint256 defenseSuccessScoreGross = (spyCount +\n            (techAmount / 20) +\n            (landAmount / 70));\n        uint256 defenseSuccessScore;\n        if (threatLevel == 1) {\n            defenseSuccessScore = ((defenseSuccessScoreGross * 75) / 100);\n        } else if (threatLevel == 2) {\n            defenseSuccessScore = ((defenseSuccessScoreGross * 90) / 100);\n        } else if (threatLevel == 3) {\n            defenseSuccessScore = defenseSuccessScoreGross;\n        } else if (threatLevel == 4) {\n            defenseSuccessScore = ((defenseSuccessScoreGross * 110) / 100);\n        } else {\n            defenseSuccessScore = ((defenseSuccessScoreGross * 125) / 100);\n        }\n        return defenseSuccessScore;\n    }\n\n    event SpyAttackResults(\n        uint256 indexed attackId,\n        uint256 indexed attackerId,\n        uint256 indexed defenderId,\n        bool success,\n        uint256 attackType\n    );\n\n    address relayer;\n\n    function setRelayer(address _relayer) public onlyOwner {\n        relayer = _relayer; \n    }\n\n    modifier onlyRelayer() {\n        require(msg.sender == relayer);\n        _;\n    }\n\n    function spyAttack(bool success, uint256 attackType, uint256 defenderId, uint256 attackerId, uint256 cost, uint256 randomNumber) public onlyRelayer() {\n        console.log(\"success\", success);\n        console.log(\"defenderId\", defenderId);\n        console.log(\"attackerId\", attackerId);\n        console.log(\"attackType\", attackType);\n        console.log(\"cost\", cost);\n        console.log(\"randomNumber\", randomNumber);\n        if (success) {\n            tsy.spendBalance(attackerId, cost);\n            emit SpyAttackResults (\n                attackId,\n                999999999,\n                defenderId,\n                true,\n                attackType\n            );\n            completeSpyAttack(success, attackId, attackerId, defenderId, attackType, randomNumber);\n        }\n        attackId++;\n    }\n\n    function completeSpyAttack(\n        bool success,\n        uint256 _attackId,\n        uint256 attackerId,\n        uint256 defenderId,\n        uint256 attackType,\n        uint256 randomNumber\n    ) internal {\n        if (!success) {\n            emit SpyAttackResults(\n                _attackId,\n                attackerId,\n                defenderId,\n                false,\n                attackType\n            );\n        } else if (success) {\n            if (attackType == 1) {\n                destroyCruiseMissiles(defenderId, randomNumber);\n            } else if (attackType == 2) {\n                destroyDefendingTanks(defenderId, randomNumber);\n            } else if (attackType == 3) {\n                captureLand(defenderId, randomNumber);\n            } else if (attackType == 4) {\n                changeDesiredGovernment(defenderId, randomNumber);\n            } else if (attackType == 5) {\n                changeDesiredReligion(defenderId, randomNumber);\n            } else if (attackType == 6) {\n                changeThreatLevel(defenderId);\n            } else if (attackType == 7) {\n                changeDefconLevel(defenderId);\n            } else if (attackType == 8) {\n                destroySpies(defenderId, randomNumber);\n            } else if (attackType == 9) {\n                captueTechnology(defenderId, randomNumber);\n            } else if (attackType == 10) {\n                sabotogeTaxes(defenderId, randomNumber);\n            } else if (attackType == 11) {\n                destroyMoneyReserves(defenderId);\n            } else if (attackType == 12) {\n                captureInfrastructure(defenderId, randomNumber);\n            } else {\n                destroyNukes(defenderId);\n            }\n        }\n    }\n\n    function destroyCruiseMissiles(\n        uint256 defenderId,\n        uint256 randomNumber\n    ) internal {\n        uint256 randomNumber2 = (randomNumber % 5) + 1;\n        mis.decreaseCruiseMissileCount(randomNumber2, defenderId);\n    }\n\n    function destroyDefendingTanks(\n        uint256 defenderId,\n        uint256 randomNumber\n    ) internal {\n        uint256 randomPercentage = ((randomNumber % 5) + 5);\n        uint256 defendingTankCount = force.getDefendingTankCount(defenderId);\n        uint256 tankAmountToDecrease = ((defendingTankCount * randomPercentage) /\n            100);\n        force.decreaseDefendingTankCount(tankAmountToDecrease, defenderId);\n    }\n\n    function captureLand(\n        uint256 defenderId,\n        uint256 randomNumber\n    ) internal {\n        uint256 randomNumberToDecreaseFromDefender = ((randomNumber % 10) +\n            5);\n        inf.decreaseLandCountFromSpyContract(defenderId, randomNumberToDecreaseFromDefender);\n    }\n\n    function changeDesiredGovernment(\n        uint256 defenderId,\n        uint256 randomNumber\n    ) internal {\n        uint256 governmentPreference = params.getGovernmentPreference(\n            defenderId\n        );\n        uint256 newPreference = ((randomNumber % 10) + 1);\n        if (newPreference == governmentPreference) {\n            if (governmentPreference == 1) {\n                newPreference += 1;\n            } else {\n                newPreference -= 1;\n            }\n        }\n        params.updateDesiredGovernment(defenderId, newPreference);\n    }\n\n    function changeDesiredReligion(\n        uint256 defenderId,\n        uint256 randomNumber\n    ) internal {\n        uint256 religionPreference = params.getReligionPreference(defenderId);\n        uint256 newPreference = ((randomNumber % 14) + 1);\n        if (newPreference == religionPreference) {\n            if (religionPreference == 1) {\n                newPreference += 1;\n            } else {\n                newPreference -= 1;\n            }\n        }\n        params.updateDesiredReligion(defenderId, newPreference);\n    }\n\n    function changeThreatLevel(\n        uint256 defenderId\n    ) internal {\n        mil.setThreatLevelFromSpyContract(defenderId, 1);\n    }\n\n    function changeDefconLevel(\n        uint256 defenderId\n    ) internal {\n        mil.setDefconLevelFromSpyContract(defenderId, 5);\n    }\n\n    function destroySpies(\n        uint256 defenderId,\n        uint256 randomNumber\n    ) internal {\n        uint256 spyCount = spy.getSpyCount(defenderId);\n        uint256 spyCountToDestroy = ((randomNumber % 20) + 1);\n        if (spyCountToDestroy > spyCount) {\n            spyCountToDestroy = spyCount;\n        }\n        spy.decreaseDefenderSpyCount(spyCountToDestroy, defenderId);\n    }\n\n    function captueTechnology(\n        uint256 defenderId,\n        uint256 randomNumber\n    ) internal {\n        uint256 randomNumberToCapture = ((randomNumber % 10) + 5);\n        inf.decreaseTechCountFromSpyContract(defenderId, randomNumberToCapture);\n    }\n\n    function sabotogeTaxes(\n        uint256 defenderId,\n        uint256 randomNumber\n    ) internal {\n\n        uint256 randomNumberToSetTaxes = ((randomNumber % 4) + 20);\n        inf.setTaxRateFromSpyContract(defenderId, randomNumberToSetTaxes);\n    }\n\n    function destroyMoneyReserves(uint256 defenderId) internal {\n        //max 5% or $10 million\n        uint256 defenderBalance = tsy.checkBalance(defenderId);\n        uint256 amountToDestroy;\n        if (defenderBalance <= (20000000 * (10 ** 18))) {\n            amountToDestroy = ((defenderBalance * 5) / 100);\n        } else {\n            amountToDestroy = (1000000 * (10 ** 18));\n        }\n        tsy.destroyBalance(defenderId, amountToDestroy);\n    }\n\n    function captureInfrastructure(\n        uint256 defenderId,\n        uint256 randomNumber\n    ) internal {\n        uint256 randomNumberToExchange = ((randomNumber % 10) + 5);\n        inf.decreaseInfrastructureCountFromSpyContract(\n            defenderId,\n            randomNumberToExchange\n        );\n    }\n\n    function destroyNukes(uint256 defenderId) internal {\n        //max 1\n        mis.decreaseNukeCountFromSpyContract(defenderId);\n    }\n}\n"
    },
    "contracts/Taxes.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./Infrastructure.sol\";\nimport \"./Treasury.sol\";\nimport \"./Improvements.sol\";\nimport \"./Wonders.sol\";\nimport \"./Resources.sol\";\nimport \"./CountryParameters.sol\";\nimport \"./Forces.sol\";\nimport \"./Military.sol\";\nimport \"./Crime.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./KeeperFile.sol\";\nimport \"./Environment.sol\";\nimport \"./NavyBattle.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"hardhat/console.sol\";\n\n///@title TaxesContract\n///@author OxSnosh\n///@dev this contract inherits from the open zeppelin ownable contract\n///@notice this contract will allow a nation owner to collect taxes from their citizens\ncontract TaxesContract is Ownable {\n    address public countryMinter;\n    address public infrastructure;\n    address public treasury;\n    address public improvements1;\n    address public improvements2;\n    address public improvements3;\n    address public improvements4;\n    address public parameters;\n    address public wonders1;\n    address public wonders2;\n    address public wonders3;\n    address public wonders4;\n    address public resources;\n    address public forces;\n    address public military;\n    address public crime;\n    address public additionalTaxes;\n    address public bonusResources;\n    address public keeper;\n    address public environment;\n    address public blockade;\n\n    InfrastructureContract inf;\n    TreasuryContract tsy;\n    ImprovementsContract1 imp1;\n    ImprovementsContract2 imp2;\n    ImprovementsContract3 imp3;\n    ImprovementsContract4 imp4;\n    CountryParametersContract params;\n    WondersContract1 won1;\n    WondersContract2 won2;\n    WondersContract3 won3;\n    WondersContract4 won4;\n    ResourcesContract res;\n    ForcesContract frc;\n    MilitaryContract mil;\n    CrimeContract crm;\n    AdditionalTaxesContract addTax;\n    CountryMinter mint;\n    BonusResourcesContract bonus;\n    KeeperContract keep;\n    EnvironmentContract env;\n    NavalBlockadeContract blk;\n\n    event TaxesCollected(uint256 indexed id, uint256 indexed amount);\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings1(\n        address _countryMinter,\n        address _infrastructure,\n        address _treasury,\n        address _improvements1,\n        address _improvements2,\n        address _improvements3,\n        address _improvements4,\n        address _additionalTaxes,\n        address _bonusResources,\n        address _keeper,\n        address _environment\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        treasury = _treasury;\n        tsy = TreasuryContract(_treasury);\n        improvements1 = _improvements1;\n        imp1 = ImprovementsContract1(_improvements1);\n        improvements2 = _improvements2;\n        imp2 = ImprovementsContract2(_improvements2);\n        improvements3 = _improvements3;\n        imp3 = ImprovementsContract3(_improvements3);\n        improvements4 = _improvements4;\n        imp4 = ImprovementsContract4(_improvements4);\n        additionalTaxes = _additionalTaxes;\n        addTax = AdditionalTaxesContract(_additionalTaxes);\n        bonusResources = _bonusResources;\n        bonus = BonusResourcesContract(_bonusResources);\n        keeper = _keeper;\n        keep = KeeperContract(_keeper);\n        environment = _environment;\n        env = EnvironmentContract(_environment);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings2(\n        address _parameters,\n        address _wonders1,\n        address _wonders2,\n        address _wonders3,\n        address _wonders4,\n        address _resources,\n        address _forces,\n        address _military,\n        address _crime,\n        address _blockade\n    ) public onlyOwner {\n        parameters = _parameters;\n        params = CountryParametersContract(_parameters);\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        wonders2 = _wonders2;\n        won2 = WondersContract2(_wonders2);\n        wonders3 = _wonders3;\n        won3 = WondersContract3(_wonders3);\n        wonders4 = _wonders4;\n        won4 = WondersContract4(_wonders4);\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        forces = _forces;\n        frc = ForcesContract(_forces);\n        military = _military;\n        mil = MilitaryContract(_military);\n        crime = _crime;\n        crm = CrimeContract(_crime);\n        blockade = _blockade;\n        blk = NavalBlockadeContract(_blockade);\n    }\n\n    ///@dev this is a public function callable only by the nation owner collecting taxes\n    ///@notice this function will allow a nation owner to collect taxes from their citizens\n    ///@param id this is the nation id of the nation collecting taxes\n    function collectTaxes(uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        (bool war, ) = mil.getWarPeacePreference(id);\n        require(war, \"must be ready for war to collct taxes\");\n        (, uint256 taxesCollectible) = getTaxesCollectible(id);\n        inf.toggleCollectionNeededToChangeRate(id);\n        tsy.increaseBalanceOnTaxCollection(id, taxesCollectible);\n        //need to reduce taxes collectible by a percentage for each blockade against\n        emit TaxesCollected(id, taxesCollectible);\n    }\n\n    ///@dev this is a public view function that will return a nations taxes that are collectible\n    ///@notice this function will return a nations taxes collectible\n    ///@param id is the nation id of the nation being queried\n    ///@return dailyTaxesCollectiblePerCitizen is the tax portion of each citizens income per day\n    ///@return taxesCollectible is the amount of taxes that are collectible (daily taxes per citizen * days since last collection * citizen count)\n    function getTaxesCollectible(\n        uint256 id\n    ) public view returns (uint256, uint256) {\n        uint256 dailyIncomePerCitizen = getDailyIncome(id);\n        uint256 daysSinceLastTaxCollection = tsy.getDaysSinceLastTaxCollection(\n            id\n        );\n        (uint256 citizenCount, ) = inf.getTaxablePopulationCount(0);\n        uint256 taxRate = inf.getTaxRate(id);\n        uint256 dailyTaxesCollectiblePerCitizen = (dailyIncomePerCitizen *\n            taxRate);\n        uint256 taxesCollectible = (dailyTaxesCollectiblePerCitizen *\n            daysSinceLastTaxCollection *\n            citizenCount) * (10 ** 18);\n        uint256 mod = 100;\n        uint256 percentageReductionForBlockades = blk.getBlockadePercentageReduction(\n            id\n        );\n        mod = mod - percentageReductionForBlockades;\n        console.log(\"mod\", mod);\n        taxesCollectible = ((taxesCollectible * mod) / 100);        \n        return (dailyTaxesCollectiblePerCitizen, taxesCollectible);\n    }\n\n    ///@dev this is a public view function that will return the daily gross income per citizen for a given nation\n    ///@notice this function will return the gross income per citizen for a given nation\n    ///@param id is the nation id of the nation being queried\n    ///@return uint256 is the daily income of each citizen for a nation\n    function getDailyIncome(uint256 id) public view returns (uint256) {\n        uint256 happiness = getHappiness(id);\n        //increasers\n        uint256 banks = imp1.getBankCount(id);\n        uint256 ministries = imp2.getForeignMinistryCount(id);\n        uint256 harbors = imp2.getHarborCount(id);\n        uint256 schools = imp3.getSchoolCount(id);\n        uint256 universityPoints = addTax.getUniversityPoints(id);\n        //detractors\n        uint256 casinos = imp1.getCasinoCount(id);\n        uint256 guerillaCamp = imp2.getGuerillaCampCount(id);\n        uint256 multipliers = (100 +\n            (banks * 7) +\n            (ministries * 5) +\n            (harbors * 1) +\n            (schools * 5) +\n            universityPoints -\n            (guerillaCamp * 8) -\n            (casinos * 1));\n        uint256 baseDailyIncomePerCitizen = (((35 + (2 * happiness)) *\n            multipliers) / 100);\n        uint256 incomeAdjustments = addTax.getIncomeAdjustments(id);\n        uint256 dailyIncomePerCitizen = baseDailyIncomePerCitizen +\n            incomeAdjustments;\n        return dailyIncomePerCitizen;\n    }\n\n    ///@dev this is a publci view function that will return a nations happiness\n    ///@notice this function will return a nations happiness\n    ///@notice the higher a nations happiness the more money its citizens will make\n    ///@param id is the nation id of the nation being queried\n    ///@return happiness is the happiness for the queried nation\n    function getHappiness(uint256 id) public view returns (uint256) {\n        uint256 happinessAdditions = getHappinessPointsToAdd(id);\n        uint256 happinessSubtractions = getHappinessPointsToSubtract(id);\n        uint256 happiness = 0;\n        if (happinessSubtractions >= happinessAdditions) {\n            happiness = 0;\n        } else {\n            happiness = (happinessAdditions - happinessSubtractions);\n        }\n        return happiness;\n    }\n\n    function getHappinessPointsToAdd(uint256 id) public view returns (uint256) {\n        uint256 compatabilityPoints = checkCompatability(id);\n        uint256 densityPoints = getDensityPoints(id);\n        uint256 pointsFromResources = getPointsFromResources(id);\n        uint256 pointsFromImprovements = getPointsFromImprovements(id);\n        uint256 wonderPoints = getHappinessFromWonders(id);\n        uint256 casualtyPoints = getCasualtyPoints(id);\n        uint256 additionalHappinessPoints = getAdditionalHappinessPointsToAdd(\n            id\n        );\n        uint256 happinessPointsToAdd = (compatabilityPoints +\n            densityPoints +\n            pointsFromResources +\n            pointsFromImprovements +\n            wonderPoints +\n            casualtyPoints +\n            additionalHappinessPoints);\n        return happinessPointsToAdd;\n    }\n\n    function getAdditionalHappinessPointsToAdd(\n        uint256 id\n    ) internal view returns (uint256) {\n        uint256 technologyPoints = getTechnologyPoints(id);\n        uint256 pointsFromAge = getPointsFromNationAge(id);\n        uint256 pointsFromTrades = addTax.getPointsFromTrades(id);\n        uint256 pointsFromDefcon = addTax.getPointsFromDefcon(id);\n        uint256 pointsFromGovt = addTax.getPointsFromGovernment(id);\n        uint256 additonalHappinessPointsToAdd = (technologyPoints +\n            pointsFromAge +\n            pointsFromTrades +\n            pointsFromDefcon +\n            pointsFromGovt);\n        return additonalHappinessPointsToAdd;\n    }\n\n    function getHappinessPointsToSubtract(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 taxRatePoints = getTaxRatePoints(id);\n        uint256 pointsFromStability = addTax.getPointsFromMilitary(id);\n        uint256 pointsFromCrime = getPointsFromCriminals(id);\n        uint256 pointsFromImprovements = addTax\n            .getPointsToSubtractFromImprovements(id);\n        uint256 pointsFromIntelAgencies = addTax.getPointsFromIntelAgencies(id);\n        uint256 environmentPoints = env.getEnvironmentScore(id);\n        uint256 happinessPointsToSubtract = (taxRatePoints +\n            pointsFromCrime +\n            pointsFromImprovements +\n            pointsFromStability +\n            pointsFromIntelAgencies +\n            environmentPoints);\n        return happinessPointsToSubtract;\n    }\n\n    function checkCompatability(\n        uint256 id\n    ) public view returns (uint256 compatability) {\n        uint256 religion = params.getReligionType(id);\n        uint256 govType = params.getGovernmentType(id);\n        uint256 preferredReligion = params.getReligionPreference(id);\n        uint256 preferredGovernment = params.getGovernmentPreference(id);\n        (bool monument, bool temple, , , ) = wonderChecks1(id);\n        uint256 religionPoints;\n        uint256 governmentPoints;\n        if (religion == preferredReligion || temple) {\n            religionPoints = 1;\n        }\n        if (govType == preferredGovernment || monument) {\n            governmentPoints = 1;\n        }\n        uint256 compatabilityPoints = (religionPoints + governmentPoints);\n        return compatabilityPoints;\n    }\n\n    function checkPopulationDensity(uint256 id) public view returns (uint256) {\n        uint256 landArea = inf.getAreaOfInfluence(id);\n        uint256 population = inf.getTotalPopulationCount(id);\n        uint256 populationDensity = (population / landArea);\n        return populationDensity;\n    }\n\n    function getDensityPoints(uint256 id) public view returns (uint256) {\n        uint256 densityPoints = 0;\n        uint256 density = checkPopulationDensity(id);\n        uint256 maxDensity = 70;\n        bool water = res.viewWater(id);\n        if (water) {\n            maxDensity = 120;\n        }\n        if (density <= maxDensity) {\n            densityPoints = 5;\n        }\n        return densityPoints;\n    }\n\n    function getPointsFromResources(uint256 id) public view returns (uint256) {\n        uint256 pointsFromResources = 0;\n        bool gems = res.viewGems(id);\n        if (gems) {\n            pointsFromResources += 3;\n        }\n        bool oil = res.viewOil(id);\n        if (oil) {\n            pointsFromResources += 2;\n        }\n        bool silver = res.viewSilver(id);\n        if (silver) {\n            pointsFromResources += 2;\n        }\n        bool spices = res.viewSpices(id);\n        if (spices) {\n            pointsFromResources += 2;\n        }\n        bool sugar = res.viewSugar(id);\n        if (sugar) {\n            pointsFromResources += 1;\n        }\n        bool water = res.viewWater(id);\n        if (water) {\n            pointsFromResources += 3;\n        }\n        bool wine = res.viewWine(id);\n        if (wine) {\n            pointsFromResources += 3;\n        }\n        bool beer = bonus.viewBeer(id);\n        if (beer) {\n            pointsFromResources += 2;\n        }\n        bool fastFood = bonus.viewFastFood(id);\n        if (fastFood) {\n            pointsFromResources += 2;\n        }\n        bool fineJewelry = bonus.viewFineJewelry(id);\n        if (fineJewelry) {\n            pointsFromResources += 3;\n        }\n        uint256 additionalPoints = getAdditionalPointsFromResources(id);\n        pointsFromResources += additionalPoints;\n        return pointsFromResources;\n    }\n\n    function getAdditionalPointsFromResources(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 additionalPointsFromResources;\n        bool automobiles = bonus.viewAutomobiles(id);\n        if (automobiles) {\n            additionalPointsFromResources += 3;\n        }\n        bool microchips = bonus.viewMicrochips(id);\n        if (microchips) {\n            additionalPointsFromResources += 2;\n        }\n        return additionalPointsFromResources;\n    }\n\n    function getPointsFromImprovements(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 pointsFromImprovements;\n        uint256 borderWalls = imp1.getBorderWallCount(id);\n        if (borderWalls > 0) {\n            pointsFromImprovements += (2 * borderWalls);\n        }\n        uint256 casinos = imp1.getCasinoCount(id);\n        if (casinos > 0) {\n            pointsFromImprovements += (2 * casinos);\n        }\n        uint256 churchCount = imp1.getChurchCount(id);\n        if (churchCount > 0) {\n            pointsFromImprovements += churchCount;\n        }\n        uint256 policeHeadquarters = imp4.getPoliceHeadquartersCount(id);\n        if (policeHeadquarters > 0) {\n            pointsFromImprovements += (2 * policeHeadquarters);\n        }\n        uint256 redLightDistricts = imp3.getRedLightDistrictCount(id);\n        if (redLightDistricts > 0) {\n            pointsFromImprovements += (redLightDistricts);\n        }\n        uint256 stadiums = imp3.getStadiumCount(id);\n        if (stadiums > 0) {\n            pointsFromImprovements += (3 * stadiums);\n        }\n        uint256 taxRate = inf.getTaxRate(id);\n        uint256 intelAgencies = imp2.getIntelAgencyCount(id);\n        if (taxRate >= 23) {\n            pointsFromImprovements += intelAgencies;\n        }\n        return pointsFromImprovements;\n    }\n\n    function getHappinessFromWonders(\n        uint256 id\n    ) public view returns (uint256 wonderPts) {\n        (\n            bool monument,\n            bool temple,\n            bool greatUniversity,\n            bool internet,\n            bool movieIndustry\n        ) = wonderChecks1(id);\n        (\n            bool warMemorial,\n            bool scientificDevCenter,\n            bool spaceProgram,\n            bool universalHealthcare\n        ) = wonderChecks2(id);\n        uint256 wonderPoints = 0;\n        if (monument) {\n            wonderPoints += 4;\n        }\n        if (temple) {\n            wonderPoints += 5;\n        }\n        uint256 tech = inf.getTechnologyCount(id);\n        uint256 techDivided = (tech / 1000);\n        if (greatUniversity && !scientificDevCenter) {\n            uint256 points;\n            if (techDivided == 0) {\n                points = 0;\n            } else if (techDivided == 1) {\n                points = 1;\n            } else if (techDivided == 2) {\n                points = 2;\n            } else {\n                points = 3;\n            }\n            wonderPoints += points;\n        } else if (greatUniversity && scientificDevCenter) {\n            uint256 points;\n            if (techDivided == 0) {\n                points = 0;\n            } else if (techDivided == 1) {\n                points = 1;\n            } else if (techDivided == 2) {\n                points = 2;\n            } else if (techDivided == 3) {\n                points = 3;\n            } else if (techDivided == 4) {\n                points = 4;\n            } else {\n                points = 5;\n            }\n            wonderPoints += points;\n        }\n        if (internet) {\n            wonderPoints += 5;\n        }\n        if (movieIndustry) {\n            wonderPoints += 3;\n        }\n        if (warMemorial) {\n            wonderPoints += 4;\n        }\n        if (spaceProgram) {\n            wonderPoints += 3;\n        }\n        if (universalHealthcare) {\n            wonderPoints += 2;\n        }\n        return wonderPoints;\n    }\n\n    function wonderChecks1(\n        uint256 id\n    ) internal view returns (bool, bool, bool, bool, bool) {\n        bool isMonument = won2.getGreatMonument(id);\n        bool isTemple = won2.getGreatTemple(id);\n        bool isUniversity = won2.getGreatUniversity(id);\n        bool isInternet = won2.getInternet(id);\n        bool isMovieIndustry = won3.getMovieIndustry(id);\n\n        return (\n            isMonument,\n            isTemple,\n            isUniversity,\n            isInternet,\n            isMovieIndustry\n        );\n    }\n\n    function wonderChecks2(\n        uint256 id\n    ) internal view returns (bool, bool, bool, bool) {\n        bool isWarMemorial = won3.getNationalWarMemorial(id);\n        bool isScientificDevCenter = won3.getScientificDevelopmentCenter(id);\n        bool isSpaceProgram = won4.getSpaceProgram(id);\n        bool isUniversalHealthcare = won4.getUniversalHealthcare(id);\n        return (\n            isWarMemorial,\n            isScientificDevCenter,\n            isSpaceProgram,\n            isUniversalHealthcare\n        );\n    }\n\n    function getCasualtyPoints(uint256 id) public view returns (uint256) {\n        bool nationalCemetary = won3.getNationalCemetary(id);\n        (uint256 casualties, ) = frc.getCasualties(id);\n        uint256 casualtyPoints = 0;\n        if (nationalCemetary) {\n            if (casualties < 10000000) {\n                casualtyPoints = 1;\n            } else if (casualties < 15000000) {\n                casualtyPoints = 2;\n            } else if (casualties < 20000000) {\n                casualtyPoints = 3;\n            } else if (casualties < 25000000) {\n                casualtyPoints = 4;\n            } else if (casualties >= 25000000) {\n                casualtyPoints = 5;\n            }\n        }\n        return casualtyPoints;\n    }\n\n    function getTechnologyPoints(uint256 id) public view returns (uint256) {\n        uint256 pointsFromTechnology;\n        uint256 tech = inf.getTechnologyCount(id);\n        if (tech == 0) {\n            pointsFromTechnology = 0;\n        } else if (tech == 1) {\n            pointsFromTechnology = 1;\n        } else if (tech <= 3) {\n            pointsFromTechnology = 2;\n        } else if (tech <= 6) {\n            pointsFromTechnology = 3;\n        } else if (tech <= 10) {\n            pointsFromTechnology = 4;\n        } else if (tech <= 15) {\n            pointsFromTechnology = 5;\n        } else if (tech <= 50) {\n            pointsFromTechnology = 6;\n        } else if (tech <= 100) {\n            pointsFromTechnology = 7;\n        } else if (tech <= 150) {\n            pointsFromTechnology = 8;\n        } else if (tech <= 200) {\n            pointsFromTechnology = 9;\n        } else {\n            pointsFromTechnology = 10;\n        }\n        return pointsFromTechnology;\n    }\n\n    function getPointsFromNationAge(uint256 id) public view returns (uint256) {\n        uint256 nationCreated = params.getDayCreated(id);\n        uint256 gameDay = keep.getGameDay();\n        uint256 agePoints = 0;\n        if ((gameDay - nationCreated) < 90) {\n            agePoints = 0;\n        } else if ((gameDay - nationCreated) < 180) {\n            agePoints = 2;\n        } else {\n            agePoints = 4;\n        }\n        return agePoints;\n    }\n\n    function getTaxRatePoints(uint256 id) public view returns (uint256) {\n        uint256 subtractTaxPoints;\n        uint256 taxRate = inf.getTaxRate(id);\n        if (taxRate <= 16) {\n            subtractTaxPoints = 0;\n        } else if (taxRate <= 20) {\n            subtractTaxPoints = 1;\n        } else if (taxRate <= 23) {\n            subtractTaxPoints = 3;\n        } else if (taxRate <= 25) {\n            subtractTaxPoints = 5;\n        } else if (taxRate <= 30) {\n            subtractTaxPoints = 7;\n        }\n        return subtractTaxPoints;\n    }\n\n\n\n    function getPointsFromCriminals(uint256 id) public view returns (uint256) {\n        (uint256 unincarceratedCriminals, , ) = crm.getCriminalCount(id);\n        uint256 pointsFromCrime;\n        if (unincarceratedCriminals < 200) {\n            pointsFromCrime = 0;\n        } else if (unincarceratedCriminals < 2000) {\n            pointsFromCrime = 1;\n        } else if (unincarceratedCriminals < 4000) {\n            pointsFromCrime = 2;\n        } else if (unincarceratedCriminals < 6000) {\n            pointsFromCrime = 3;\n        } else if (unincarceratedCriminals < 8000) {\n            pointsFromCrime = 4;\n        } else {\n            pointsFromCrime = 5;\n        }\n        return pointsFromCrime;\n    }\n}\n\n///@title AdditionalTaxesContract\n///@author OxSnosh\n///@dev tis contract inherits from openzeppelin's ownable contract\n///@notice this contract will have additional formulas that will allow a nation to collect taxes from its citizens\ncontract AdditionalTaxesContract is Ownable {\n    address public infrastructure;\n    address public improvements2;\n    address public improvements3;\n    address public parameters;\n    address public wonders1;\n    address public wonders2;\n    address public wonders3;\n    address public wonders4;\n    address public resources;\n    address public military;\n    address public bonusResources;\n    address public forces;\n\n    InfrastructureContract inf;\n    ImprovementsContract2 imp2;\n    ImprovementsContract3 imp3;\n    CountryParametersContract params;\n    WondersContract1 won1;\n    WondersContract2 won2;\n    WondersContract3 won3;\n    WondersContract4 won4;\n    ResourcesContract res;\n    MilitaryContract mil;\n    BonusResourcesContract bonus;\n    ForcesContract frc;\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _parameters,\n        address _wonders1,\n        address _wonders2,\n        address _wonders3,\n        address _wonders4,\n        address _resources,\n        address _military,\n        address _infrastructure,\n        address _bonusResources\n    ) public onlyOwner {\n        parameters = _parameters;\n        params = CountryParametersContract(_parameters);\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        wonders2 = _wonders2;\n        won2 = WondersContract2(_wonders2);\n        wonders3 = _wonders3;\n        won3 = WondersContract3(_wonders3);\n        wonders4 = _wonders4;\n        won4 = WondersContract4(_wonders4);\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        military = _military;\n        mil = MilitaryContract(_military);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        bonusResources = _bonusResources;\n        bonus = BonusResourcesContract(_bonusResources);\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings2(\n        address _improvements2,\n        address _improvements3,\n        address _forces\n    ) public onlyOwner {\n        improvements2 = _improvements2;\n        imp2 = ImprovementsContract2(_improvements2);\n        improvements3 = _improvements3;\n        imp3 = ImprovementsContract3(_improvements3);\n        forces = _forces;\n        frc = ForcesContract(_forces);\n    }\n\n    function getIncomeAdjustments(uint256 id) public view returns (uint256) {\n        uint256 adjustments = 0;\n        bool furs = res.viewFurs(id);\n        if (furs) {\n            adjustments += 4;\n        }\n        bool gems = res.viewGems(id);\n        if (gems) {\n            adjustments += 2;\n        }\n        bool gold = res.viewGold(id);\n        if (gold) {\n            adjustments += 3;\n        }\n        bool silver = res.viewSilver(id);\n        if (silver) {\n            adjustments += 2;\n        }\n        bool scholars = bonus.viewScholars(id);\n        if (scholars) {\n            adjustments += 3;\n        }\n        bool agriDevProgram = won1.getAgriculturalDevelopmentProgram(id);\n        if (agriDevProgram) {\n            adjustments += 2;\n        }\n        bool miningIndustryConsortium = won2.getMiningIndustryConsortium(id);\n        if (miningIndustryConsortium) {\n            uint256 points = getResourcePointsForMiningConsortium(id);\n            adjustments += (2 * points);\n        }\n        bool stockMarket = won4.getStockMarket(id);\n        if (stockMarket) {\n            adjustments += 10;\n        }\n        uint256 uraniumAndNuclearPowerBonus = getNuclearAndUraniumBonus(id);\n        adjustments += uraniumAndNuclearPowerBonus;\n        return adjustments;\n    }\n\n    function getResourcePointsForMiningConsortium(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 points = 0;\n        bool coal = res.viewCoal(id);\n        if (coal) {\n            points += 1;\n        }\n        bool lead = res.viewLead(id);\n        if (lead) {\n            points += 1;\n        }\n        bool oil = res.viewOil(id);\n        if (oil) {\n            points += 1;\n        }\n        bool uranium = res.viewUranium(id);\n        if (uranium) {\n            points += 1;\n        }\n        return points;\n    }\n\n    function getNuclearAndUraniumBonus(\n        uint256 id\n    ) public view returns (uint256) {\n        bool nuclearPowerPlant = won3.getNuclearPowerPlant(id);\n        bool uranium = res.viewUranium(id);\n        uint256 techAmount = inf.getTechnologyCount(id);\n        uint256 adjustment = 0;\n        if (nuclearPowerPlant && uranium) {\n            adjustment += 3;\n            if (techAmount >= 10 && techAmount < 20) {\n                adjustment += 1;\n            } else if (techAmount >= 20 && techAmount < 30) {\n                adjustment += 2;\n            } else if (techAmount >= 30 && techAmount < 40) {\n                adjustment += 3;\n            } else if (techAmount >= 40) {\n                adjustment += 4;\n            }\n        }\n        return adjustment;\n    }\n\n    function getPointsFromTrades(uint256 id) public view returns (uint256) {\n        uint256[] memory partners = res.getTradingPartners(id);\n        uint256 pointsFromTeamTrades = 0;\n        uint256 callerNationTeam = params.getTeam(id);\n        for (uint256 i = 0; i < partners.length; i++) {\n            uint256 partnerId = partners[i];\n            uint256 partnerTeam = params.getTeam(partnerId);\n            if (callerNationTeam == partnerTeam) {\n                pointsFromTeamTrades++;\n            }\n        }\n        return pointsFromTeamTrades;\n    }\n\n    function getPointsFromDefcon(uint256 id) public view returns (uint256) {\n        uint256 defconLevel = mil.getDefconLevel(id);\n        return (defconLevel - 1);\n    }\n\n    function getPointsToSubtractFromImprovements(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 pointsToSubtractFromImprovements;\n        uint256 laborCamps = imp2.getLaborCampCount(id);\n        if (laborCamps > 0) {\n            pointsToSubtractFromImprovements += (laborCamps * 1);\n        }\n        return pointsToSubtractFromImprovements;\n    }\n\n    function getUniversityPoints(uint256 id) public view returns (uint256) {\n        uint256 universities = imp3.getUniversityCount(id);\n        uint256 universityPoints = 0;\n        bool scientificDevelopmentCenter = won3.getScientificDevelopmentCenter(\n            id\n        );\n        if (universities > 0 && !scientificDevelopmentCenter) {\n                universityPoints = (universities * 8);\n        } else if (universities > 0 && scientificDevelopmentCenter) {\n                universityPoints = (universities * 10);\n        }\n        return universityPoints;\n    }\n\n    function getPointsFromGovernment(uint256 id) public view returns (uint256) {\n        uint256 governmentType = params.getGovernmentType(id);\n        uint256 pointsFromGovernmentType = 0;\n        if (\n            governmentType == 3 ||\n            governmentType == 6 ||\n            governmentType == 8 ||\n            governmentType == 9\n        ) {\n            pointsFromGovernmentType = 1;\n        }\n        return pointsFromGovernmentType;\n    }\n\n    function getPointsFromMilitary(uint256 id) public view returns (uint256) {\n        (uint256 ratio, , ) = soldierToPopulationRatio(id);\n        uint256 pointsFromMilitaryToSubtract;\n        if (ratio > 70) {\n            pointsFromMilitaryToSubtract = 10;\n        }\n        if (ratio < 20) {\n            pointsFromMilitaryToSubtract = 5;\n        }\n        if (ratio < 10) {\n            pointsFromMilitaryToSubtract = 14;\n        }\n        return pointsFromMilitaryToSubtract;\n    }\n\n    function soldierToPopulationRatio(\n        uint256 id\n    ) public view returns (uint256, bool, bool) {\n        uint256 soldierCount = frc.getSoldierCount(id);\n        if (soldierCount == 0) {\n            return(0, false, true);\n        }\n        uint256 populationCount = inf.getTotalPopulationCount(id);\n        uint256 soldierPopulationRatio = (\n            ((soldierCount * 100) / populationCount)\n        );\n        bool environmentPenalty = false;\n        bool anarchyCheck = false;\n        if (soldierPopulationRatio > 60) {\n            environmentPenalty = true;\n        }\n        if (soldierPopulationRatio < 10) {\n            anarchyCheck = true;\n        }\n        return (soldierPopulationRatio, environmentPenalty, anarchyCheck);\n    }\n\n        function getPointsFromIntelAgencies(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 intelAgencies = imp2.getIntelAgencyCount(id);\n        uint256 subtractPoints;\n        uint256 taxRate = inf.getTaxRate(id);\n        if (taxRate <= 20) {\n            subtractPoints = 0;\n        } else if (intelAgencies >= 1 && taxRate > 20 && taxRate <= 23) {\n            subtractPoints = 1;\n        } else if (intelAgencies >= 1 && taxRate > 23) {\n            subtractPoints = intelAgencies;\n        } else {\n            subtractPoints = 0;\n        }\n        return subtractPoints;\n    }\n}\n"
    },
    "contracts/TechnologyMarket.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./CountryMinter.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Resources.sol\";\nimport \"./Improvements.sol\";\nimport \"./Wonders.sol\";\nimport \"./Treasury.sol\";\nimport \"./Crime.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n///@title TechnologyMarketContract\n///@author OxSnosh\n///@dev this contract inherits from openzeppelin's ownable contract\n///@notice this contract allows a nation owner to purchase technology\ncontract TechnologyMarketContract is Ownable {\n    address public countryMinter;\n    address public infrastructure;\n    address public resources;\n    address public improvements3;\n    address public wonders2;\n    address public wonders3;\n    address public wonders4;\n    address public treasury;\n    address public bonusResources;\n    address public crime;\n\n    CountryMinter mint;\n    ResourcesContract res;\n    TreasuryContract tsy;\n    ImprovementsContract3 imp3;\n    WondersContract2 won2;\n    WondersContract3 won3;\n    WondersContract4 won4;\n    InfrastructureContract inf;\n    BonusResourcesContract bonus;\n    CrimeContract crim;\n\n    event TechPurchased(\n        uint256 indexed id,\n        uint256 indexed amount,\n        uint256 indexed cost\n    );\n\n    event TechDestroyed(uint256 indexed id, uint256 indexed amount);\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _resources,\n        address _improvements3,\n        address _infrastructure,\n        address _wonders2,\n        address _wonders3,\n        address _wonders4,\n        address _treasury,\n        address _countryMinter,\n        address _bonusResources,\n        address _crime\n    ) public onlyOwner {\n        resources = _resources;\n        res = ResourcesContract(_resources);\n        improvements3 = _improvements3;\n        imp3 = ImprovementsContract3(_improvements3);\n        infrastructure = _infrastructure;\n        inf = InfrastructureContract(_infrastructure);\n        wonders2 = _wonders2;\n        won2 = WondersContract2(_wonders2);\n        wonders3 = _wonders3;\n        won3 = WondersContract3(_wonders3);\n        wonders4 = _wonders4;\n        won4 = WondersContract4(_wonders4);\n        treasury = _treasury;\n        tsy = TreasuryContract(_treasury);\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        bonusResources = _bonusResources;\n        bonus = BonusResourcesContract(_bonusResources);\n        crime = _crime;\n        crim = CrimeContract(_crime);\n    }\n\n    ///@dev this is a public function that is only callable by the nation owner\n    ///@notice this function will allow a nation owner to purchase technology\n    ///@param id this is the nation id of the nation buying technology\n    ///@param amount this is the amount of technology being purchased\n    function buyTech(uint256 id, uint256 amount) public {\n        uint256 initialLiteracy = crim.getLiteracy(id);\n        bool owner = mint.checkOwnership(id, msg.sender);\n        require(owner, \"!nation owner\");\n        uint256 cost = getTechCost(id, amount);\n        inf.increaseTechnologyFromMarket(id, amount);\n        tsy.spendBalance(id, cost);\n        uint256 finalLiteracy = crim.getLiteracy(id);\n        if(initialLiteracy < 90 && finalLiteracy >= 90){\n            res.triggerForResources(id);\n        }\n        uint256 currentTechAmount = inf.getTechnologyCount(id);\n        if((currentTechAmount) < 10 && (currentTechAmount + amount) >= 10){\n            res.triggerForResources(id);\n        }\n        emit TechPurchased(id, amount, cost);\n    }\n\n    ///@dev this is a public view function taht will return the cost of a technology purchase\n    ///@notice this function will return the cost of a technology purchase\n    ///@param id is the nation id of the nation buying technology\n    ///@param amount is the amount of technology being purchased\n    ///@return uint256 is the cost of a technology purchase\n    function getTechCost(\n        uint256 id,\n        uint256 amount\n    ) public view returns (uint256) {\n        uint256 costPerLevel = getTechCostPerLevel(id);\n        uint256 cost = (costPerLevel * amount);\n        return cost;\n    }\n\n    ///@dev this is a public view function that will return the cost a nation has to pay for technology per level\n    ///@notice this function willreturn the cost a nation has to pay for technology per level\n    ///@param id is the nation id of the nation being queried\n    ///@return uint256 is the cost a nation has to pey for technology per level\n    function getTechCostPerLevel(uint256 id) public view returns (uint256) {\n        uint256 currentTechAmount = inf.getTechnologyCount(id);\n        uint256 baseCostPerLevel;\n        if (currentTechAmount < 5) {\n            baseCostPerLevel = 100 * (10 ** 18);\n        } else if (currentTechAmount < 8) {\n            baseCostPerLevel = 120 * (10 ** 18);\n        } else if (currentTechAmount < 10) {\n            baseCostPerLevel = 130 * (10 ** 18);\n        } else if (currentTechAmount < 15) {\n            baseCostPerLevel = 140 * (10 ** 18);\n        } else if (currentTechAmount < 30) {\n            baseCostPerLevel = 160 * (10 ** 18);\n        } else if (currentTechAmount < 50) {\n            baseCostPerLevel = 180 * (10 ** 18);\n        } else if (currentTechAmount < 75) {\n            baseCostPerLevel = 200 * (10 ** 18);\n        } else if (currentTechAmount < 100) {\n            baseCostPerLevel = 220 * (10 ** 18);\n        } else if (currentTechAmount < 150) {\n            baseCostPerLevel = 240 * (10 ** 18);\n        } else if (currentTechAmount < 200) {\n            baseCostPerLevel = 260 * (10 ** 18);\n        } else if (currentTechAmount < 250) {\n            baseCostPerLevel = 300 * (10 ** 18);\n        } else if (currentTechAmount < 300) {\n            baseCostPerLevel = 400 * (10 ** 18);\n        } else if (currentTechAmount < 400) {\n            baseCostPerLevel = 500 * (10 ** 18);\n        } else if (currentTechAmount < 500) {\n            baseCostPerLevel = 600 * (10 ** 18);\n        } else if (currentTechAmount < 600) {\n            baseCostPerLevel = 700 * (10 ** 18);\n        } else if (currentTechAmount < 700) {\n            baseCostPerLevel = 800 * (10 ** 18);\n        } else if (currentTechAmount < 1000) {\n            baseCostPerLevel = 1100 * (10 ** 18);\n        } else if (currentTechAmount < 2000) {\n            baseCostPerLevel = 1600 * (10 ** 18);\n        } else if (currentTechAmount < 3000) {\n            baseCostPerLevel = 2100 * (10 ** 18);\n        } else if (currentTechAmount < 4000) {\n            baseCostPerLevel = 2600 * (10 ** 18);\n        } else if (currentTechAmount < 5000) {\n            baseCostPerLevel = 3100 * (10 ** 18);\n        } else if (currentTechAmount < 6000) {\n            baseCostPerLevel = 3600 * (10 ** 18);\n        } else if (currentTechAmount < 7000) {\n            baseCostPerLevel = 4100 * (10 ** 18);\n        } else if (currentTechAmount < 8000) {\n            baseCostPerLevel = 4600 * (10 ** 18);\n        } else if (currentTechAmount < 9000) {\n            baseCostPerLevel = 5100 * (10 ** 18);\n        } else if (currentTechAmount < 10000) {\n            baseCostPerLevel = 5600 * (10 ** 18);\n        } else if (currentTechAmount < 15000) {\n            baseCostPerLevel = 6600 * (10 ** 18);\n        } else if (currentTechAmount < 20000) {\n            baseCostPerLevel = 7600 * (10 ** 18);\n        } else {\n            baseCostPerLevel = 8600 * (10 ** 18);\n        }\n        uint256 costMultiplier = getTechCostMultiplier(id);\n        uint256 costPerLevel = ((baseCostPerLevel * costMultiplier) / 100);\n        return costPerLevel;\n    }\n\n    ///@dev this function will adjust a nations tech cost based on wonders improvements and resources\n    function getTechCostMultiplier(uint256 id) public view returns (uint256) {\n        uint256 numberToSubtract = 0;\n        bool isGold = res.viewGold(id);\n        bool isMicrochips = bonus.viewMicrochips(id);\n        uint256 universityCount = imp3.getUniversityCount(id);\n        bool greatUniversity = won2.getGreatUniversity(id);\n        bool isSpaceProgram = won4.getSpaceProgram(id);\n        bool isNationalResearchLab = won3.getNationalResearchLab(id);\n        if (isGold) {\n            numberToSubtract += 5;\n        }\n        if (isMicrochips) {\n            numberToSubtract += 8;\n        }\n        if (universityCount > 0) {\n            numberToSubtract += (universityCount * 10);\n        }\n        if (greatUniversity) {\n            numberToSubtract += 10;\n        }\n        if (isNationalResearchLab) {\n            numberToSubtract += 3;\n        }\n        if (isSpaceProgram) {\n            numberToSubtract += 3;\n        }\n        uint256 multiplier = (100 - numberToSubtract);\n        return multiplier;\n    }\n\n    ///@dev this function allows a nation to destroy technology\n    function destroyTech(uint256 id, uint256 amount) public {\n        bool owner = mint.checkOwnership(id, msg.sender);\n        require(owner, \"!nation owner\");\n        uint256 currentTech = inf.getTechnologyCount(id);\n        require((currentTech - amount) >= 0, \"not enough tech\");\n        inf.decreaseTechnologyFromMarket(id, amount);\n        emit TechDestroyed(id, amount);\n    }\n}\n"
    },
    "contracts/Treasury.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./IWarBucks.sol\";\nimport \"./WarBucks.sol\";\nimport \"./Wonders.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Forces.sol\";\nimport \"./Navy.sol\";\nimport \"./Fighters.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./GroundBattle.sol\";\nimport \"./KeeperFile.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n///@title TreasuyContract\n///@author OxSnosh\n///@dev this contract allows a nation owner to withdraw game revenues from their nation\n///@dev this contract allows a nation owner to deposit game revenues into their nation\n///@dev this contract inherits from the openzeppelin ownable contract\n///@dev this contract allows the game owner to set the MILF and withdraw game revenues\ncontract TreasuryContract is Ownable {\n    uint256 public totalGameBalance;\n    uint256 public counter;\n    address public wonders1;\n    address public wonders2;\n    address public wonders3;\n    address public wonders4;\n    address public improvements1;\n    address public improvements2;\n    address public improvements3;\n    address public improvements4;\n    address public infrastructure;\n    address public navy;\n    address public navy2;\n    address public fighters;\n    address public bombers;\n    address public fightersMarket1;\n    address public fightersMarket2;\n    address public bombersMarket1;\n    address public bombersMarket2;\n    address public warBucksAddress;\n    address public forces;\n    address public spies;\n    address public missiles;\n    address public aid;\n    address public taxes;\n    address public bills;\n    address public spyOperations;\n    address public groundBattle;\n    address public countryMinter;\n    address public landMarket;\n    address public techMarket;\n    address public infrastructureMarket;\n    address public keeper;\n    address public parameters;\n    uint256 public daysToInactive = 30;\n    uint256 public maxDaysOfTaxes = 20;\n    uint256 private milf = 0;\n    uint256 public seedMoney = 2000000 * (10 ** 18);\n\n    CountryMinter mint;\n    GroundBattleContract ground;\n    KeeperContract keep;\n\n    struct Treasury {\n        uint256 dayOfLastBillPaid;\n        uint256 dayOfLastTaxCollection;\n        uint256 balance;\n        bool demonitized;\n    }\n\n    mapping(uint256 => Treasury) public idToTreasury;\n\n    event FundsWithdrawn(\n        uint256 countryId,\n        uint256 amount\n    );\n\n    event FundsAdded(\n        uint256 countryId,\n        uint256 amount\n    );\n\n    event OwnerWithdrawMilfRevenues(\n        uint256 amount\n    );\n\n    event SeedMoneyUpdated(\n        uint256 newSeedMoney\n    );\n\n    event SpoilsTransferred(\n        uint256 attackerId,\n        uint256 defenderId,\n        uint256 fundsTransferred\n    );\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings1(\n        address _warBucksAddress,\n        address _wonders1,\n        address _wonders2,\n        address _wonders3,\n        address _wonders4,\n        address _improvements1,\n        address _improvements2,\n        address _improvements3,\n        address _improvements4,\n        address _infrastructure\n    ) public onlyOwner {\n        warBucksAddress = _warBucksAddress;\n        wonders1 = _wonders1;\n        wonders2 = _wonders2;\n        wonders3 = _wonders3;\n        wonders4 = _wonders4;\n        improvements1 = _improvements1;\n        improvements2 = _improvements2;\n        improvements3 = _improvements3;\n        improvements4 = _improvements4;\n        infrastructure = _infrastructure;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings2(\n        address _groundBattle,\n        address _countryMinter,\n        address _keeper,\n        address _forces,\n        address _navy,\n        address _fighters,\n        address _bombers,\n        address _aid,\n        address _taxes,\n        address _bills,\n        address _spyOperations\n    ) public onlyOwner {\n        groundBattle = _groundBattle;\n        ground = GroundBattleContract(_groundBattle);\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        keeper = _keeper;\n        keep = KeeperContract(_keeper);\n        forces = _forces;\n        navy = _navy;\n        fighters = _fighters;\n        bombers = _bombers;\n        aid = _aid;\n        taxes = _taxes;\n        bills = _bills;\n        spyOperations = _spyOperations;\n    }\n\n    function settings3(\n        address _navy2,\n        address _missiles,\n        address _infrastructureMarket,\n        address _landMarket,\n        address _techMarket,\n        address _fightersMarket1,\n        address _fightersMarket2,\n        address _bombersMarket1,\n        address _bombersMarket2,\n        address _parameters,\n        address _spies\n    ) public onlyOwner {\n        navy2 = _navy2;\n        missiles = _missiles;\n        infrastructureMarket = _infrastructureMarket;\n        landMarket = _landMarket;\n        techMarket = _techMarket;\n        fightersMarket1 = _fightersMarket1;\n        fightersMarket2 = _fightersMarket2;\n        bombersMarket1 = _bombersMarket1;\n        bombersMarket2 = _bombersMarket2;\n        parameters = _parameters;\n        spies = _spies;\n    }\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"function only callable from country minter contract\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable from the country minter contract\n    ///@notice this function will be called when a nation is minted and will allow a nation to undergo treasury operations\n    ///@param id is the nation id of the nation being minted\n    function generateTreasury(uint256 id) public onlyCountryMinter {\n        uint256 gameDay = keep.getGameDay();\n        Treasury memory newTreasury = Treasury(\n            gameDay,\n            gameDay,\n            0,\n            false\n        );\n        idToTreasury[id] = newTreasury;\n        idToTreasury[id].balance += seedMoney;\n        totalGameBalance += seedMoney;\n        counter++;\n    }\n\n    ///@dev this is a public view function that will return a nations in game balance\n    ///@notice this function will return a given nations in game balance\n    ///@param id is the nation id of the nation being queries\n    ///@return uint256 is the balance of war bucks for the nation\n    function checkBalance(uint256 id) public view returns (uint256) {\n        return idToTreasury[id].balance;\n    }\n\n    ///@dev this function is only callable from a nation owner\n    ///@dev this function allows a nation owner to withdraw funds from their nation\n    ///@notice this function allows a nation owner to withdraw funds from their nation\n    ///@param amount is the amount of funds being withdrawn\n    ///@param id is the nation id of the nation withdrawing funds\n    function withdrawFunds(uint256 amount, uint256 id) public {\n        uint256 gameBalance = idToTreasury[id].balance;\n        require(gameBalance >= amount, \"insufficient game balance\");\n        idToTreasury[id].balance -= amount;\n        totalGameBalance -= amount;\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 gameDay = keep.getGameDay();\n        uint256 daysOfBillsPaid = idToTreasury[id].dayOfLastBillPaid;\n        require(\n            daysOfBillsPaid == gameDay,\n            \"pay bills before withdrawing funds\"\n        );\n        bool demonitized = idToTreasury[id].demonitized;\n        require(demonitized == false, \"ERROR\");\n        IWarBucks(warBucksAddress).mintFromTreasury(msg.sender, amount);\n        emit FundsWithdrawn(id, amount);\n    }\n\n    ///@dev this function is only callable from a nation owner\n    ///@dev this function allows a nation owner to add funds to their nation\n    ///@notice this function allows a nation owner to add funds to their nation\n    ///@param amount is the amount of funds being added\n    ///@param id is the nation id of the nation withdrawing funds\n    function addFunds(uint256 amount, uint256 id) public {\n        uint256 coinBalance = IWarBucks(warBucksAddress).balanceOf(msg.sender);\n        require(\n            coinBalance >= amount,\n            \"deposit amount exceeds balance in wallet\"\n        );\n        idToTreasury[id].balance += amount;\n        totalGameBalance += amount;\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        bool demonitized = idToTreasury[id].demonitized;\n        require(demonitized == false, \"ERROR\");\n        IWarBucks(warBucksAddress).burnFromTreasury(msg.sender, amount);\n        emit FundsAdded(id, amount);\n    }\n\n    ///@dev this funtion is a public view function that will return the number of days it has been since a nation has collected taxes\n    ///@notice this funtion will return the number of days it has been since a nation has collected taxes\n    ///@param id is the nation id of the nation being queried\n    ///@return uint256 is the number of days since a nation has collected taxes\n    function getDaysSinceLastTaxCollection(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 gameDay = keep.getGameDay();\n        uint256 dayOfLastBillPaid = idToTreasury[id].dayOfLastTaxCollection;\n        uint256 daysSince = (gameDay - dayOfLastBillPaid);\n        if (daysSince > maxDaysOfTaxes) {\n            daysSince = maxDaysOfTaxes;\n        }\n        return daysSince;\n    }\n\n    function getMaxDaysOfTaxes() public view returns (uint256) {\n        return maxDaysOfTaxes;\n    }\n\n    function setMaxDaysOfTaxes(uint256 newMaxDays) public onlyOwner {\n        maxDaysOfTaxes = newMaxDays;\n    }\n\n    modifier onlyTaxesContract() {\n        require(msg.sender == taxes, \"only callable from taxes contract\");\n        _;\n    }\n\n    ///@dev this function is only callable by the taxes contract\n    ///@dev this function will increase a nations balance when taxes are collected\n    ///@param id this is the nation id of the country collecting taxes\n    ///@param amount this is the amount of taxes being collected\n    function increaseBalanceOnTaxCollection(\n        uint256 id,\n        uint256 amount\n    ) public onlyTaxesContract {\n        idToTreasury[id].balance += amount;\n        totalGameBalance += amount;\n        uint256 day = keep.getGameDay();\n        idToTreasury[id].dayOfLastTaxCollection = day;\n    }\n\n    ///@dev this funtion is a public view function that will return the number of days it has been since a nation has paid bills\n    ///@notice this funtion will return the number of days it has been since a nation has paid bills\n    ///@param id is the nation id of the nation being queried\n    ///@return uint256 is the number of days since a nation has paid bills\n    function getDaysSinceLastBillsPaid(\n        uint256 id\n    ) public view returns (uint256) {\n        uint256 gameDay = keep.getGameDay();\n        uint256 dayOfLastBillPaid = idToTreasury[id].dayOfLastBillPaid;\n        uint256 daysSince = (gameDay - dayOfLastBillPaid);\n        if (daysSince > daysToInactive) {\n            daysSince = daysToInactive;\n        }\n        return daysSince;\n    }\n\n    modifier onlyBillsContract() {\n        require(msg.sender == bills, \"only callable from taxes contract\");\n        _;\n    }\n\n    ///@dev this function is only callable from the bills contract\n    ///@dev this function will decrease a nations balance when bils are paid\n    ///@param id is the nation id of the nation paying bills\n    ///@param amount is the amount of bills being paid\n    function decreaseBalanceOnBillsPaid(\n        uint256 id,\n        uint256 amount\n    ) public onlyBillsContract {\n        require(\n            idToTreasury[id].balance >= amount,\n            \"balance not high enough to pay bills\"\n        );\n        idToTreasury[id].balance -= amount;\n        totalGameBalance -= amount;\n        uint256 day = keep.getGameDay();\n        idToTreasury[id].dayOfLastBillPaid = day;\n    }\n\n    ///@dev this is a public view function that will return if a nation is inactive\n    ///@notice this function will retun if a nation is inactive\n    ///@param id is the nation id of the nation being queried\n    ///@return bool will be true if the nation is inactive\n    function checkInactive(uint256 id) public view returns (bool) {\n        uint256 day = keep.getGameDay();\n        uint256 dayBillsPaid = idToTreasury[id].dayOfLastBillPaid;\n        uint256 elapsed = (day - dayBillsPaid);\n        bool inactive = false;\n        if (elapsed > daysToInactive) {\n            inactive = true;\n        }\n        return inactive;\n    }\n\n    ///@dev this function is only callable from the contract owner\n    ///@dev this function will allow the contract owner to set the number of days a nation cannot pay bill until it becomes inactive\n    ///@notice this function will allow the contract owner to set the number of days a nation cannot pay bill until it becomes inactive\n    function setDaysToInactive(uint256 newDays) public onlyOwner {\n        daysToInactive = newDays;\n    }\n\n    function getDaysToInactive() public view returns (uint256) {\n        return daysToInactive;\n    }\n\n    modifier approvedBalanceSpender() {\n        require(\n            msg.sender == bombers ||\n                msg.sender == bombersMarket1 ||\n                msg.sender == bombersMarket2 ||\n                msg.sender == fightersMarket1 ||\n                msg.sender == fightersMarket2 ||\n                msg.sender == fighters ||\n                msg.sender == forces ||\n                msg.sender == missiles ||\n                msg.sender == navy ||\n                msg.sender == navy2 ||\n                msg.sender == improvements1 ||\n                msg.sender == improvements2 ||\n                msg.sender == improvements3 ||\n                msg.sender == improvements4 ||\n                msg.sender == wonders1 ||\n                msg.sender == wonders2 ||\n                msg.sender == wonders3 ||\n                msg.sender == wonders4 ||\n                msg.sender == infrastructureMarket ||\n                msg.sender == techMarket ||\n                msg.sender == landMarket ||\n                msg.sender == spyOperations ||\n                msg.sender == parameters ||\n                msg.sender == spies,\n            \"cannot call spendBalance()\"\n        );\n        _;\n    }\n\n    ///@dev this function is public but only callable by contracts within the game where funds are being spent\n    ///@dev this function will decrease a nation owner's balance when money is spent within the game\n    ///@notice this function will decrease a nation owner's balance when money is spent within the game\n    ///@param id is the nation id of the nation spending funds\n    ///@param cost is the cost of the expense\n    function spendBalance(\n        uint256 id,\n        uint256 cost\n    ) external approvedBalanceSpender {\n        uint256 balance = idToTreasury[id].balance;\n        require(balance >= cost, \"insufficient balance\");\n        idToTreasury[id].balance -= cost;\n        totalGameBalance -= cost;\n        bool demonitized = idToTreasury[id].demonitized;\n        require(demonitized == false, \"ERROR\");\n        bool inactive = checkInactive(id);\n        require(inactive == false, \"ERROR Inactive, pay bills to reactivate\");\n        //TAXES here\n        uint256 taxLevied = ((cost * milf) / 100);\n        if (taxLevied > 0) {\n            IWarBucks(warBucksAddress).mintFromTreasury(\n                address(this),\n                taxLevied\n            );\n        }\n    }\n\n    ///@dev this function will show the balance of warbucks within the contract\n    ///@dev when money is spent within the game it can be taxed an deposited within this contract\n    function viewMilfRevenues() public view returns (uint256) {\n        return (WarBucks(warBucksAddress).balanceOf(address(this)));\n    }\n\n    ///@dev when money is spent within the game it can be taxed an deposited within this contract\n    ///@dev this function will allow the contract owner to withdraw the warbucks from this contract into the owners wallet\n    function withdrawMilfRevenues(uint256 amount) public onlyOwner {\n        WarBucks(warBucksAddress).approve(address(this), amount);\n        WarBucks(warBucksAddress).transferFrom(\n            address(this),\n            msg.sender,\n            amount\n        );\n        emit OwnerWithdrawMilfRevenues(amount);\n    }\n\n    ///@notice the seed money is the amount of warbucks that a nation owner will need to have in their wallet when the nation is minted \n    ///@dev when a nation is minted the seed money is deposited into the nations balance and the warbucks are burned\n    ///@param newSeedMoney is the new amount of warbucks that a nation owner will need to have in their wallet when the nation is minted\n    function updateSeedMoney(uint256 newSeedMoney) public onlyOwner {\n        seedMoney = (newSeedMoney * (10 ** 18));\n        emit SeedMoneyUpdated(newSeedMoney);\n    }\n\n    ///@notice this function will return the seed money that is required to mint a nation\n    ///@notice seed money is the amount of warbuck a nation will need to have in their wallet when the nation is minted\n    ///@dev when a nation is minted the seed money is deposited into the nations balance and the warucks are burned\n    ///@return uint256 is the seed money required to mint a nation\n    function getSeedMoney() public view returns (uint256) {\n        return seedMoney;\n    }\n\n    ///@dev this function allows the contract owner to set the tax rate in game purchases are taxed at\n    ///@dev the tax rate will be the % of the purchase price that is minted into this contract that can be withdrawn later\n    function setMilf(uint256 newPercentage) public onlyOwner {\n        milf = newPercentage;\n    }\n\n    ///@dev this funtion will reuturn the game tax rate\n    ///@return uint256 will be the tax rate at which purchases in the game are taxed at\n    function getMilf() public view returns (uint256) {\n        return milf;\n    }\n\n    function demonetizeNation(uint256 id) public onlyOwner {\n        idToTreasury[id].demonitized = true;\n    }\n\n    function remonetizeNation(uint256 id) public onlyOwner {\n        idToTreasury[id].demonitized = false;\n    }\n\n    function isNationDemonetized(uint256 id) public view returns (bool) {\n        return idToTreasury[id].demonitized;\n    }\n\n    function getTotalGameBalance() public view returns (uint256) {\n        return totalGameBalance;\n    }\n\n    modifier onlySpyContract() {\n        require(msg.sender == spyOperations, \"only callable from spy contract\");\n        _;\n    }\n\n    ///@dev this function is only callable from the spy contract\n    ///@dev this function will allow the spy contract to transfer a nations balance to an attacking nation upon a successful spy attack\n    ///@param id is the nation id of the nation recieving the balance (receiving nation)\n    ///@param amount is the amount of balance being transferred\n    function destroyBalance(\n        uint256 id,\n        uint256 amount\n    ) public onlySpyContract {\n        idToTreasury[id].balance -= amount;\n    }\n\n    modifier onlyAidContract() {\n        require(msg.sender == aid);\n        _;\n    }\n\n    ///@dev this function is only callable from the aid contract\n    ///@dev this function will send the balance in an aid package from the sender nation to the recipient nation\n    ///@param idSender is the sender of an aid package\n    ///@param idRecipient is the recipient of an aid package\n    ///@param amount is the amount of balance being included in the aid package\n    function sendAidBalance(\n        uint256 idSender,\n        uint256 idRecipient,\n        uint256 amount\n    ) public onlyAidContract {\n        uint256 balance = idToTreasury[idSender].balance;\n        require(balance >= amount, \"not enough balance\");\n        idToTreasury[idSender].balance -= amount;\n        idToTreasury[idRecipient].balance += amount;\n    }\n\n    modifier onlyGroundBattle() {\n        require(\n            msg.sender == groundBattle,\n            \"function only callable from ground battle\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable from the ground battle contract\n    ///@dev this function will transfer the balance lost in a ground battle to the winning nation\n    ///@param randomNumber is the amount of balance being transferred\n    ///@param attackerId is the nation id of the attacking nation\n    ///@param defenderId is the nation id of the defending nation\n    function transferSpoils(\n        uint256 randomNumber,\n        uint256 battleId,\n        uint256 attackerId,\n        uint256 defenderId\n    ) public onlyGroundBattle {\n        uint256 defenderBalance = idToTreasury[defenderId].balance;\n        (\n            ,\n            ,\n            ,\n            ,\n            uint256 defenderSoldierLosses,\n            uint256 defenderTankLosses\n        ) = ground.returnBattleResults(battleId);\n        uint256 maximumFundsToTransfer = ((defenderSoldierLosses * 4) +\n            (defenderTankLosses * 150) * (10**18));\n        uint256 fundsToTransfer = ((defenderBalance * randomNumber) / 100);\n        if (fundsToTransfer >= maximumFundsToTransfer) {\n            fundsToTransfer = maximumFundsToTransfer;\n        }\n        if (fundsToTransfer < (1000000 * (10**18))) {\n            idToTreasury[attackerId].balance += fundsToTransfer;\n        } else {\n            idToTreasury[attackerId].balance += (1000000 * (10**18));\n            fundsToTransfer = (1000000 * (10**18));\n        }\n        emit SpoilsTransferred(\n            attackerId,\n            defenderId,\n            fundsToTransfer\n        );\n    }\n\n    modifier onlyInfrastructure() {\n        require(\n            msg.sender == infrastructure,\n            \"only callable from infrastructure contract\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable from the infrastructure contract\n    ///@dev this function will compensate a nation when they sell land, tech or infrastructure\n    function returnBalance(uint256 id, uint256 cost) public onlyInfrastructure {\n        //need a way to only allow the nation owner to do this\n        idToTreasury[id].balance += cost;\n    }\n}\n"
    },
    "contracts/War.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./NationStrength.sol\";\nimport \"./Military.sol\";\nimport \"./Wonders.sol\";\nimport \"./CountryMinter.sol\";\nimport \"./Treasury.sol\";\nimport \"./KeeperFile.sol\";\nimport \"./Forces.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"hardhat/console.sol\";\n\n// import \"hardhat/console.sol\";\n\n///@title WarContract\n///@author OxSnosh\n///@notice this contact will allow a naion owner to declare war on another nation\n///@dev this contract inherits from openzeppelin's ownable contract\ncontract WarContract is Ownable {\n    uint256 public warId;\n    address public countryMinter;\n    address public nationStrength;\n    address public military;\n    address public breakBlockade;\n    address public navalAttack;\n    address public airBattle;\n    address public groundBattle;\n    address public cruiseMissile;\n    address public blockade;\n    address public nuke;\n    address public forces;\n    address public wonders1;\n    address public keeper;\n    address public treasury;\n\n    NationStrengthContract nsc;\n    MilitaryContract mil;\n    WondersContract1 won1;\n    CountryMinter mint;\n    TreasuryContract tres;\n    KeeperContract keep;\n    ForcesContract forc;\n\n    struct War {\n        uint256 offenseId;\n        uint256 defenseId;\n        bool active;\n        uint256 dayStarted;\n        bool peaceDeclared;\n        bool offensePeaceOffered;\n        bool defensePeaceOffered;\n        uint256 offenseBlockades;\n        uint256 defenseBlockades;\n        mapping(uint256 => uint256) offenseIdToCruiseMissileLaunchesToday;\n        mapping(uint256 => uint256) defenseIdToCruiseMissileLaunchesToday;\n    }\n\n\n    struct OffenseDeployed1 {\n        mapping(uint256 => bool) offenseDeployedToday;\n        uint256 soldiersDeployed;\n        uint256 tanksDeployed;\n    }\n\n    struct DefenseDeployed1 {\n        mapping(uint256 => bool) defenseDeployedToday;\n        uint256 soldiersDeployed;\n        uint256 tanksDeployed;\n    }\n\n    struct OffenseLosses {\n        uint256 warId;\n        uint256 nationId;\n        uint256 soldiersLost;\n        uint256 tanksLost;\n        uint256 cruiseMissilesLost;\n        uint256 aircraftLost;\n        uint256 navyStrengthLost;\n        uint256 infrastructureLost;\n        uint256 technologyLost;\n        uint256 landLost;\n    }\n\n    struct DefenseLosses {\n        uint256 warId;\n        uint256 nationId;\n        uint256 soldiersLost;\n        uint256 tanksLost;\n        uint256 cruiseMissilesLost;\n        uint256 aircraftLost;\n        uint256 navyStrengthLost;\n        uint256 infrastructureLost;\n        uint256 technologyLost;\n        uint256 landLost;\n    }\n\n    mapping(uint256 => War) public warIdToWar;\n    mapping(uint256 => OffenseDeployed1) public warIdToOffenseDeployed1;\n    mapping(uint256 => DefenseDeployed1) public warIdToDefenseDeployed1;\n    mapping(uint256 => OffenseLosses) public warIdToOffenseLosses;\n    mapping(uint256 => DefenseLosses) public warIdToDefenseLosses;\n    mapping(uint256 => uint256[]) public idToActiveWars;\n    mapping(uint256 => uint256[]) public idToOffensiveWars;\n    mapping(uint256 => uint256[]) public idToDeactivatedWars;\n\n    event WarDeclared(\n        uint256 indexed warId,\n        uint256 indexed offenseId,\n        uint256 indexed defenseId\n    );\n\n    event PeaceOffered(\n        uint256 indexed warId,\n        uint256 indexed offeredBy\n    );\n\n    event PeaceDeclared(\n        uint256 indexed warId,\n        uint256 indexed offenseId,\n        uint256 indexed defenseId\n    );\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _countryMinter,\n        address _nationStrength,\n        address _military,\n        address _breakBlockadeAddress,\n        address _navalAttackAddress,\n        address _airBattleAddress,\n        address _groundBattle,\n        address _cruiseMissile,\n        address _forces,\n        address _wonders1,\n        address _keeper\n    ) public onlyOwner {\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n        nationStrength = _nationStrength;\n        breakBlockade = _breakBlockadeAddress;\n        navalAttack = _navalAttackAddress;\n        airBattle = _airBattleAddress;\n        groundBattle = _groundBattle;\n        nsc = NationStrengthContract(_nationStrength);\n        military = _military;\n        mil = MilitaryContract(_military);\n        cruiseMissile = _cruiseMissile;\n        forces = _forces;\n        wonders1 = _wonders1;\n        won1 = WondersContract1(_wonders1);\n        keeper = _keeper;\n        keep = KeeperContract(_keeper);\n    }\n\n    function settings2(address _treasury, address _forces, address _blockade, address _nuke) public onlyOwner {\n        treasury = _treasury;\n        tres = TreasuryContract(_treasury);\n        forces = _forces;\n        forc = ForcesContract(_forces);\n        blockade = _blockade;\n        nuke = _nuke;\n    }\n\n    modifier onlyCruiseMissileContract() {\n        require(\n            msg.sender == cruiseMissile,\n            \"only callable from cruise missile contract\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable from a nation owner and allow a natio nto eclare war on another nation\n    ///@notice this function allows a nation to declare war on another nation\n    ///@notice when war is declared the nations can attack each other\n    ///@param offenseId is the nation id of the nation declaring war\n    ///@param defenseId is the nation id of the nation having war declared on it\n    ///@notice a nation can only have a maximum of 4 offensive wars (5 with a foreign army base)\n    function declareWar(uint256 offenseId, uint256 defenseId) public {\n        bool isOwner = mint.checkOwnership(offenseId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        bool check = warCheck(offenseId, defenseId);\n        require(check, \"war not possible\");\n        uint day = keep.getGameDay();\n        War storage war = warIdToWar[warId];\n            war.offenseId = offenseId;\n            war.defenseId = defenseId;\n            war.active = true;\n            war.dayStarted = day;\n            war.peaceDeclared = false;\n            war.offensePeaceOffered = false;\n            war.defensePeaceOffered = false;\n        OffenseLosses memory newOffenseLosses = OffenseLosses(\n            warId,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        );\n        warIdToOffenseLosses[warId] = newOffenseLosses;\n        DefenseLosses memory newDefenseLosses = DefenseLosses(\n            warId,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        );\n        warIdToDefenseLosses[warId] = newDefenseLosses;\n        uint256[] storage offensiveWars = idToOffensiveWars[offenseId];\n        uint256 maxOffensiveWars = 4;\n        bool foreignArmyBase = won1.getForeignArmyBase(offenseId);\n        if (foreignArmyBase) {\n            maxOffensiveWars = 5;\n        }\n        offensiveWars.push(warId);\n        require(\n            offensiveWars.length <= maxOffensiveWars,\n            \"you do not have an offensive war slot available\"\n        );\n        uint256[] storage offenseActiveWars = idToActiveWars[offenseId];\n        offenseActiveWars.push(warId);\n        uint256[] storage defenseActiveWars = idToActiveWars[defenseId];\n        defenseActiveWars.push(warId);\n        initializeDeployments(warId);\n        emit WarDeclared(warId, offenseId, defenseId);\n        warId++;\n    }\n\n    function warCheck(\n        uint256 offenseId,\n        uint256 defenseId\n    ) internal view returns (bool) {\n        bool warCheckReturn = false;\n        (bool isWarOkOffense,) = mil.getWarPeacePreference(offenseId);\n        require(isWarOkOffense == true, \"you are in peace mode\");\n        (bool isWarOkDefense,) = mil.getWarPeacePreference(defenseId);\n        require(isWarOkDefense == true, \"nation in peace mode\");\n        bool isStrengthWithinRange = checkStrength(offenseId, defenseId);\n        require(\n            isStrengthWithinRange == true,\n            \"nation strength is not within range to declare war\"\n        );\n        bool defenderInactive = tres.checkInactive(defenseId);\n        require(!defenderInactive, \"defender inactive\");\n        bool offenseInactive = tres.checkInactive(offenseId);\n        require(!offenseInactive, \"nation inactive\");\n        uint256[] memory activeWars = idToActiveWars[offenseId];\n        for (uint256 i = 0; i < activeWars.length; i++) {\n            uint256 war = activeWars[i];\n            (uint256 offense, uint256 defense) = getInvolvedParties(war);\n            require(\n                offense != defenseId && defense != defenseId,\n                \"already at war with this nation\"\n            );\n        }\n        warCheckReturn = true;\n        return warCheckReturn;\n    }\n\n    function offensiveWarLength(\n        uint256 offenseId\n    ) public view returns (uint256) {\n        uint256[] memory offensiveWars = idToOffensiveWars[offenseId];\n        return offensiveWars.length;\n    }\n\n    function offensiveWarReturn(\n        uint256 offenseId\n    ) public view returns (uint256[] memory) {\n        uint256[] memory offensiveWars = idToOffensiveWars[offenseId];\n        return offensiveWars;\n    }\n\n    function nationActiveWarsReturn(\n        uint256 offenseId\n    ) public view returns (uint256[] memory) {\n        uint256[] memory activeWarsArray = idToActiveWars[offenseId];\n        return activeWarsArray;\n    }\n\n    ///@dev this is an internal function that will be balled by the declare war function and set up several structs that will keep track of each war\n    function initializeDeployments(uint256 _warId) internal {\n        OffenseDeployed1 storage newOffenseDeployed1 = warIdToOffenseDeployed1[_warId];\n            newOffenseDeployed1.soldiersDeployed = 0;\n            newOffenseDeployed1.tanksDeployed = 0;\n        DefenseDeployed1 storage newDefenseDeployed1 = warIdToDefenseDeployed1[_warId];\n            newDefenseDeployed1.soldiersDeployed = 0;\n            newDefenseDeployed1.tanksDeployed = 0;\n    }\n\n    ///@dev this is a public view function that will return a boolean value if the nations are able to fight eachother\n    ///@notice this function will return a boolean value of true if the nations are able to fight eachother\n    ///@notice in order for a war to be declared the offense strength must be within 75% and 133% of the defending nation\n    ///@param offenseId is the nation id of the aggressor nation\n    ///@param defenseId if the nation id of the defending nation\n    ///@return bool will be true if the nations are within range where war is possible\n    function checkStrength(\n        uint256 offenseId,\n        uint256 defenseId\n    ) public view returns (bool) {\n        uint256 offenseStrength = nsc.getNationStrength(offenseId);\n        uint256 defenseStrength = nsc.getNationStrength(defenseId);\n        uint256 strengthRatio = ((offenseStrength * 100) / defenseStrength);\n        if (strengthRatio < 75) {\n            return false;\n        } else if (strengthRatio > 133) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    ///@dev this is a public function that will allow a nation involved in a war to offer peace\n    ///@notice this funtion will allow a nation involved in a war to offer peace\n    ///@param offerId is the nation offering peace\n    ///@param _warId is the war id for the war where peace is being offered\n    ///@notice if the offense and the defense offer peace then peace will be declares\n    ///@notice an attack will nullify any existing peace offers\n    function offerPeace(uint256 offerId, uint256 _warId) public {\n        bool isOwner = mint.checkOwnership(offerId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256 offenseNation = warIdToWar[_warId].offenseId;\n        uint256 defenseNation = warIdToWar[_warId].defenseId;\n        require(\n            offerId == offenseNation || offerId == defenseNation,\n            \"nation not involved in this war\"\n        );\n        if (offerId == offenseNation) {\n            warIdToWar[_warId].offensePeaceOffered = true;\n        }\n        if (offerId == defenseNation) {\n            warIdToWar[_warId].defensePeaceOffered = true;\n        }\n        emit PeaceOffered(_warId, offerId);\n        bool offensePeaceCheck = warIdToWar[_warId].offensePeaceOffered;\n        bool defensePeaceCheck = warIdToWar[_warId].defensePeaceOffered;\n        if (offensePeaceCheck == true && defensePeaceCheck == true) {\n            warIdToWar[_warId].peaceDeclared = true;\n            warIdToWar[_warId].active = false;\n            emit PeaceDeclared(_warId, offenseNation, defenseNation);\n            removeActiveWar(_warId);\n        }\n    }\n\n    ///@dev this is a public view function that will return information about a war\n    ///@notice this function will return information about a war\n    ///@param _warId is the war id of the war being queried\n    ///@return offensePeaceOffered is a boolean value that will be true if the offense offered peace\n    ///@return defensePeaceOffered is a boolean value that will be true if the defense nation offered peace\n    ///@return warActive will return a boolean true if the war is still active\n    ///@return peaceDeclared will return a boolean true of peace was declared by both sides\n    function returnWar(\n        uint256 _warId\n    ) public view returns (bool, bool, bool, bool) {\n        bool offensePeaceOffered = warIdToWar[_warId].offensePeaceOffered;\n        bool defensePeaceOffered = warIdToWar[_warId].defensePeaceOffered;\n        bool warActive = warIdToWar[_warId].active;\n        bool peaceDeclared = warIdToWar[_warId].peaceDeclared;\n        return (\n            offensePeaceOffered,\n            defensePeaceOffered,\n            warActive,\n            peaceDeclared\n        );\n    }\n\n    function returnWarDetails(uint256 _warId) public view returns (uint256, uint256, bool, uint256, bool, bool, bool, uint256, uint256) {\n        War storage war = warIdToWar[_warId];\n        return (\n            war.offenseId,\n            war.defenseId,\n            war.active,\n            war.dayStarted,\n            war.peaceDeclared,\n            war.offensePeaceOffered,\n            war.defensePeaceOffered,\n            war.offenseBlockades,\n            war.defenseBlockades\n        );\n    }\n\n    ///@dev this is an internal function that will remove the active war from each nation when peace is declared or the war expires\n    function removeActiveWar(uint256 _warId) internal {\n        (uint256 offenseId, uint256 defenseId) = getInvolvedParties(_warId);\n        uint256[] storage offenseActiveWars = idToActiveWars[offenseId];\n        uint256[] storage offenseDeactivatedWars = idToDeactivatedWars[offenseId];\n        for (uint256 i = 0; i < offenseActiveWars.length; i++) {\n            if (offenseActiveWars[i] == _warId) {\n                offenseDeactivatedWars.push(_warId);\n                offenseActiveWars[i] = offenseActiveWars[\n                    offenseActiveWars.length - 1\n                ];\n                offenseActiveWars.pop();\n            }\n        }\n        uint256[] storage offensiveWars = idToOffensiveWars[offenseId];\n        for (uint256 i = 0; i < offensiveWars.length; i++) {\n            if (offensiveWars[i] == _warId) {\n                offensiveWars[i] = offensiveWars[offensiveWars.length - 1];\n                offensiveWars.pop();\n            }\n        }\n        uint256[] storage defenseActiveWars = idToActiveWars[defenseId];\n        uint256[] storage defenseDeactivatedWars = idToDeactivatedWars[defenseId];\n        for (uint256 i = 0; i < defenseActiveWars.length; i++) {\n            if (defenseActiveWars[i] == _warId) {\n                defenseDeactivatedWars.push(_warId);\n                defenseActiveWars[i] = defenseActiveWars[\n                    defenseActiveWars.length - 1\n                ];\n                defenseActiveWars.pop();\n            }\n        }\n        warIdToWar[_warId].active = false;\n    }\n\n    modifier onlyNavyBattle() {\n        require(\n            msg.sender == breakBlockade ||\n                msg.sender == navalAttack,\n            \"function only callable from navy battle contract\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable from the navy battle contract and will increment navy casualties\n    function addNavyCasualties(\n        uint256 _warId,\n        uint256 nationId,\n        uint256 navyCasualties\n    ) public onlyNavyBattle {\n        (uint256 offenseId, uint256 defenseId) = getInvolvedParties(_warId);\n        if (offenseId == nationId) {\n            warIdToOffenseLosses[_warId].navyStrengthLost = navyCasualties;\n        }\n        if (defenseId == nationId) {\n            warIdToDefenseLosses[_warId].navyStrengthLost = navyCasualties;\n        }\n    }\n\n    ///@dev this function is only callable from the cruise missile contract and will only allow a nation to launch 2 cruise missiles per war per day\n    ///@notice this function will only allow a nation to launch 2 cruise missiles per war per day\n    function incrementCruiseMissileAttack(\n        uint256 _warId,\n        uint256 nationId\n    ) public onlyCruiseMissileContract {\n        (uint256 offenseId, uint256 defenseId) = getInvolvedParties(_warId);\n        uint256 day = keep.getGameDay();\n        War storage war = warIdToWar[_warId];\n        if (nationId == offenseId) {\n            require(war.offenseIdToCruiseMissileLaunchesToday[day] < 2, \"too many launches today\");\n            war.offenseIdToCruiseMissileLaunchesToday[day] += 1;\n        } else if (nationId == defenseId) {\n            require(war.defenseIdToCruiseMissileLaunchesToday[day] < 2, \"too many launches today\");\n            war.defenseIdToCruiseMissileLaunchesToday[day] += 1;\n        }\n    }\n\n    function getCruiseMissileLaunchesToday(uint256 _warId, uint256 id) public view returns (uint256) {\n        (uint256 offenseId, uint256 defenseId) = getInvolvedParties(_warId);\n        uint256 day = keep.getGameDay();\n        uint256 launches;\n        War storage war = warIdToWar[_warId];\n        if (id == offenseId) {\n            launches = war.offenseIdToCruiseMissileLaunchesToday[day];\n        } else if (id == defenseId) {\n            launches = war.defenseIdToCruiseMissileLaunchesToday[day];\n        }\n        return launches;\n    }\n\n    ///@dev this is a public view function that will take a war id as a parameter and return whether the war is active or not\n    ///@notice this function will return whether a war is active or not\n    ///@param _warId is the warId being queries\n    ///@return bool will be true if the war is active\n    function isWarActive(uint256 _warId) public view returns (bool) {\n        bool isActive = true;\n        bool warDoesntExist = warIdToWar[_warId].active;\n        (, bool expired) = getDaysLeft(_warId);\n        bool peaceDeclared = warIdToWar[_warId].peaceDeclared;\n        if (expired == true || peaceDeclared == true) {\n            isActive = false;\n        } else if (warDoesntExist == false) {\n            isActive = false;\n        }\n        console.log(isActive, \"war active\");\n        return isActive;\n    }\n\n    ///@dev this is a public view function that will return the two members f a given warId\n    ///@param _warId is the warId of the war being queried\n    ///@return offenseId is the nation id of the offensive nation in the war\n    ///@return defenseId is the nation id of the defensive nation in the war\n    function getInvolvedParties(\n        uint256 _warId\n    ) public view returns (uint256, uint256) {\n        uint256 offenseId = warIdToWar[_warId].offenseId;\n        uint256 defenseId = warIdToWar[_warId].defenseId;\n        return (offenseId, defenseId);\n    }\n\n    ///@dev this is a public view function that will return true if one of the nations has offered peace\n    ///@notice this function will return true if one of the nations has offered peace\n    ///@param _warId is the war id of the war being queried\n    ///@return bool will be true if one of the nation has offered peace\n    function isPeaceOffered(uint256 _warId) public view returns (bool) {\n        bool peaceOffered = false;\n        if (\n            warIdToWar[_warId].offensePeaceOffered == true ||\n            warIdToWar[_warId].defensePeaceOffered == true\n        ) {\n            peaceOffered = true;\n        }\n        return peaceOffered;\n    }\n\n    modifier onlyBattle() {\n        require(\n            msg.sender == groundBattle ||\n                msg.sender == airBattle ||\n                msg.sender == navalAttack ||\n                msg.sender == breakBlockade ||\n                msg.sender == blockade ||\n                msg.sender == cruiseMissile ||\n                msg.sender == nuke,\n            \"function only callable dring an attack\"\n        );\n        _;\n    }\n\n    function cancelPeaceOffersUponAttack(uint256 _warId) public onlyBattle {\n        warIdToWar[_warId].offensePeaceOffered = false;\n        warIdToWar[_warId].defensePeaceOffered = false;\n    }\n\n    ///@dev this is a publci view function that will return the number of days left in a war\n    ///@dev wars expire after 7 days when days left == 0\n    function getDaysLeft(uint256 _warId) public view returns (uint256, bool) {\n        uint256 day = keep.getGameDay();\n        uint256 warDaysElapsed;\n        if (day >= warIdToWar[_warId].dayStarted + 7) {\n            warDaysElapsed = 7;\n        } else {\n            warDaysElapsed = day - warIdToWar[_warId].dayStarted;\n        }\n        uint256 daysLeft = (7 - warDaysElapsed);\n        bool expired = false;\n        if (daysLeft == 0) {\n            expired = true;\n        }\n        return (daysLeft, expired);\n    }\n\n    modifier onlyAirBattle() {\n        require(\n            msg.sender == airBattle,\n            \"function only callable from air battle\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable from the air battle contract\n    ///@dev this function will increment air battle casualties\n    function addAirBattleCasualties(\n        uint256 _warId,\n        uint256 nationId,\n        uint256 battleCausalties\n    ) public onlyAirBattle {\n        (uint256 offenseId, uint256 defenseId) = getInvolvedParties(_warId);\n        if (offenseId == nationId) {\n            warIdToOffenseLosses[_warId].aircraftLost = battleCausalties;\n        }\n        if (defenseId == nationId) {\n            warIdToDefenseLosses[_warId].aircraftLost = battleCausalties;\n        }\n    }\n\n    modifier onlyForcesContract() {\n        require(msg.sender == forces, \"only callable from forces\");\n        _;\n    }\n\n    ///@dev this function is only callable from the forces contact\n    ///@notice this function will allow a nation to deploy ground forces (soldiers and tanks) to a given war\n    function deployForcesToWar(\n        uint256 nationId,\n        uint256 _warId,\n        uint256 soldiersToDeploy,\n        uint256 tanksToDeploy\n    ) public onlyForcesContract {\n        bool isActive = isWarActive(_warId);\n        require(isActive, \"war not active\");\n        (uint256 offenseId, uint256 defenseId) = getInvolvedParties(_warId);\n        require(\n            nationId == offenseId || nationId == defenseId,\n            \"nation not involved\"\n        );\n        uint256 day = keep.getGameDay();\n        if (nationId == offenseId) {\n            bool deployedToday = warIdToOffenseDeployed1[_warId]\n                .offenseDeployedToday[day];\n            require(!deployedToday, \"already deployed forces today\");\n            warIdToOffenseDeployed1[_warId]\n                .soldiersDeployed += soldiersToDeploy;\n            warIdToOffenseDeployed1[_warId].tanksDeployed += tanksToDeploy;\n            warIdToOffenseDeployed1[_warId].offenseDeployedToday[day] = true;\n        } else if (nationId == defenseId) {\n            bool deployedToday = warIdToDefenseDeployed1[_warId]\n                .defenseDeployedToday[day];\n            require(!deployedToday, \"already deployed forces today\");\n            warIdToDefenseDeployed1[_warId]\n                .soldiersDeployed += soldiersToDeploy;\n            warIdToDefenseDeployed1[_warId].tanksDeployed += tanksToDeploy;\n            warIdToDefenseDeployed1[_warId].defenseDeployedToday[day] = true;\n        }\n    }\n\n    ///@dev this is a public view function that will return the number of ground forces a nation has deploed to a war\n    ///@param _warId is the war id of the war where the forces are deployed\n    ///@param attackerId is the nation id of the nation being queried\n    ///@return soldiersDeployed is the soldiers the given nation has deployed to the given war\n    ///@return tanksDeployed is the tanks the given nation has deployed to the given war\n    function getDeployedGroundForces(\n        uint256 _warId,\n        uint256 attackerId\n    ) public view returns (uint256, uint256) {\n        uint256 soldiersDeployed;\n        uint256 tanksDeployed;\n        (uint256 offenseId, uint256 defenseId) = getInvolvedParties(_warId);\n        if (attackerId == offenseId) {\n            soldiersDeployed = warIdToOffenseDeployed1[_warId].soldiersDeployed;\n            tanksDeployed = warIdToOffenseDeployed1[_warId].tanksDeployed;\n        } else if (attackerId == defenseId) {\n            soldiersDeployed = warIdToDefenseDeployed1[_warId].soldiersDeployed;\n            tanksDeployed = warIdToDefenseDeployed1[_warId].tanksDeployed;\n        }\n        return (soldiersDeployed, tanksDeployed);\n    }\n\n    modifier onlyGroundBattle() {\n        require(\n            msg.sender == groundBattle,\n            \"function only callable from navy battle contract\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable from the groun battle contract\n    ///@dev this function will increment ground forces casualties\n    function decreaseGroundBattleLosses(\n        uint256 soldierLosses,\n        uint256 tankLosses,\n        uint256 attackerId,\n        uint256 _warId\n    ) public onlyGroundBattle {\n        (uint256 offenseId, uint256 defenseId) = getInvolvedParties(_warId);\n        if (offenseId == attackerId) {\n            warIdToOffenseDeployed1[_warId].soldiersDeployed -= soldierLosses;\n            warIdToOffenseDeployed1[_warId].tanksDeployed -= tankLosses;\n        } else if (defenseId == attackerId) {\n            warIdToDefenseDeployed1[_warId].soldiersDeployed -= soldierLosses;\n            warIdToDefenseDeployed1[_warId].tanksDeployed -= tankLosses;\n        }\n    }\n\n    function recallTroopsFromDeactivatedWars(uint256 id) public {\n        bool isOwner = mint.checkOwnership(id, msg.sender);\n        require(isOwner, \"!nation owner\");\n        uint256[] memory activeWars = idToActiveWars[id];\n        for (uint256 i = 0; i < activeWars.length; i++) {\n            (,bool expired) = getDaysLeft(activeWars[i]);\n            if(expired == true) {\n                removeActiveWar(activeWars[i]);\n            }\n        }\n        uint256[] storage deactivatedWars = idToDeactivatedWars[id];\n        for (uint256 i = 0; i < deactivatedWars.length; i++) {\n            uint256 war = deactivatedWars[i];\n            (uint256 offenseId, uint256 defenseId) = getInvolvedParties(war);\n            if (id == offenseId) {\n                uint256 soldiersDeployed = warIdToOffenseDeployed1[war]\n                    .soldiersDeployed;\n                uint256 tanksDeployed = warIdToOffenseDeployed1[war]\n                    .tanksDeployed;\n                forc.withdrawSoldiers(soldiersDeployed, id);\n                forc.withdrawTanks(tanksDeployed, id);\n                warIdToOffenseDeployed1[war].soldiersDeployed = 0;\n                warIdToOffenseDeployed1[war].tanksDeployed = 0;\n            } else if (id == defenseId) {\n                uint256 soldiersDeployed = warIdToDefenseDeployed1[war]\n                    .soldiersDeployed;\n                uint256 tanksDeployed = warIdToDefenseDeployed1[war]\n                    .tanksDeployed;\n                forc.withdrawSoldiers(soldiersDeployed, id);\n                forc.withdrawTanks(tanksDeployed, id);\n                warIdToDefenseDeployed1[war].soldiersDeployed = 0;\n                warIdToDefenseDeployed1[war].tanksDeployed = 0;\n            }\n            deactivatedWars[i] = deactivatedWars[deactivatedWars.length - 1];\n            deactivatedWars.pop();\n        }\n    }\n}\n"
    },
    "contracts/WarBucks.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title ERC20 Contract WarBucks\n/// @author OxSnosh\n/// @dev This is the contact for the currency used to purchase items in the game\n/// @dev Inherits from OpenZeppelin ERC20 and Ownable\n/// @dev The deployer of the contract will be the owner\ncontract WarBucks is ERC20, Ownable {\n    address treasury;\n    address countryMinter;\n\n    /// @param initialSupply is the inital supply of WarBucks currency\n    /// @dev The initial supply is minted to the deployer of the contract\n    constructor(uint256 initialSupply) ERC20(\"WarBucks\", \"WB\") {\n        _mint(msg.sender, initialSupply);\n    }\n\n    /// @dev This modifier exists in order to allow the TreasuryContract to mint and burn tokens\n    modifier onlyTreasury() {\n        require(\n            msg.sender == treasury,\n            \"function only callable from treasury contract\"\n        );\n        _;\n    }\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"function only callable from countryMinter contract\"\n        );\n        _;\n    }\n\n    /// @dev This function is called by the owner after deployment in order to update the treasury contract address for the onlyTreasury modifer\n    /// @param _treasury is the address of the treasury contract\n    /// @param _countryMinter is the address of the countryMinter contract\n    function settings(address _treasury, address _countryMinter) public onlyOwner {\n        treasury = _treasury;\n        countryMinter = _countryMinter;\n    }\n\n    /// @dev This function can only be called from the treasury contract\n    /// @dev This function enables a nation owner to withdraw in game balance from the treasury contract and mint a corresponding amount of WarBucks tokens into a nations wallet \n    /// @dev WarBucks has 18 decimals as does the in game balance\n    /// @param account this is the address of the nation owner and the wallet where the tokens are being minted\n    /// @param amount is the amount of tokens being burned\n    function mintFromTreasury(\n        address account,\n        uint256 amount\n    ) external onlyTreasury {\n        _mint(account, amount);\n    }\n\n    /// @dev This function can only be called from the treasury contract\n    /// @dev This function enables a nation owner to deposit in game balance into a nation and burn a corresponding amount of WarBucks tokens into a nations wallet\n    /// @dev WarBucks has 18 decimals as does the in game balance\n    /// @notice This function will burn tokens when they are deposited into a nation. For every token burned, a nations in game balance will increase +1\n    /// @param account this is the address of the nation owner and the wallet where the tokens are being burned\n    /// @param amount is the amount of tokens being burned\n    function burnFromTreasury(\n        address account,\n        uint256 amount\n    ) external onlyTreasury {\n        _burn(account, amount);\n    }\n\n    function burnFromMint(\n        address account,\n        uint256 amount\n    ) external onlyCountryMinter {\n        _burn(account, amount);\n    }\n\n    function mint(address account, uint256 amount) public onlyOwner {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) public onlyOwner {\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/Wonders.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport \"./Treasury.sol\";\nimport \"./Infrastructure.sol\";\nimport \"./Improvements.sol\";\nimport \"./Forces.sol\";\nimport \"./CountryMinter.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"hardhat/console.sol\";\n\n///@title WondersContract1\n///@author OxSnosh\n///@dev this contract inherits from openzeppelin's ownable contract\n///@notice this contract will strore information about a nations wonders\ncontract WondersContract1 is Ownable {\n    address public treasuryAddress;\n    address public wondersContract2Address;\n    address public wondersContract3Address;\n    address public wondersContract4Address;\n    address public infrastructureAddress;\n    address public countryMinter;\n    uint256 public agricultureDevelopmentCost = 30000000 * (10**18);\n    uint256 public antiAirDefenseNetworkCost = 50000000 * (10**18);\n    uint256 public centralIntelligenceAgencyCost = 40000000 * (10**18);\n    uint256 public disasterReliefAgencyCost = 40000000 * (10**18);\n    uint256 public empWeaponizationCost = 200000000 * (10**18);\n    uint256 public falloutShelterSystemCost = 40000000 * (10**18);\n    uint256 public federalAidCommissionCost = 25000000 * (10**18);\n    uint256 public federalReserveCost = 100000000 * (10**18);\n    uint256 public foreignAirForceBaseCost = 35000000 * (10**18);\n    uint256 public foreignArmyBaseCost = 200000000 * (10**18);\n    uint256 public foreignNavalBaseCost = 200000000 * (10**18);\n\n    CountryMinter mint;\n\n    struct Wonders1 {\n        uint256 wonderCount;\n        //Agriculture Development Program\n        //$30,000,000\n        //DONE //Increases land size by 15%\n        //DONE //Increases citizen income +$2.00,\n        //Increases the citizen-bonus for land from 0.2 to 0.5.\n        //Requires 3,000 land purchased, 500 technology.\n        bool agricultureDevelopmentProgram;\n        //Anti-Air Defense Network\n        //$50,000,000\n        //Reduces odds of incoming aircraft attacks against your nation -25%.\n        //DONE //Reduces aircraft attack damages against your nation -15%.\n        bool antiAirDefenseNetwork;\n        //Central Intelligence Agency\n        //$40,000,000\n        //DONE //Increases the number of spies that your nation can support +250 and\n        //DONE //increases your nation's spy attack strength +10%.\n        //Only viewable by the user who owns it.\n        bool centralIntelligenceAgency;\n        //Disaster Relief Agency\n        //$40,000,000\n        //The disaster relief agency helps restore your nation and its people after emergency situations\n        //DONE //Increases population +3%\n        //DONE //and opens one extra foreign aid slot.\n        bool disasterReliefAgency;\n        //EMP Weaponization\n        //$200,000,000 + (Nation Strength * 2,000)\n        //Provides attackers with 5,000 or more technology the option to launch a targeted EMP nuclear attack.\n        //DONE //Nuclear weapons can target higher infrastructure, higher land, or higher technology damage based on player choice when launching nukes.\n        //When you choose to target infrastructure, land, or technology you are trading more damage to your target for less damage for the other two.\n        //For instance, if you choose to target infrastructure you will do more base damage to infrastructure but less damage to land and technology.\n        //Requires 5,000 technology and a Weapons Research Complex to purchase.\n        bool empWeaponization;\n        //Fallout Shelter System\n        //$40,000,000\n        //DONE //Allows 50% of your defending soldiers to survive a nuclear strike\n        //(Does not prevent nuclear Anarchy but does prevent troops from being totally depleted),\n        //DONE (not aircraft) //Reduces tank, cruise missile, and aircraft, losses from a nuclear strike by -25%,\n        //DONE //Reduces nuclear vulnerable navy losses by 12%,\n        //Reduces nuclear anarchy effects by 1 day.\n        //Requires 6,000 infrastructure, 2,000 technology.\n        bool falloutShelterSystem;\n        //Federal Aid Commission\n        //$25,000,000\n        //DONE //Raises the cap on foreign money aid +50% provided that the foreign aid recipient also has a Federal Aid Commission wonder.\n        //Allows two nations with the Federal Aid Commission wonder to send secret foreign aid.\n        //Secret foreign aid costs the sender 200% the value of the items that are sent.\n        bool federalAidCommission;\n        //Federal Reserve\n        //$100,000,000 + (Nation Strength * 1,000)\n        //DONE //Increases the number of banks that can be purchased +2.\n        //Requires Stock Market.\n        bool federalReserve;\n        //Foreign Air Force Base -\n        //$35,000,000 -\n        //DONE //Raises the aircraft limit +20 for your nation and\n        //increases the number of aircraft that can be sent in each attack mission +20.\n        bool foreignAirForceBase;\n        //Foreign Army Base -\n        //$200,000,000 -\n        //DONE //Adds an extra +1 offensive war slot.\n        //Requires 8,000 technology to purchase.\n        bool foreignArmyBase;\n        //Foreign Naval Base -\n        //$200,000,000 -\n        //DONE //Allows +2 naval vessels to be purchased per day (+1 in Peace Mode)\n        //and also allows +1 naval deployment per day.\n        //Requires 20,000 infrastructure.\n        bool foreignNavalBase;\n    }\n\n    mapping(uint256 => Wonders1) public idToWonders1;\n\n    event Wonder1Purchased(\n        uint256 indexed id,\n        uint256 indexed wonderId\n    );\n\n    event Wonder1Deleted(\n        uint256 indexed id,\n        uint256 indexed wonderId\n    );\n\n    modifier approvedAddress() {\n        require(\n            msg.sender == wondersContract2Address ||\n                msg.sender == wondersContract3Address ||\n                msg.sender == wondersContract4Address,\n            \"Unable to call\"\n        );\n        _;\n    }\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"only callable from countryMinter\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _treasuryAddress,\n        address _wonderContract2Address,\n        address _wonderContract3Address,\n        address _wonderContract4Address,\n        address _infrastructureAddress,\n        address _countryMinter\n    ) public onlyOwner {\n        treasuryAddress = _treasuryAddress;\n        wondersContract2Address = _wonderContract2Address;\n        wondersContract3Address = _wonderContract3Address;\n        wondersContract4Address = _wonderContract4Address;\n        infrastructureAddress = _infrastructureAddress;\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n    }\n\n    ///@dev this is a public view function that will return the number of wonders a given nation owns\n    ///@notice this function will return the number of wonders a given nation owns\n    ///@param id is the nation id of the nation being queried\n    ///@return count is the number of wonder a given nation owns\n    function getWonderCount(uint256 id) public view returns (uint256 count) {\n        count = idToWonders1[id].wonderCount;\n        return count;\n    }\n\n    ///@dev this function is only callable from other wonder contracts\n    ///@dev this function will increment the number of wonders a nation owns when a wonder is purchased in another contract\n    function addWonderCount(uint256 id) public approvedAddress {\n        idToWonders1[id].wonderCount += 1;\n    }\n\n    ///@dev this function is only callable from other wonder contracts\n    ///@dev this function will decremeny the number of wonders a nation owns when a wonder is deleted in another contract\n    function subtractWonderCount(uint256 id) public approvedAddress {\n        idToWonders1[id].wonderCount -= 1;\n    }\n\n    ///@dev this function is only callable from the country minter contract\n    ///@notice this function will be called when a nation is minted and allow a nation to buy the wonders in this contract\n    function generateWonders1(uint256 id) public onlyCountryMinter {\n        Wonders1 memory newWonders1 = Wonders1(\n            0,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false\n        );\n        idToWonders1[id] = newWonders1;\n    }\n\n    \n    ///@dev this function is only callable by the contract owner\n    function updateAgricultureDevelopmentCost(\n        uint256 newPrice\n    ) public onlyOwner {\n        agricultureDevelopmentCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateAntiAirDefenseNetworkCost(\n        uint256 newPrice\n    ) public onlyOwner {\n        antiAirDefenseNetworkCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateCentralIntelligenceAgencyCost(\n        uint256 newPrice\n    ) public onlyOwner {\n        centralIntelligenceAgencyCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateDisasterReliefAgencyCost(uint256 newPrice) public onlyOwner {\n        disasterReliefAgencyCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateEmpWeaponizationCost(uint256 newPrice) public onlyOwner {\n        empWeaponizationCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateFalloutShelterSystemCost(uint256 newPrice) public onlyOwner {\n        falloutShelterSystemCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateFederalAidCommissionCost(uint256 newPrice) public onlyOwner {\n        federalAidCommissionCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateFederalReserveCost(uint256 newPrice) public onlyOwner {\n        federalReserveCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateForeignAirForceBaseCost(uint256 newPrice) public onlyOwner {\n        foreignAirForceBaseCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateForeignArmyBaseCost(uint256 newPrice) public onlyOwner {\n        foreignArmyBaseCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateForeignNavalBaseCost(uint256 newPrice) public onlyOwner {\n        foreignNavalBaseCost = newPrice;\n    }\n\n    ///@dev this function is only callable from a nation owner and allows a nation to purchase the wonders in this contract\n    ///@notice this function allows a nation owner to purchase the wonders in this contract\n    ///@param countryId is the nationId of the country purchasing a wonder\n    /**@param wonderId is the id of the wonder\n     * 1. agricultrual development program\n     * 2. air defense network\n     * 3. central intelligence agency\n     * 4. disaster relief agency\n     * 5. emp weaponization\n     * 6. fallout shelter system \n     * 7. federal aid commission\n     * 8. federal reserve\n     * 9. foreign air force base\n     * 10. foreign army base\n     * 11. foreign naval base\n    */\n    function buyWonder1(uint256 countryId, uint256 wonderId) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(wonderId <= 11, \"Invalid wonder ID\");\n        uint256 balance = TreasuryContract(treasuryAddress).checkBalance(\n            countryId\n        );\n        if (wonderId == 1) {\n            require(\n                balance >= agricultureDevelopmentCost,\n                \"Insufficient balance\"\n            );\n            bool existingWonder = idToWonders1[countryId]\n                .agricultureDevelopmentProgram;\n            require(existingWonder == false, \"Already owned\");\n            uint256 techAmount = InfrastructureContract(infrastructureAddress)\n                .getTechnologyCount(countryId);\n            require(techAmount >= 500, \"Requires 500 Tech\");\n            uint256 landAmount = InfrastructureContract(infrastructureAddress)\n                .getLandCount(countryId);\n            require(landAmount >= 3000, \"Requires 3000 Land\");\n            idToWonders1[countryId].agricultureDevelopmentProgram = true;\n            idToWonders1[countryId].wonderCount += 1;\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                agricultureDevelopmentCost\n            );\n        } else if (wonderId == 2) {\n            require(\n                balance >= antiAirDefenseNetworkCost,\n                \"Insufficient balance\"\n            );\n            bool existingWonder = idToWonders1[countryId].antiAirDefenseNetwork;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders1[countryId].antiAirDefenseNetwork = true;\n            idToWonders1[countryId].wonderCount += 1;\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                antiAirDefenseNetworkCost\n            );\n        } else if (wonderId == 3) {\n            require(\n                balance >= centralIntelligenceAgencyCost,\n                \"Insufficient balance\"\n            );\n            bool existingWonder = idToWonders1[countryId]\n                .centralIntelligenceAgency;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders1[countryId].centralIntelligenceAgency = true;\n            idToWonders1[countryId].wonderCount += 1;\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                centralIntelligenceAgencyCost\n            );\n        } else if (wonderId == 4) {\n            require(\n                balance >= disasterReliefAgencyCost,\n                \"Insufficient balance\"\n            );\n            bool existingWonder = idToWonders1[countryId].disasterReliefAgency;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders1[countryId].disasterReliefAgency = true;\n            idToWonders1[countryId].wonderCount += 1;\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                disasterReliefAgencyCost\n            );\n        } else if (wonderId == 5) {\n            require(balance >= empWeaponizationCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders1[countryId].empWeaponization;\n            require(existingWonder == false, \"Already owned\");\n            bool isWrcThere = WondersContract4(wondersContract4Address)\n                .getWeaponsResearchCenter(countryId);\n            require(\n                isWrcThere == true,\n                \"Must own Weapons Research Center to purchase\"\n            );\n            uint256 techAmount = InfrastructureContract(infrastructureAddress)\n                .getTechnologyCount(countryId);\n            require(\n                techAmount >= 5000,\n                \"Must have 5000 Technology to purchase\"\n            );\n            idToWonders1[countryId].empWeaponization = true;\n            idToWonders1[countryId].wonderCount += 1;\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                empWeaponizationCost\n            );\n        } else if (wonderId == 6) {\n            require(\n                balance >= falloutShelterSystemCost,\n                \"Insufficient balance\"\n            );\n            bool existingWonder = idToWonders1[countryId].falloutShelterSystem;\n            require(existingWonder == false, \"Already owned\");\n            uint256 infrastructureAmount = InfrastructureContract(\n                infrastructureAddress\n            ).getInfrastructureCount(countryId);\n            require(\n                infrastructureAmount >= 6000,\n                \"Requires 6000 Infrastructure to purchase\"\n            );\n            uint256 technologyAmount = InfrastructureContract(\n                infrastructureAddress\n            ).getTechnologyCount(countryId);\n            require(technologyAmount >= 2000, \"Requires 2000 Tech to purchase\");\n            idToWonders1[countryId].falloutShelterSystem = true;\n            idToWonders1[countryId].wonderCount += 1;\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                falloutShelterSystemCost\n            );\n        } else if (wonderId == 7) {\n            require(\n                balance >= federalAidCommissionCost,\n                \"Insufficient balance\"\n            );\n            bool existingWonder = idToWonders1[countryId].federalAidCommission;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders1[countryId].federalAidCommission = true;\n            idToWonders1[countryId].wonderCount += 1;\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                federalAidCommissionCost\n            );\n        } else if (wonderId == 8) {\n            require(balance >= federalReserveCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders1[countryId].federalReserve;\n            require(existingWonder == false, \"Already owned\");\n            bool isStockMarket = WondersContract4(wondersContract4Address)\n                .getStockMarket(countryId);\n            require(\n                isStockMarket == true,\n                \"Required to own stock market to purchase\"\n            );\n            idToWonders1[countryId].federalReserve = true;\n            idToWonders1[countryId].wonderCount += 1;\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                federalReserveCost\n            );\n        } else if (wonderId == 9) {\n            require(balance >= foreignAirForceBaseCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders1[countryId].foreignAirForceBase;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders1[countryId].foreignAirForceBase = true;\n            idToWonders1[countryId].wonderCount += 1;\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                foreignAirForceBaseCost\n            );\n        } else if (wonderId == 10) {\n            require(balance >= foreignArmyBaseCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders1[countryId].foreignArmyBase;\n            require(existingWonder == false, \"Already owned\");\n            uint256 techAmount = InfrastructureContract(infrastructureAddress)\n                .getTechnologyCount(countryId);\n            require(\n                techAmount >= 8000,\n                \"Must have 8000 Technology to purchase\"\n            );\n            idToWonders1[countryId].foreignArmyBase = true;\n            idToWonders1[countryId].wonderCount += 1;\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                foreignArmyBaseCost\n            );\n        } else {\n            require(balance >= foreignNavalBaseCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders1[countryId].foreignNavalBase;\n            require(existingWonder == false, \"Already owned\");\n            uint256 infrastructureAmount = InfrastructureContract(\n                infrastructureAddress\n            ).getInfrastructureCount(countryId);\n            require(\n                infrastructureAmount >= 20000,\n                \"Requires 20000 infrastructure to purchase\"\n            );\n            idToWonders1[countryId].foreignNavalBase = true;\n            idToWonders1[countryId].wonderCount += 1;\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                foreignNavalBaseCost\n            );\n        }\n        emit Wonder1Purchased(countryId, wonderId);\n    }\n\n    ///@dev this function will allow a nation owner to delete a wonder\n    ///@dev this function is only callable by a nation owner\n    ///@notice this funtion will allow a nation owner to delete a wonder\n    ///@param countryId is the nation deleting the woner\n    /**@param wonderId is the id of the wonder\n     * 1. agricultrual development program\n     * 2. air defense network\n     * 3. central intelligence agency\n     * 4. disaster relief agency\n     * 5. emp weaponization\n     * 6. fallout shelter system \n     * 7. federal aid commission\n     * 8. federal reserve\n     * 9. foreign air force base\n     * 10. foreign army base\n     * 11. foreign naval base\n    */\n    function deleteWonder1(uint256 countryId, uint256 wonderId) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(wonderId <= 11, \"Invalid wonder ID\");\n        if (wonderId == 1) {\n            bool existingWonder = idToWonders1[countryId]\n                .agricultureDevelopmentProgram;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders1[countryId].agricultureDevelopmentProgram = false;\n            idToWonders1[countryId].wonderCount -= 1;\n        } else if (wonderId == 2) {\n            bool existingWonder = idToWonders1[countryId].antiAirDefenseNetwork;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders1[countryId].antiAirDefenseNetwork = false;\n            idToWonders1[countryId].wonderCount -= 1;\n        } else if (wonderId == 3) {\n            bool existingWonder = idToWonders1[countryId]\n                .centralIntelligenceAgency;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders1[countryId].centralIntelligenceAgency = false;\n            idToWonders1[countryId].wonderCount -= 1;\n        } else if (wonderId == 4) {\n            bool existingWonder = idToWonders1[countryId].disasterReliefAgency;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders1[countryId].disasterReliefAgency = false;\n            idToWonders1[countryId].wonderCount -= 1;\n        } else if (wonderId == 5) {\n            bool existingWonder = idToWonders1[countryId].empWeaponization;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders1[countryId].empWeaponization = false;\n            idToWonders1[countryId].wonderCount -= 1;\n        } else if (wonderId == 6) {\n            bool existingWonder = idToWonders1[countryId].falloutShelterSystem;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders1[countryId].falloutShelterSystem = false;\n            idToWonders1[countryId].wonderCount -= 1;\n        } else if (wonderId == 7) {\n            bool existingWonder = idToWonders1[countryId].federalAidCommission;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders1[countryId].federalAidCommission = false;\n            idToWonders1[countryId].wonderCount -= 1;\n        } else if (wonderId == 8) {\n            bool existingWonder = idToWonders1[countryId].federalReserve;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders1[countryId].federalReserve = false;\n            idToWonders1[countryId].wonderCount -= 1;\n        } else if (wonderId == 9) {\n            bool existingWonder = idToWonders1[countryId].foreignAirForceBase;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders1[countryId].foreignAirForceBase = false;\n            idToWonders1[countryId].wonderCount -= 1;\n        } else if (wonderId == 10) {\n            bool existingWonder = idToWonders1[countryId].foreignArmyBase;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders1[countryId].foreignArmyBase = false;\n            idToWonders1[countryId].wonderCount -= 1;\n        } else {\n            bool existingWonder = idToWonders1[countryId].foreignNavalBase;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders1[countryId].foreignNavalBase = false;\n            idToWonders1[countryId].wonderCount -= 1;\n        }\n        emit Wonder1Deleted(countryId, wonderId);\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the agriculture development program wonder\n    ///@dev this function will return true if a nation has the agriculture development program wonder\n    ///@param id is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getAgriculturalDevelopmentProgram(\n        uint256 id\n    ) public view returns (bool) {\n        return idToWonders1[id].agricultureDevelopmentProgram;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the anti air defense network wonder\n    ///@dev this function will return true if a nation has the anti air defense network wonder\n    ///@param id is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getAntiAirDefenseNewtwork(uint256 id) public view returns (bool) {\n        return idToWonders1[id].antiAirDefenseNetwork;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the central intelligence agency wonder\n    ///@dev this function will return true if a nation has the central intelligence agency wonder\n    ///@param id is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getCentralIntelligenceAgency(\n        uint256 id\n    ) public view returns (bool) {\n        return idToWonders1[id].centralIntelligenceAgency;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the disaster relief agency wonder\n    ///@dev this function will return true if a nation has the disaster relief agency wonder\n    ///@param id is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getDisasterReliefAgency(uint256 id) public view returns (bool) {\n        return idToWonders1[id].disasterReliefAgency;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the emp weaponization wonder\n    ///@dev this function will return true if a nation has the emp weaponization wonder\n    ///@param id is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getEmpWeaponization(uint256 id) public view returns (bool) {\n        return idToWonders1[id].empWeaponization;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the fallout shelter system wonder\n    ///@dev this function will return true if a nation has the fallout shelter system wonder\n    ///@param id is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getFalloutShelterSystem(uint256 id) public view returns (bool) {\n        return idToWonders1[id].falloutShelterSystem;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the federal aig commission wonder\n    ///@dev this function will return true if a nation has the federal aig commission wonder\n    ///@param id is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getFederalAidComission(uint256 id) public view returns (bool) {\n        return idToWonders1[id].federalAidCommission;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the federal reserve wonder\n    ///@dev this function will return true if a nation has the federal reserve wonder\n    ///@param id is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getFederalReserve(uint256 id) public view returns (bool) {\n        return idToWonders1[id].federalReserve;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the foreign air force base wonder\n    ///@dev this function will return true if a nation has the foreign air force base wonder\n    ///@param id is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getForeignAirforceBase(uint256 id) public view returns (bool) {\n        return idToWonders1[id].foreignAirForceBase;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the foreign army base wonder\n    ///@dev this function will return true if a nation has the foreign army base wonder\n    ///@param id is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getForeignArmyBase(uint256 id) public view returns (bool) {\n        return idToWonders1[id].foreignArmyBase;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the foreign naval base wonder\n    ///@dev this function will return true if a nation has the foreign naval base wonder\n    ///@param id is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getForeignNavalBase(uint256 id) public view returns (bool) {\n        return idToWonders1[id].foreignNavalBase;\n    }\n\n    ///@dev this function will return the costs of the wonders in this contract\n    function getWonderCosts1()\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            agricultureDevelopmentCost,\n            antiAirDefenseNetworkCost,\n            centralIntelligenceAgencyCost,\n            disasterReliefAgencyCost,\n            empWeaponizationCost,\n            falloutShelterSystemCost,\n            federalAidCommissionCost,\n            federalReserveCost,\n            foreignAirForceBaseCost,\n            foreignArmyBaseCost,\n            foreignNavalBaseCost\n        );\n    }\n}\n\n///@title WondersContract2\n///@author OxSnosh\n///@dev this contract inherits from openzeppelin's ownable contract\n///@notice this contract will strore information about a nations wonders\ncontract WondersContract2 is Ownable {\n    address public treasuryAddress;\n    address public infrastructureAddress;\n    address public wonderContract1Address;\n    address public wonderContract3Address;\n    address public wonderContract4Address;\n    address public countryMinter;\n    uint256 public greatMonumentCost = 35000000 * (10**18);\n    uint256 public greatTempleCost = 35000000 * (10**18);\n    uint256 public greatUniversityCost = 35000000 * (10**18);\n    uint256 public hiddenNuclearMissileSiloCost = 30000000 * (10**18);\n    uint256 public interceptorMissileSystemCost = 50000000 * (10**18);\n    uint256 public internetCost = 35000000 * (10**18);\n    uint256 public interstateSystemCost = 45000000 * (10**18);\n    uint256 public manhattanProjectCost = 100000000 * (10**18);\n    uint256 public miningIndustryConsortiumCost = 25000000 * (10**18);\n\n    CountryMinter mint;\n\n    struct Wonders2 {\n        //Great Monument -\n        //$35,000,000 -\n        //DONE //The great monument is a testament to your great leadership.\n        //DONE //Increases happiness +4 and your population will always be happy with your government choice.\n        bool greatMonument;\n        //Great Temple -\n        //$35,000,000 -\n        //DONE //The great temple is a dedicated shrine to your national religion.\n        //DONE //Increases happiness +5 and your population will always be happy with your religion choice.\n        bool greatTemple;\n        //Great University -\n        //$35,000,000 -\n        //The great university is a central location for scholars within your nation.\n        //DONE //Decreases technology costs -10% and\n        //DONE //increases population happiness +.2% (+2 for every 1000) of your nation's technology level over 200 up to 3,000 tech.\n        bool greatUniversity;\n        //Hidden Nuclear Missile Silo -\n        //$30,000,000 -\n        //DONE //Allows your nation to develop +5 nuclear missiles that cannot be destroyed in spy attacks.\n        //(Nations must first be nuclear capable in order to purchase nukes.)\n        bool hiddenNuclearMissileSilo;\n        //Interceptor Missile System (IMS) -\n        //$50,000,000 -\n        //DONE //Thwarts Cruise Missile Attacks, 50% of the time (removes 1 attackers CM strike chance for that day when successful).\n        //Requires 5,000 technology and a Strategic Defense Initiative (SDI).\n        bool interceptorMissileSystem;\n        //Internet -\n        //$35,000,000 -\n        //DONE //Provides Internet infrastructure throughout your nation.\n        //Increases population happiness +5.\n        bool internet;\n        //Interstate System -\n        //$45,000,000 -\n        //The interstate system allows goods and materials to be transported throughout your nation with greater ease.\n        //DONE //Decreases initial infrastructure cost -8% and\n        //DONE //decreases infrastructure upkeep costs -8%.\n        bool interstateSystem;\n        //Manhattan Project -\n        //$100,000,000 -\n        //DONE //The Manhattan Project allows nations below (150k strength) 5% of the top nations in the game to develop nuclear weapons.\n        //The Manhattan Project cannot be destroyed once it is created.\n        //The wonder requires 3,000 infrastructure, 300 technology, and a uranium resource.\n        bool manhattanProject;\n        //Mining Industry Consortium -\n        //$25,000,000 -\n        //DONE //Increases population income by $2.00 for the resources Coal, Lead, Oil, Uranium that your nation has access to.\n        //Requires 5,000 infrastructure, 3,000 land purchased, 1,000 technology.\n        bool miningIndustryConsortium;\n    }\n\n    mapping(uint256 => Wonders2) public idToWonders2;\n\n    event Wonder2Purchased(uint256 indexed countryId, uint256 indexed wonderId);\n    event Wonder2Deleted(uint256 indexed countryId, uint256 indexed wonderId);\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _treasury,\n        address _infrastructure,\n        address _wonders1,\n        address _wonders3,\n        address _wonders4,\n        address _countryMinter\n    ) public onlyOwner {\n        treasuryAddress = _treasury;\n        infrastructureAddress = _infrastructure;\n        wonderContract1Address = _wonders1;\n        wonderContract3Address = _wonders3;\n        wonderContract4Address = _wonders4;\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n    }\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"only callable from countryMinter\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable from the country minter contract\n    ///@notice this function will be called when a nation is minted and allow a nation to buy the wonders in this contract\n    function generateWonders2(uint256 id) public onlyCountryMinter {\n        Wonders2 memory newWonders2 = Wonders2(\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false\n        );\n        idToWonders2[id] = newWonders2;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateGreatMonumentCost(uint256 newPrice) public onlyOwner {\n        greatMonumentCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateGreatTempleCost(uint256 newPrice) public onlyOwner {\n        greatTempleCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateGreatUniversityCost(uint256 newPrice) public onlyOwner {\n        greatUniversityCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateHiddenNuclearMissileSiloCost(\n        uint256 newPrice\n    ) public onlyOwner {\n        hiddenNuclearMissileSiloCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateInterceptorMissileSystemCost(\n        uint256 newPrice\n    ) public onlyOwner {\n        interceptorMissileSystemCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateInternetCost(uint256 newPrice) public onlyOwner {\n        internetCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateInterstateSystemCost(uint256 newPrice) public onlyOwner {\n        interstateSystemCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateManhattanProjectCost(uint256 newPrice) public onlyOwner {\n        manhattanProjectCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateMiningIndustryConsortiumCost(\n        uint256 newPrice\n    ) public onlyOwner {\n        miningIndustryConsortiumCost = newPrice;\n    }\n\n    ///@dev this function is only callable from a nation owner and allows a nation to purchase the wonders in this contract\n    ///@notice this function allows a nation owner to purchase the wonders in this contract\n    ///@param countryId is the nationId of the country purchasing a wonder\n    /**@param wonderId is the id of the wonder\n     * 1. great monumnet\n     * 2. great temple\n     * 3. great university\n     * 4. hidden nuclear missile silo\n     * 5. interceptor missile system\n     * 6. internat\n     * 7. interstate system\n     * 8. manhattan project\n     * 9. minimg industry consortium\n    */\n    function buyWonder2(uint256 countryId, uint256 wonderId) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(wonderId <= 9, \"Invalid wonder ID\");\n        uint256 balance = TreasuryContract(treasuryAddress).checkBalance(\n            countryId\n        );\n        if (wonderId == 1) {\n            require(balance >= greatMonumentCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders2[countryId].greatMonument;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders2[countryId].greatMonument = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                greatMonumentCost\n            );\n        } else if (wonderId == 2) {\n            require(balance >= greatTempleCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders2[countryId].greatTemple;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders2[countryId].greatTemple = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                greatTempleCost\n            );\n        } else if (wonderId == 3) {\n            require(balance >= greatUniversityCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders2[countryId].greatUniversity;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders2[countryId].greatUniversity = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                greatUniversityCost\n            );\n        } else if (wonderId == 4) {\n            require(\n                balance >= hiddenNuclearMissileSiloCost,\n                \"Insufficient balance\"\n            );\n            bool existingWonder = idToWonders2[countryId]\n                .hiddenNuclearMissileSilo;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders2[countryId].hiddenNuclearMissileSilo = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                hiddenNuclearMissileSiloCost\n            );\n        } else if (wonderId == 5) {\n            require(\n                balance >= interceptorMissileSystemCost,\n                \"Insufficient balance\"\n            );\n            bool existingWonder = idToWonders2[countryId]\n                .interceptorMissileSystem;\n            require(existingWonder == false, \"Already owned\");\n            bool strategicDefenseInitiative = WondersContract4(\n                wonderContract4Address\n            ).getStrategicDefenseInitiative(countryId);\n            require(\n                strategicDefenseInitiative == true,\n                \"Strategic Defense Inititive required to purchase\"\n            );\n            uint256 techAmount = InfrastructureContract(infrastructureAddress)\n                .getTechnologyCount(countryId);\n            require(\n                techAmount >= 5000,\n                \"Must have 5000 Technology to purchase\"\n            );\n            idToWonders2[countryId].interceptorMissileSystem = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                interceptorMissileSystemCost\n            );\n        } else if (wonderId == 6) {\n            require(balance >= internetCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders2[countryId].internet;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders2[countryId].internet = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                internetCost\n            );\n        } else if (wonderId == 7) {\n            require(balance >= interstateSystemCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders2[countryId].interstateSystem;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders2[countryId].interstateSystem = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                interstateSystemCost\n            );\n        } else if (wonderId == 8) {\n            require(balance >= manhattanProjectCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders2[countryId].manhattanProject;\n            require(existingWonder == false, \"Already owned\");\n            //require uranium\n            uint256 infrastructureAmount = InfrastructureContract(\n                infrastructureAddress\n            ).getInfrastructureCount(countryId);\n            require(\n                infrastructureAmount >= 3000,\n                \"Requires 3000 infrastructure to purchase\"\n            );\n            uint256 techAmount = InfrastructureContract(infrastructureAddress)\n                .getTechnologyCount(countryId);\n            require(techAmount >= 300, \"Must have 300 Technology to purchase\");\n            idToWonders2[countryId].manhattanProject = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                manhattanProjectCost\n            );\n        } else {\n            require(\n                balance >= miningIndustryConsortiumCost,\n                \"Insufficient balance\"\n            );\n            bool existingWonder = idToWonders2[countryId]\n                .miningIndustryConsortium;\n            require(existingWonder == false, \"Already owned\");\n            uint256 techAmount = InfrastructureContract(infrastructureAddress)\n                .getTechnologyCount(countryId);\n            require(\n                techAmount >= 1000,\n                \"Must have 1000 Technology to purchase\"\n            );\n            uint256 infrastructureAmount = InfrastructureContract(\n                infrastructureAddress\n            ).getInfrastructureCount(countryId);\n            require(\n                infrastructureAmount >= 5000,\n                \"Must have 5000 Infrastructure to purchase\"\n            );\n            uint256 landAmount = InfrastructureContract(infrastructureAddress)\n                .getLandCount(countryId);\n            require(landAmount >= 3000, \"Must have 3000 Land to purchase\");\n            idToWonders2[countryId].miningIndustryConsortium = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                miningIndustryConsortiumCost\n            );\n        }\n        emit Wonder2Purchased(countryId, wonderId);\n    }\n\n    ///@dev this function will allow a nation owner to delete a wonder\n    ///@dev this function is only callable by a nation owner\n    ///@notice this funtion will allow a nation owner to delete a wonder\n    ///@param countryId is the nation deleting the woner\n    /**@param wonderId is the id of the wonder\n     * 1. great monumnet\n     * 2. great temple\n     * 3. great university\n     * 4. hidden nuclear missile silo\n     * 5. interceptor missile system\n     * 6. internat\n     * 7. interstate system\n     * 8. manhattan project\n     * 9. minimg industry consortium\n    */\n    function deleteWonder2(uint256 countryId, uint256 wonderId) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(wonderId <= 9, \"Invalid wonder ID\");\n        if (wonderId == 1) {\n            bool existingWonder = idToWonders2[countryId].greatMonument;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders2[countryId].greatMonument = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 2) {\n            bool existingWonder = idToWonders2[countryId].greatTemple;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders2[countryId].greatTemple = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 3) {\n            bool existingWonder = idToWonders2[countryId].greatUniversity;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders2[countryId].greatUniversity = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 4) {\n            bool existingWonder = idToWonders2[countryId]\n                .hiddenNuclearMissileSilo;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders2[countryId].hiddenNuclearMissileSilo = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 5) {\n            bool existingWonder = idToWonders2[countryId]\n                .interceptorMissileSystem;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders2[countryId].interceptorMissileSystem = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 6) {\n            bool existingWonder = idToWonders2[countryId].internet;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders2[countryId].internet = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 7) {\n            bool existingWonder = idToWonders2[countryId].interstateSystem;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders2[countryId].interstateSystem = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 8) {\n            // unable to delete Manhattan Project once purchased\n            // bool existingWonder = idToWonders2[countryId].manhattanProject;\n            // require(existingWonder == true, \"No wonder to delete\");\n            // idToWonders2[countryId].manhattanProject = false;\n            // WondersContract1(wonderContract1Address).subtractWonderCount(\n            //     countryId\n            // );\n            revert(\"Unable to delete Manhattan Project\");\n        } else {\n            bool existingWonder = idToWonders2[countryId]\n                .miningIndustryConsortium;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders2[countryId].miningIndustryConsortium = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        }\n        emit Wonder2Deleted(countryId, wonderId);\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the great monument wonder\n    ///@dev this function will return true if a nation has the great monument wonder\n    ///@param id is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getGreatMonument(uint256 id) public view returns (bool) {\n        return idToWonders2[id].greatMonument;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the great temple wonder\n    ///@dev this function will return true if a nation has the great temple wonder\n    ///@param id is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getGreatTemple(uint256 id) public view returns (bool) {\n        return idToWonders2[id].greatTemple;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the great university wonder\n    ///@dev this function will return true if a nation has the great university wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getGreatUniversity(uint256 countryId) public view returns (bool) {\n        return idToWonders2[countryId].greatUniversity;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the hidden nuclear missile silo wonder\n    ///@dev this function will return true if a nation has the hidden nuclear missile silo wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getHiddenNuclearMissileSilo(\n        uint256 countryId\n    ) public view returns (bool) {\n        return idToWonders2[countryId].hiddenNuclearMissileSilo;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the intereptor missile system wonder\n    ///@dev this function will return true if a nation has the intereptor missile system wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getInterceptorMissileSystem(\n        uint256 countryId\n    ) public view returns (bool) {\n        return idToWonders2[countryId].interceptorMissileSystem;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the internet wonder\n    ///@dev this function will return true if a nation has the internet wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getInternet(uint256 countryId) public view returns (bool) {\n        return idToWonders2[countryId].internet;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the interstate system wonder\n    ///@dev this function will return true if a nation has the interstate system wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getInterstateSystem(uint256 countryId) public view returns (bool) {\n        return idToWonders2[countryId].interstateSystem;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the manhattan project wonder\n    ///@dev this function will return true if a nation has the manhattan project wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getManhattanProject(uint256 countryId) public view returns (bool) {\n        return idToWonders2[countryId].manhattanProject;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the mining industry consortium wonder\n    ///@dev this function will return true if a nation has the mining industry consortium wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getMiningIndustryConsortium(\n        uint256 countryId\n    ) public view returns (bool) {\n        return idToWonders2[countryId].miningIndustryConsortium;\n    }\n\n    ///@dev this function will return the costs of the wonders in this contract\n    function getWonderCosts2() public view returns(\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256\n    ) {\n        return (\n            greatMonumentCost,\n            greatTempleCost,\n            greatUniversityCost,\n            hiddenNuclearMissileSiloCost,\n            interceptorMissileSystemCost,\n            internetCost,\n            interstateSystemCost,\n            manhattanProjectCost,\n            miningIndustryConsortiumCost\n        );\n    }\n}\n\n///@title WondersContract3\n///@author OxSnosh\n///@dev this contract inherits from openzeppelin's ownable contract\n///@notice this contract will strore information about a nations wonders\ncontract WondersContract3 is Ownable {\n    address public treasuryAddress;\n    address public infrastructureAddress;\n    address public wonderContract1Address;\n    address public wonderContract2Address;\n    address public wonderContract4Address;\n    address public forces;\n    address public countryMinter;\n    uint256 public movieIndustryCost = 26000000 * (10**18);\n    uint256 public nationalCemetaryCost = 150000000 * (10**18);\n    uint256 public nationalEnvironmentOfficeCost = 100000000 * (10**18);\n    uint256 public nationalResearchLabCost = 35000000 * (10**18);\n    uint256 public nationalWarMemorialCost = 27000000 * (10**18);\n    uint256 public nuclearPowerPlantCost = 75000000 * (10**18);\n    uint256 public pentagonCost = 30000000 * (10**18);\n    uint256 public politicalLobbyistsCost = 50000000 * (10**18);\n    uint256 public scientificDevelopmentCenterCost = 150000000 * (10**18);\n\n    ForcesContract frc;\n    CountryMinter mint;\n\n    struct Wonders3 {\n        //Movie Industry -\n        //$26,000,000 -\n        //The movie industry provides a great source of entertainment to your people.\n        //DONE //Increases population happiness +3.\n        bool movieIndustry;\n        //National Cemetery -\n        //$150,000,000 -\n        //DONE //Provides +0.20 Happiness per 1,000,000 soldier casualties up to +5 happiness.\n        //Requires 5 million soldier casualties and a National War Memorial.\n        bool nationalCemetary;\n        //National Environment Office -\n        //$100,000,000 -\n        //DONE //The national environment office removes the penalties for Coal, Oil, and Uranium,\n        //DONE //improves environment by 1 point,\n        //DONE //increases population +3%,\n        //DONE //and reduces infrastructure upkeep -3%.\n        //Requires 13,000 infrastructure.\n        bool nationalEnvironmentOffice;\n        //National Research Lab -\n        //$35,000,000 -\n        //The national research lab is a central location for scientists seeking cures for common diseases among your population.\n        //DONE //Increases population +5% and\n        //DONE //decreases technology costs -3%.\n        bool nationalResearchLab;\n        //National War Memorial -\n        //$27,000,000 -\n        //The war memorial allows your citizens to remember its fallen soldiers.\n        //This wonder is only available to nations that have lost over 50,000 soldiers during war throughout the life of your nation.\n        //DONE //Increases population happiness +4.\n        bool nationalWarMemorial;\n        //Nuclear Power Plant -\n        //$75,000,000 -\n        //The nuclear power plant allows nations to receive Uranium financial bonus\n        //DONE //(+$3 citizen income +$0.15 per technology level up to 30 technology levels. Requires an active Uranium trade.)\n        //even when maintaining nuclear weaponry.\n        //DONE //The nuclear power plant by itself, even without a Uranium trade, reduces infrastructure upkeep -5%,\n        //DONE //national wonder upkeep -5%,\n        //DONE //and improvement upkeep -5%.\n        //Requires 12,000 infrastructure, 1,000 technology, and a Uranium resource to build.\n        //Nations that develop the Nuclear Power Plant must keep their government position on nuclear weapons set to option 2 or 3.\n        bool nuclearPowerPlant;\n        //Pentagon -\n        //$30,000,000 -\n        //The Pentagon serves as your nation's headquarters for military operations.\n        //DONE //Increases attacking and defending ground battle strength +20%.\n        bool pentagon;\n        //Political Lobbyists -\n        //$50,000,000 -\n        //DONE //Your vote counts as two votes in your team's senate.\n        //Must be re-purchased every time you switch teams.\n        bool politicalLobbyists;\n        //Scientific Development Center -\n        //$150,000,000 -\n        //DONE //The scientific development center increases the productivity of your factories from\n        //DONE //-8% infrastructure cost to -10% infrastructure cost,\n        //DONE //increases the productivity of your universities from\n        //DONE //+8% citizen income to +10% citizen income,\n        //DONE //allows the Great University to give its technology happiness bonus up to 5,000 technology levels\n        //DONE //(+2 happiness each 1,000 technology levels).\n        //Requires 14,000 infrastructure, 3,000 technology, Great University, National Research Lab.\n        bool scientificDevelopmentCenter;\n    }\n\n    mapping(uint256 => Wonders3) public idToWonders3;\n\n    event Wonder3Purchased(uint256 indexed countryId, uint256 indexed wonderId);\n    event Wonder3Deleted(uint256 indexed countryId, uint256 indexed wonderId);\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _treasuryAddress,\n        address _infrastructureAddress,\n        address _forces,\n        address _wonders1,\n        address _wonders2,\n        address _wonders4,\n        address _countryMinter\n    ) public onlyOwner {\n        treasuryAddress = _treasuryAddress;\n        infrastructureAddress = _infrastructureAddress;\n        forces = _forces;\n        frc = ForcesContract(_forces);\n        wonderContract1Address = _wonders1;\n        wonderContract2Address = _wonders2;\n        wonderContract4Address = _wonders4;\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n    }\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"only callable from countryMinter\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable from the country minter contract\n    ///@notice this function will be called when a nation is minted and allow a nation to buy the wonders in this contract\n    function generateWonders3(uint256 id) public onlyCountryMinter {\n        Wonders3 memory newWonders3 = Wonders3(\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false\n        );\n        idToWonders3[id] = newWonders3;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateMovieIndustryCost(uint256 newPrice) public onlyOwner {\n        movieIndustryCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateNationalCemetaryCost(uint256 newPrice) public onlyOwner {\n        nationalCemetaryCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateNationalEnvironmentOfficeCost(uint256 newPrice)\n        public\n        onlyOwner\n    {\n        nationalEnvironmentOfficeCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateNationalResearchLabCost(uint256 newPrice) public onlyOwner {\n        nationalResearchLabCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateNationalWarMemorialCost(uint256 newPrice) public onlyOwner {\n        nationalWarMemorialCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateNuclearPowerPlantCost(uint256 newPrice) public onlyOwner {\n        nuclearPowerPlantCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updatePentagonCost(uint256 newPrice) public onlyOwner {\n        pentagonCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updatePoliticalLobbyistsCost(uint256 newPrice) public onlyOwner {\n        politicalLobbyistsCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateScientificDevelopmentCenterCost(uint256 newPrice)\n        public\n        onlyOwner\n    {\n        scientificDevelopmentCenterCost = newPrice;\n    }\n\n    ///@dev this function is only callable from a nation owner and allows a nation to purchase the wonders in this contract\n    ///@notice this function allows a nation owner to purchase the wonders in this contract\n    ///@param countryId is the nationId of the country purchasing a wonder\n    /**@param wonderId is the id of the wonder\n     * 1. movie industry\n     * 2. national cemetary\n     * 3. national environmental office\n     * 4. national research lab\n     * 5. national war memorial\n     * 6. nuclear power plant\n     * 7. pentagon\n     * 8. political lobbyists\n     * 9. scientific development center\n    */\n    function buyWonder3(uint256 countryId, uint256 wonderId) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(wonderId <= 9, \"Invalid wonder ID\");\n        uint256 balance = TreasuryContract(treasuryAddress).checkBalance(\n            countryId\n        );\n        if (wonderId == 1) {\n            require(balance >= movieIndustryCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders3[countryId].movieIndustry;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders3[countryId].movieIndustry = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                movieIndustryCost\n            );\n        } else if (wonderId == 2) {\n            require(balance >= nationalCemetaryCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders3[countryId].nationalCemetary;\n            require(existingWonder == false, \"Already owned\");\n            (uint256 casualties , ) = frc.getCasualties(countryId);\n            require(casualties >= 5000000, \"not enough casualties to purchase\");\n            bool nationalWarMemorial = idToWonders3[countryId]\n                .nationalWarMemorial;\n            require(\n                nationalWarMemorial == true,\n                \"Must own National War Memorial wonder to purchase\"\n            );\n            idToWonders3[countryId].nationalCemetary = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                nationalCemetaryCost\n            );\n        } else if (wonderId == 3) {\n            require(\n                balance >= nationalEnvironmentOfficeCost,\n                \"Insufficient balance\"\n            );\n            bool existingWonder = idToWonders3[countryId]\n                .nationalEnvironmentOffice;\n            require(existingWonder == false, \"Already owned\");\n            uint256 infrastructureAmount = InfrastructureContract(\n                infrastructureAddress\n            ).getInfrastructureCount(countryId);\n            require(\n                infrastructureAmount >= 13000,\n                \"Requires 13000 infrastructure to purchase\"\n            );\n            idToWonders3[countryId].nationalEnvironmentOffice = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                nationalEnvironmentOfficeCost\n            );\n        } else if (wonderId == 4) {\n            require(balance >= nationalResearchLabCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders3[countryId].nationalResearchLab;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders3[countryId].nationalResearchLab = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                nationalResearchLabCost\n            );\n        } else if (wonderId == 5) {\n            require(balance >= nationalWarMemorialCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders3[countryId].nationalWarMemorial;\n            require(existingWonder == false, \"Already owned\");\n            (uint256 casualties , ) = frc.getCasualties(countryId);\n            require(casualties >= 50000, \"not enough casualties\");\n            idToWonders3[countryId].nationalWarMemorial = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                nationalWarMemorialCost\n            );\n        } else if (wonderId == 6) {\n            require(balance >= nuclearPowerPlantCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders3[countryId].nuclearPowerPlant;\n            require(existingWonder == false, \"Already owned\");\n            uint256 techAmount = InfrastructureContract(infrastructureAddress)\n                .getTechnologyCount(countryId);\n            require(\n                techAmount >= 1000,\n                \"Must have 1000 Technology to purchase\"\n            );\n            uint256 infrastructureAmount = InfrastructureContract(\n                infrastructureAddress\n            ).getInfrastructureCount(countryId);\n            require(\n                infrastructureAmount >= 12000,\n                \"Must have 12000 Infrastructure to purchase\"\n            );\n            //require Uranium\n            idToWonders3[countryId].nuclearPowerPlant = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                nuclearPowerPlantCost\n            );\n        } else if (wonderId == 7) {\n            require(balance >= pentagonCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders3[countryId].pentagon;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders3[countryId].pentagon = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                pentagonCost\n            );\n        } else if (wonderId == 8) {\n            require(balance >= politicalLobbyistsCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders3[countryId].politicalLobbyists;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders3[countryId].politicalLobbyists = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                politicalLobbyistsCost\n            );\n        } else {\n            require(\n                balance >= scientificDevelopmentCenterCost,\n                \"Insufficient balance\"\n            );\n            bool existingWonder = idToWonders3[countryId]\n                .scientificDevelopmentCenter;\n            require(existingWonder == false, \"Already owned\");\n            uint256 techAmount = InfrastructureContract(infrastructureAddress)\n                .getTechnologyCount(countryId);\n            require(\n                techAmount >= 3000,\n                \"Must have 3000 Technology to purchase\"\n            );\n            uint256 infrastructureAmount = InfrastructureContract(\n                infrastructureAddress\n            ).getInfrastructureCount(countryId);\n            require(\n                infrastructureAmount >= 14000,\n                \"Must have 14000 Infrastructure to purchase\"\n            );\n            bool isGreatUniversity = WondersContract2(wonderContract2Address)\n                .getGreatUniversity(countryId);\n            require(\n                isGreatUniversity == true,\n                \"Great University required to purchase\"\n            );\n            bool isNationalResearchLab = idToWonders3[countryId]\n                .nationalResearchLab;\n            require(\n                isNationalResearchLab == true,\n                \"National Research Lab required to purchase\"\n            );\n            idToWonders3[countryId].scientificDevelopmentCenter = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                scientificDevelopmentCenterCost\n            );\n        }\n        emit Wonder3Purchased(countryId, wonderId);\n    }\n\n    ///@dev this function will allow a nation owner to delete a wonder\n    ///@dev this function is only callable by a nation owner\n    ///@notice this funtion will allow a nation owner to delete a wonder\n    ///@param countryId is the nation deleting the woner\n    /**@param wonderId is the id of the wonder\n     * 1. movie industry\n     * 2. national cemetary\n     * 3. national environmental office\n     * 4. national research lab\n     * 5. national war memorial\n     * 6. nuclear power plant\n     * 7. pentagon\n     * 8. political lobbyists\n     * 9. scientific development center\n    */\n    function deleteWonder3(uint256 countryId, uint256 wonderId) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(wonderId <= 9, \"Invalid wonder ID\");\n        if (wonderId == 1) {\n            bool existingWonder = idToWonders3[countryId].movieIndustry;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders3[countryId].movieIndustry = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 2) {\n            bool existingWonder = idToWonders3[countryId].nationalCemetary;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders3[countryId].nationalCemetary = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 3) {\n            bool existingWonder = idToWonders3[countryId]\n                .nationalEnvironmentOffice;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders3[countryId].nationalEnvironmentOffice = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 4) {\n            bool existingWonder = idToWonders3[countryId].nationalResearchLab;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders3[countryId].nationalResearchLab = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 5) {\n            bool existingWonder = idToWonders3[countryId].nationalWarMemorial;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders3[countryId].nationalWarMemorial = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 6) {\n            bool existingWonder = idToWonders3[countryId].nuclearPowerPlant;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders3[countryId].nuclearPowerPlant = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 7) {\n            bool existingWonder = idToWonders3[countryId].pentagon;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders3[countryId].pentagon = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 8) {\n            bool existingWonder = idToWonders3[countryId].politicalLobbyists;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders3[countryId].politicalLobbyists = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else {\n            bool existingWonder = idToWonders3[countryId]\n                .scientificDevelopmentCenter;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders3[countryId].scientificDevelopmentCenter = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        }\n        emit Wonder3Deleted(countryId, wonderId);\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the movie industry wonder\n    ///@dev this function will return true if a nation has the movie industry wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getMovieIndustry(uint256 countryId) public view returns (bool) {\n        return idToWonders3[countryId].movieIndustry;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the national cemetary wonder\n    ///@dev this function will return true if a nation has the national cemetary wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getNationalCemetary(uint256 countryId) public view returns (bool) {\n        return idToWonders3[countryId].nationalCemetary;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the national environmental office wonder\n    ///@dev this function will return true if a nation has the national environmental office wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getNationalEnvironmentOffice(\n        uint256 countryId\n    ) public view returns (bool) {\n        return idToWonders3[countryId].nationalEnvironmentOffice;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the national research lab wonder\n    ///@dev this function will return true if a nation has the national research lab wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getNationalResearchLab(\n        uint256 countryId\n    ) public view returns (bool) {\n        return idToWonders3[countryId].nationalResearchLab;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the national war memorial wonder\n    ///@dev this function will return true if a nation has the national war memorial wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getNationalWarMemorial(\n        uint256 countryId\n    ) public view returns (bool) {\n        return idToWonders3[countryId].nationalWarMemorial;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the nuclear power plant wonder\n    ///@dev this function will return true if a nation has the nuclear power plant wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getNuclearPowerPlant(\n        uint256 countryId\n    ) public view returns (bool) {\n        return idToWonders3[countryId].nuclearPowerPlant;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the pentagon wonder\n    ///@dev this function will return true if a nation has the pentagon wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getPentagon(uint256 countryId) public view returns (bool) {\n        return idToWonders3[countryId].pentagon;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the political lobbyists wonder\n    ///@dev this function will return true if a nation has the political lobbyists wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getPoliticalLobbyists(\n        uint256 countryId\n    ) public view returns (bool) {\n        return idToWonders3[countryId].politicalLobbyists;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the scientific development center wonder\n    ///@dev this function will return true if a nation has the scientific development center wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getScientificDevelopmentCenter(\n        uint256 countryId\n    ) public view returns (bool) {\n        return idToWonders3[countryId].scientificDevelopmentCenter;\n    }\n\n    ///@dev this function will return the costs of the wonders in this contract\n    function getWonderCosts3() public view returns(\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256\n    ) {\n        return (\n            movieIndustryCost,\n            nationalCemetaryCost,\n            nationalEnvironmentOfficeCost,\n            nationalResearchLabCost,\n            nationalWarMemorialCost,\n            nuclearPowerPlantCost,\n            pentagonCost,\n            politicalLobbyistsCost,\n            scientificDevelopmentCenterCost\n        );\n    }\n}\n\n///@title WondersContract4\n///@author OxSnosh\n///@dev this contract inherits from openzeppelin's ownable contract\n///@notice this contract will strore information about a nations wonders\ncontract WondersContract4 is Ownable {\n    address public treasuryAddress;\n    address public infrastructureAddress;\n    address public improvementsContract2Address;\n    address public improvementsContract3Address;\n    address public improvementsContract4Address;\n    address public wonderContract1Address;\n    address public wonderContract3Address;\n    address public countryMinter;\n    uint256 public socialSecuritySystemCost = 40000000 * (10**18);\n    uint256 public spaceProgramCost = 30000000 * (10**18);\n    uint256 public stockMarketCost = 30000000 * (10**18);\n    uint256 public strategicDefenseInitiativeCost = 75000000 * (10**18);\n    uint256 public superiorLogisticalSupportCost = 80000000 * (10**18);\n    uint256 public universalHealthcareCost = 100000000 * (10**18);\n    uint256 public weaponsResearchCenterCost = 150000000 * (10**18);\n\n    CountryMinter mint;\n\n    struct Wonders4 {\n        //Social Security System -\n        //$40,000,000-\n        //The social security system provides benefits to aging members of your nation.\n        //DONE //Allows you to raise taxes above 28% up to 30% without additional happiness penalties.\n        bool socialSecuritySystem;\n        //Space Program -\n        //$30,000,000 -\n        //The space program sends your astronauts to the moon and beyond.\n        //DONE //Increases happiness +3, lowers technology cost -3% and lowers aircraft cost -5%.\n        bool spaceProgram;\n        //Stock Market -\n        //$30,000,000 -\n        //The stock market provides a boost to your economy.\n        //DONE //Increases citizen income +$10.00\n        bool stockMarket;\n        //Strategic Defense Initiative (SDI) -\n        //$75,000,000 -\n        //DONE //Reduces odds of a successful nuclear attack against your nation by 60%.\n        //The SDI wonder also requires 3 satellites and 3 missile defenses\n        //and those satellites and missile defenses cannot be deleted once the wonder is developed.\n        bool strategicDefenseInitiative;\n        //Superior Logistical Support -\n        //$80,000,000 -\n        //Provides supplies more efficiently to your nation's military.\n        //DONE //Reduces Aircraft and Naval Maintenance Cost by -10% and\n        //DONE //Tank Maintenance Cost by -5%.\n        //DONE //Increases attacking and defending ground battle strength +10%.\n        //Requires Pentagon.\n        bool superiorLogisticalSupport;\n        //Universal Health Care -\n        //$100,000,000 -\n        //A Universal Health Care program\n        //DONE //increases population +3% and\n        //DONE //increases population happiness +2.\n        //Requires 11,000 infrastructure, Hospital, National Research Lab.\n        bool universalHealthcare;\n        //Weapons Research Complex -\n        //$150,000,000 -\n        //Increases the technology bonus to damage from 0.01% to 0.02% per technology level,\n        //DONE //Increases the number of nukes that can be purchased per day to 2,\n        //DONE //hurts environment by +1,\n        //Increases the purchase costs of all military by 0.01% per technology level.\n        //Requires 8,500 infrastructure, 2,000 technology, National Research Lab, Pentagon Wonder.\n        bool weaponsResearchCenter;\n    }\n\n    mapping(uint256 => Wonders4) public idToWonders4;\n\n    event Wonder4Purchased(uint256 indexed countryId, uint256 indexed wonderId);\n    event Wonder4Deleted(uint256 indexed countryId, uint256 indexed wonderId);\n\n    ///@dev this function is only callable by the contract owner\n    ///@dev this function will be called immediately after contract deployment in order to set contract pointers\n    function settings(\n        address _treasuryAddress,\n        address _improvementsContract2Address,\n        address _improvementsContract3Address,\n        address _improvementsContract4Address,\n        address _infrastructureAddress,\n        address _wonders1,\n        address _wonders3,\n        address _countryMinter\n    ) public onlyOwner {\n        treasuryAddress = _treasuryAddress;\n        improvementsContract2Address = _improvementsContract2Address;\n        improvementsContract3Address = _improvementsContract3Address;\n        improvementsContract4Address = _improvementsContract4Address;\n        infrastructureAddress = _infrastructureAddress;\n        wonderContract1Address = _wonders1;\n        wonderContract3Address = _wonders3;\n        countryMinter = _countryMinter;\n        mint = CountryMinter(_countryMinter);\n    }\n\n    modifier onlyCountryMinter() {\n        require(\n            msg.sender == countryMinter,\n            \"only callable from countryMinter\"\n        );\n        _;\n    }\n\n    ///@dev this function is only callable from the country minter contract\n    ///@notice this function will be called when a nation is minted and allow a nation to buy the wonders in this contract\n    function generateWonders4(uint256 id) public onlyCountryMinter {\n        Wonders4 memory newWonders4 = Wonders4(\n            false,\n            false,\n            false,\n            false,\n            false,\n            false,\n            false\n        );\n        idToWonders4[id] = newWonders4;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateSocialSecuritySystemCost(uint256 newPrice) public onlyOwner {\n        socialSecuritySystemCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateSpaceProgramCost(uint256 newPrice) public onlyOwner {\n        spaceProgramCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateStockMarketCost(uint256 newPrice) public onlyOwner {\n        stockMarketCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateStrategicDefenseInitiativeCost(\n        uint256 newPrice\n    ) public onlyOwner {\n        strategicDefenseInitiativeCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateSuperiorLogisticalSupportCost(\n        uint256 newPrice\n    ) public onlyOwner {\n        superiorLogisticalSupportCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateUniversalHealthcareCost(uint256 newPrice) public onlyOwner {\n        universalHealthcareCost = newPrice;\n    }\n\n    ///@dev this function is only callable by the contract owner\n    function updateWeaponsResearchCenterCost(\n        uint256 newPrice\n    ) public onlyOwner {\n        weaponsResearchCenterCost = newPrice;\n    }\n\n    ///@dev this function is only callable from a nation owner and allows a nation to purchase the wonders in this contract\n    ///@notice this function allows a nation owner to purchase the wonders in this contract\n    ///@param countryId is the nationId of the country purchasing a wonder\n    /**@param wonderId is the id of the wonder\n     * 1. social security system\n     * 2. space program\n     * 3. stock market\n     * 4. strategic defense initiative\n     * 5. superior logistical support\n     * 6. universal healthcare\n     * 7. weapons research center\n    */\n    function buyWonder4(uint256 countryId, uint256 wonderId) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(wonderId <= 7, \"Invalid wonder ID\");\n        uint256 balance = TreasuryContract(treasuryAddress).checkBalance(\n            countryId\n        );\n        if (wonderId == 1) {\n            require(\n                balance >= socialSecuritySystemCost,\n                \"Insufficient balance\"\n            );\n            bool existingWonder = idToWonders4[countryId].socialSecuritySystem;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders4[countryId].socialSecuritySystem = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                socialSecuritySystemCost\n            );\n        } else if (wonderId == 2) {\n            require(balance >= spaceProgramCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders4[countryId].spaceProgram;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders4[countryId].spaceProgram = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                spaceProgramCost\n            );\n        } else if (wonderId == 3) {\n            require(balance >= stockMarketCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders4[countryId].stockMarket;\n            require(existingWonder == false, \"Already owned\");\n            idToWonders4[countryId].stockMarket = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                stockMarketCost\n            );\n        } else if (wonderId == 4) {\n            require(\n                balance >= strategicDefenseInitiativeCost,\n                \"Insufficient balance\"\n            );\n            bool existingWonder = idToWonders4[countryId]\n                .strategicDefenseInitiative;\n            require(existingWonder == false, \"Already owned\");\n            uint256 missileDefenseCount = ImprovementsContract4(\n                improvementsContract4Address\n            ).getMissileDefenseCount(countryId);\n            require(\n                missileDefenseCount >= 3,\n                \"Must own at least 3 missile defense improvements\"\n            );\n            uint256 satelliteCount = ImprovementsContract3(\n                improvementsContract3Address\n            ).getSatelliteCount(countryId);\n            require(\n                satelliteCount >= 3,\n                \"Must own at least 3 satellite improvements\"\n            );\n            idToWonders4[countryId].strategicDefenseInitiative = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                strategicDefenseInitiativeCost\n            );\n        } else if (wonderId == 5) {\n            require(\n                balance >= superiorLogisticalSupportCost,\n                \"Insufficient balance\"\n            );\n            bool existingWonder = idToWonders4[countryId]\n                .superiorLogisticalSupport;\n            require(existingWonder == false, \"Already owned\");\n            bool isPentagon = WondersContract3(wonderContract3Address)\n                .getPentagon(countryId);\n            require(\n                isPentagon == true,\n                \"Pentagon required in order to purchase\"\n            );\n            idToWonders4[countryId].superiorLogisticalSupport = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                superiorLogisticalSupportCost\n            );\n        } else if (wonderId == 6) {\n            require(balance >= universalHealthcareCost, \"Insufficient balance\");\n            bool existingWonder = idToWonders4[countryId].universalHealthcare;\n            require(existingWonder == false, \"Already owned\");\n            uint256 infrastructureAmount = InfrastructureContract(\n                infrastructureAddress\n            ).getInfrastructureCount(countryId);\n            require(\n                infrastructureAmount >= 11000,\n                \"Must have 11000 Infrastructure to purchase\"\n            );\n            uint256 hospitalAmount = ImprovementsContract2(\n                improvementsContract2Address\n            ).getHospitalCount(countryId);\n            require(\n                hospitalAmount > 0,\n                \"Hospital improvement required to purchase\"\n            );\n            bool researchLab = WondersContract3(wonderContract3Address)\n                .getNationalResearchLab(countryId);\n            require(\n                researchLab == true,\n                \"National Research Lab required to Purchase\"\n            );\n            idToWonders4[countryId].universalHealthcare = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                universalHealthcareCost\n            );\n        } else {\n            require(\n                balance >= weaponsResearchCenterCost,\n                \"Insufficient balance\"\n            );\n            bool existingWonder = idToWonders4[countryId].weaponsResearchCenter;\n            require(existingWonder == false, \"Already owned\");\n            bool isPentagon = WondersContract3(wonderContract3Address)\n                .getPentagon(countryId);\n            require(\n                isPentagon == true,\n                \"Pentagon required in order to purchase\"\n            );\n            bool researchLab = WondersContract3(wonderContract3Address)\n                .getNationalResearchLab(countryId);\n            require(\n                researchLab == true,\n                \"National Research Lab required to Purchase\"\n            );\n            uint256 infrastructureAmount = InfrastructureContract(\n                infrastructureAddress\n            ).getInfrastructureCount(countryId);\n            require(\n                infrastructureAmount >= 8500,\n                \"Must have 8500 Infrastructure to purchase\"\n            );\n            uint256 techAmount = InfrastructureContract(infrastructureAddress)\n                .getTechnologyCount(countryId);\n            require(\n                techAmount >= 2000,\n                \"Must have 2000 Technology to purchase\"\n            );\n            idToWonders4[countryId].weaponsResearchCenter = true;\n            WondersContract1(wonderContract1Address).addWonderCount(countryId);\n            TreasuryContract(treasuryAddress).spendBalance(\n                countryId,\n                weaponsResearchCenterCost\n            );\n        }\n        emit Wonder4Purchased(countryId, wonderId);\n    }\n\n    function deleteWonder4(uint256 countryId, uint256 wonderId) public {\n        bool isOwner = mint.checkOwnership(countryId, msg.sender);\n        require(isOwner, \"!nation owner\");\n        require(wonderId <= 7, \"Invalid wonder ID\");\n        if (wonderId == 1) {\n            bool existingWonder = idToWonders4[countryId].socialSecuritySystem;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders4[countryId].socialSecuritySystem = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 2) {\n            bool existingWonder = idToWonders4[countryId].spaceProgram;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders4[countryId].spaceProgram = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 3) {\n            bool existingWonder = idToWonders4[countryId].stockMarket;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders4[countryId].stockMarket = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 4) {\n            bool existingWonder = idToWonders4[countryId]\n                .strategicDefenseInitiative;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders4[countryId].strategicDefenseInitiative = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 5) {\n            bool existingWonder = idToWonders4[countryId]\n                .superiorLogisticalSupport;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders4[countryId].superiorLogisticalSupport = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else if (wonderId == 6) {\n            bool existingWonder = idToWonders4[countryId].universalHealthcare;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders4[countryId].universalHealthcare = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        } else {\n            bool existingWonder = idToWonders4[countryId].weaponsResearchCenter;\n            require(existingWonder == true, \"No wonder to delete\");\n            idToWonders4[countryId].weaponsResearchCenter = false;\n            WondersContract1(wonderContract1Address).subtractWonderCount(\n                countryId\n            );\n        }\n        emit Wonder4Deleted(countryId, wonderId);\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the social security system wonder\n    ///@dev this function will return true if a nation has the social security system wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getSocialSecuritySystem(\n        uint256 countryId\n    ) public view returns (bool) {\n        return idToWonders4[countryId].socialSecuritySystem;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the space program wonder\n    ///@dev this function will return true if a nation has the space program wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getSpaceProgram(uint256 countryId) public view returns (bool) {\n        return idToWonders4[countryId].spaceProgram;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the stock market wonder\n    ///@dev this function will return true if a nation has the stock market wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getStockMarket(uint256 countryId) public view returns (bool) {\n        return idToWonders4[countryId].stockMarket;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the strategic defense initiative wonder\n    ///@dev this function will return true if a nation has the strategic defense initiative wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getStrategicDefenseInitiative(\n        uint256 countryId\n    ) public view returns (bool) {\n        return idToWonders4[countryId].strategicDefenseInitiative;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the superior logistical support wonder\n    ///@dev this function will return true if a nation has the superior logistical support wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getSuperiorLogisticalSupport(\n        uint256 countryId\n    ) public view returns (bool) {\n        return idToWonders4[countryId].superiorLogisticalSupport;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the universal healthcare wonder\n    ///@dev this function will return true if a nation has the universal healthcare wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getUniversalHealthcare(\n        uint256 countryId\n    ) public view returns (bool) {\n        return idToWonders4[countryId].universalHealthcare;\n    }\n\n    ///@dev this is a public view function that will return true if a nation has the weapons research center wonder\n    ///@dev this function will return true if a nation has the weapons research center wonder\n    ///@param countryId is the nation id of the nation being queried\n    ///@return bool will be true if the nation has the wonder\n    function getWeaponsResearchCenter(\n        uint256 countryId\n    ) public view returns (bool) {\n        return idToWonders4[countryId].weaponsResearchCenter;\n    }\n\n    ///@dev this function will return the costs of the wonders in this contract\n    function getWonderCosts4() public view returns(\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256\n    ) {\n        return (\n            socialSecuritySystemCost,\n            spaceProgramCost,\n            stockMarketCost,\n            strategicDefenseInitiativeCost,\n            superiorLogisticalSupportCost,\n            universalHealthcareCost,\n            weaponsResearchCenterCost\n        );\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}